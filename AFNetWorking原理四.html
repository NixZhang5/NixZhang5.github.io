<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>AFNetWorking原理四 AFURLResponseSerialization | Xinping&#39;s Blog | 因为有了危机感，所以才会义无反顾。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="AFNetWorking原理">
    <meta name="description" content="AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。">
<meta name="keywords" content="AFNetWorking原理">
<meta property="og:type" content="article">
<meta property="og:title" content="AFNetWorking原理四 AFURLResponseSerialization">
<meta property="og:url" content="https://nixzhang5.github.io/AFNetWorking原理四.html">
<meta property="og:site_name" content="Xinping&#39;s Blog">
<meta property="og:description" content="AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-06-28T09:03:10.316Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AFNetWorking原理四 AFURLResponseSerialization">
<meta name="twitter:description" content="AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。">
    
        <link rel="alternate" type="application/atom+xml" title="Xinping&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">张新平</h5>
          <a href="mailto:351235445@qq.com" title="351235445@qq.com" class="mail">351235445@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/NixZhang5" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">AFNetWorking原理四 AFURLResponseSerialization</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">AFNetWorking原理四 AFURLResponseSerialization</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-06-28T06:06:40.000Z" itemprop="datePublished" class="page-time">
  2019-06-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#模块结构"><span class="post-toc-number">1.</span> <span class="post-toc-text">模块结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AFHTTPResponseSerializer"><span class="post-toc-number">2.</span> <span class="post-toc-text">AFHTTPResponseSerializer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AFJSONResponseSerializer"><span class="post-toc-number">3.</span> <span class="post-toc-text">AFJSONResponseSerializer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer"><span class="post-toc-number">4.</span> <span class="post-toc-text">AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AFImageResponseSerializer"><span class="post-toc-number">5.</span> <span class="post-toc-text">AFImageResponseSerializer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AFCompoundResponseSerializer"><span class="post-toc-number">6.</span> <span class="post-toc-text">AFCompoundResponseSerializer</span></a></li></ol>
        </nav>
    </aside>


<article id="post-AFNetWorking原理四"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">AFNetWorking原理四 AFURLResponseSerialization</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-06-28 14:06:40" datetime="2019-06-28T06:06:40.000Z"  itemprop="datePublished">2019-06-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。</p>
<a id="more"></a>

<h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>AFURLResponseSerialization协议，通过协议来处理返回值，代码结构清晰、易于扩展</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"><span class="comment">// 对返回的数据进行解析，解析response为对应的数据类型（JSON、XML、plist、Image）,AFHTTPResponseSerializer的子类会重写这个方法，根据不同的需要解析成不同的结果，如AFJSONResponseSerializer会将数据解析成为JSON数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>父类</p>
<ul>
<li>AFHTTPResponseSerializer遵循AFURLResponseSerialization协议</li>
</ul>
<p>子类 所有子类都遵循AFURLResponseSerialization协议</p>
<ul>
<li>AFJSONResponseSerializer          JSON响应</li>
<li>AFXMLParserResponseSerializer     XMLParse响应</li>
<li>AFXMLDocumentResponseSerializer   XMLDocument响应</li>
<li>AFPropertyListResponseSerializer  PropertyList响应</li>
<li>AFImageResponseSerializer         Image响应</li>
<li>AFCompoundResponseSerializer      符合响应</li>
</ul>
<h3 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h3><p>对返回数据进行解析的父类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPResponseSerializer</span> : <span class="title">NSObject</span> &lt;<span class="title">AFURLResponseSerialization</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)serializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Configuring Response Serialization</span></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置接收的状态码，不在接受范围内的状态码会在验证时返回错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSIndexSet</span> *acceptableStatusCodes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置接收的contentTypes，不在范围内的contentType会在验证时返回错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSString</span> *&gt; *acceptableContentTypes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    验证服务器返回的数据，这个会使用到NSIndexSet *acceptableStatusCodes，NSIndexSet *acceptableStatusCodes这两个属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="keyword">nullable</span> <span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>初始化成功的状态码默认值 200 ~ 299</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">类别</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">信息性状态码</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">成功状态码</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">重定向状态码</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">客户端错误状态码</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">服务器错误状态码</td>
<td align="left">服务器处理请求出错</td>
</tr>
</tbody></table>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.acceptableStatusCodes = [<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">    <span class="keyword">self</span>.acceptableContentTypes = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证响应和数据的有效性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证响应和数据的有效性（验证MIMEType和status code）。子类可添加其他特定域的检查。</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;<span class="comment">//response是否合法</span></span><br><span class="line">    <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//response是否存在和类型判断，如果response为空或者不是NSHTTPURLResponse类型，responseIsValid=YES!</span></span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//根据在初始化方法中初始化的属性 acceptableContentTypes 和 acceptableStatusCodes 来判断当前响应是否有效</span></span><br><span class="line">        <span class="comment">//1.response的内容类型不对（MIMEType）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">            !([response MIMEType] == <span class="literal">nil</span> &amp;&amp; [data length] == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//数据解析失败</span></span><br><span class="line">            <span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line">                <span class="comment">//NSLocalizedDescriptionKey是NSError头文件中预定义的键，标识错误的本地化描述.可以通过NSError的localizedDescription方法获得对应的值信息</span></span><br><span class="line">                <span class="comment">//NSURLErrorFailingURLErrorKey相应的值是包含导致加载失败的URL的NSURL。 此键仅存在于NSURLErrorDomain中。</span></span><br><span class="line">                <span class="comment">//生成错误信息字典。会返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中</span></span><br><span class="line">                <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                                          <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: unacceptable content-type: %@"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                                                          <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                                        &#125; mutableCopy];</span><br><span class="line">                <span class="keyword">if</span> (data) &#123;                    </span><br><span class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//+errorWithDomain: code: userInfo:创建和初始化NSError对象</span></span><br><span class="line">                <span class="comment">//NSErrorDomain错误域 - 这可以是预定义的NSError域之一，也可以是描述自定义域的任意字符串。 域名不能为空。</span></span><br><span class="line">                <span class="comment">//收到的内容数据具有未知内容编码（解析数据出错）。NSURLErrorCannotDecodeContentData = -1016，NSError错误码</span></span><br><span class="line">                <span class="comment">//出现错误时通过AFErrorWithUnderlyingError函数生成本地格式化的错误</span></span><br><span class="line">                validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.状态码无效</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">            <span class="comment">//-localizedStringForStatusCode:根据状态码获取本地化文本内容</span></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                               <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: %@ (%ld)"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response.statusCode], (<span class="keyword">long</span>)response.statusCode],</span><br><span class="line">                                               <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                       &#125; mutableCopy];</span><br><span class="line">            <span class="keyword">if</span> (data) &#123;                </span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//收到从服务器来的错误数据 NSURLErrorBadServerResponse = -1011,NSError错误码</span></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">            responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorCannotDecodeContentData。</span></span><br><span class="line"><span class="comment">如果MIME type不满足，，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorBadServerResponse。</span></span><br><span class="line"><span class="comment"> 2.方法中，有可能会出现两个错误，在self.acceptableContentTypes和self.acceptableStatusCodes这两个判断中，如果都出现错误怎么办呢？</span></span><br><span class="line"><span class="comment"> 这就用到了NSUnderlyingErrorKey 这个字段，它表示一个优先的错误，value为NSError对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ol>
<li>根据初始化中的属性acceptableContentTypes和acceptableStatusCodes判断响应是否有效。</li>
<li>content-type不对，返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中。MIME type不对，处理相似，这里不展开。</li>
</ol>
<p>这个记录了错误信息的字典，系统提供的KEY值：</p>
<ul>
<li><p>NSError的Key:</p>
<ul>
<li>NSUnderlyingErrorKey                  优先错误，value是NSError</li>
<li>NSLocalizedDescriptionKey             错误描述</li>
<li>NSLocalizedFailureReasonErrorKey      错误的简要说明</li>
<li>NSLocalizedRecoverySuggestionErrorKey 修复建议</li>
<li>NSLocalizedRecoveryOptionErrorKey     修复选项</li>
</ul>
</li>
<li><p>NSURLError</p>
<ul>
<li>NSURLErrorFailingURLErrorKey</li>
<li>NSURLErrorFailingURLStringErrorKey</li>
<li>NSErrorFailingURLStringKey</li>
<li>NSURLErrorFailingURLPeeTrustErrorKey</li>
<li>NSURLErrorBackgroundTaskCancelledReasonKey</li>
</ul>
</li>
</ul>
<p>AF中自定义了AFNetworkingOperationFailingURLResponseErrorKey和AFNetworkingOperationFailingURLResponseDataErrorKey。</p>
<ol start="3">
<li>出现错误时通过AFErrorWithUnderlyingError函数生成本地格式化的错误。<br> 3.1 如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为 NSURLErrorCannotDecodeContentData的自定义NSError。<br> 3.2 如果MIME type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为 NSURLErrorBadServerResponse的自定义NSError。</li>
<li>如果content type和MIMEtype同时出错，这就用到了NSUnderlyingErrorKey这个字段，它表示一个优先的错误，value为NSError对象。</li>
</ol>
<p>具体看下面这个函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成本地格式化的错误。填充错误信息，一些处理过程中产生的错误信息填充到我们需要返回给用户的自定义错误中</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSError</span> * AFErrorWithUnderlyingError(<span class="built_in">NSError</span> *error, <span class="built_in">NSError</span> *underlyingError) &#123;</span><br><span class="line">    <span class="comment">//NSUnderlyingErrorKey表示优先错误</span></span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!underlyingError || error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[<span class="built_in">NSUnderlyingErrorKey</span>] = underlyingError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSError</span> alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在两者都出错的情况下，那么UnderlyingError就是content type error。</p>
<p>AFURLResponseSerialization协议的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从与指定响应相关联的数据中decode得到的响应对象。</span></span><br><span class="line"> - (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error&#123;</span><br><span class="line">    <span class="comment">//调用验证方法，返回data</span></span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把验证方法调用完之后就返回data，没有其他实现了。</p>
<h3 id="AFJSONResponseSerializer"><a href="#AFJSONResponseSerializer" class="headerlink" title="AFJSONResponseSerializer"></a>AFJSONResponseSerializer</h3><p>可接受的数据类型：application/json，text/json，text/javascript。<br>实现协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//验证MIMEType和status code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="comment">//error为空或者 错误、优先错误匹配error code和domain（在这里是content type类型的错误）</span></span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">    <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line">    <span class="comment">//数据是否是一个空格</span></span><br><span class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">" "</span> length:<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//如果数据为空或者是空格，就不json解析</span></span><br><span class="line">    <span class="keyword">if</span> (data.length == <span class="number">0</span> || isSpace) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//json解析。NSJSON只支持解析UTF8编码的数据</span></span><br><span class="line">    <span class="keyword">id</span> responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseObject)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">//用json解析的error去填充错误信息</span></span><br><span class="line">            *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否要从响应的JSON数据中删除带有“NSNull”值的键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>验证响应<br>验证失败。在没有error 或者 错误中的code是NSURLErrorCannotDecodeContentData（即content type不匹配）的情况下，是不能解析数据的，就返回nil。用到的函数：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测错误或者优先错误中是否匹配code和domain</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFErrorOrUnderlyingErrorHasCodeInDomain(<span class="built_in">NSError</span> *error, <span class="built_in">NSInteger</span> code, <span class="built_in">NSString</span> *domain) &#123;</span><br><span class="line">    <span class="comment">//判断错误域和传过来的域名是否一致，错误code是否一致</span></span><br><span class="line">    <span class="keyword">if</span> ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;<span class="comment">//如果NSUnderlyingErrorKey对应有值，就再进行判断</span></span><br><span class="line">        <span class="keyword">return</span> AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>], code, domain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>处理返回的数据中只有空格的情况<br>如果数据为空或者只有一个空格，就不解析。</p>
</li>
<li><p>解析JSON<br>readingOptions属性设置json的读取选项。这里的默认值是NSJSONReadingMutableContainers</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSJSONReadingOptions</span>) &#123;</span><br><span class="line">    <span class="comment">//返回可变容器，NSMutableDictionary或NSMutableArray</span></span><br><span class="line">    <span class="built_in">NSJSONReadingMutableContainers</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), </span><br><span class="line">    <span class="comment">//返回的JSON对象中字符串的值为NSMutableString</span></span><br><span class="line">    <span class="built_in">NSJSONReadingMutableLeaves</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    <span class="comment">//允许JSON字符串最外层既不是NSArray也不是NSDictionary，但必须是有效的JSON Fragment。例如使用这个选项可以解析 @“123” 这样的字符串。</span></span><br><span class="line">    <span class="built_in">NSJSONReadingAllowFragments</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>是否要从响应的JSON数据中删除带有“NSNull”值的键<br>用到的函数：主要通过递归的手段来实现的。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从响应的JSON数据中删除带有“NSNull”值的键</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="comment">//遍历数组，通过递归的手段清空数组内的null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按位与操作，解析类型是否NSJSONReadingMutableContainers（mutableArray或者mutabledictionary）</span></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字典</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer"><a href="#AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer" class="headerlink" title="AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer"></a>AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer</h3><p>AFXMLParserResponseSerializer用来解析XML数据，支持的ContentType：application/xml、text/xml。<br>AFXMLDocumentResponseSerializer同上，但这个类只能在mac os x上使用。<br>AFPropertyListResponseSerializer用来解析plist数据，支持的ContentType：application/x-plist。<br>这三个子类的实现和上面JSON子类的实现差不多，就不具体展开了。</p>
<h3 id="AFImageResponseSerializer"><a href="#AFImageResponseSerializer" class="headerlink" title="AFImageResponseSerializer"></a>AFImageResponseSerializer</h3><p>用于验证和解码图像响应。</p>
<p>支持的ContentType：<br>image/tiff、image/jpeg、image/gif、image/png、image/ico、image/x-icon、image/bmp、image/x-bmp、image/x-xbitmap、image/x-win-bitmap</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//验证MIME type和status code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图片解压。宏判断是那种设备，进行对应的图片解压处理</span></span><br><span class="line"><span class="meta">#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.automaticallyInflatesResponseImage) &#123;<span class="comment">//是否对响应的图片进行自动处理</span></span><br><span class="line">        <span class="keyword">return</span> AFInflatedImageFromResponseWithDataAtScale((<span class="built_in">NSHTTPURLResponse</span> *)response, data, <span class="keyword">self</span>.imageScale);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AFImageWithDataAtScale(data, <span class="keyword">self</span>.imageScale);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// Ensure that the image is set to it's correct pixel width and height</span></span><br><span class="line">    <span class="built_in">NSBitmapImageRep</span> *bitimage = [[<span class="built_in">NSBitmapImageRep</span> alloc] initWithData:data];</span><br><span class="line">    <span class="built_in">NSImage</span> *image = [[<span class="built_in">NSImage</span> alloc] initWithSize:<span class="built_in">NSMakeSize</span>([bitimage pixelsWide], [bitimage pixelsHigh])];</span><br><span class="line">    [image addRepresentation:bitimage];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里用到了几个方法，写在了UIImage分类UIImage (AFNetworkingSafeImageLoading)里面。下面来看一下分类中的这几个方法：</p>
<ol>
<li>把NSData安全地转换为UIImage。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)af_safeImageWithData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">UIImage</span>* image = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        imageLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    [imageLock lock];<span class="comment">//上锁</span></span><br><span class="line">    image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    [imageLock unlock];<span class="comment">//开锁</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们读写一个数据的时候，由于数据还可能被别人读写，这就有可能出现不安全的情况，为了解决这个问题，就使用了“锁”。如果对线程锁比较熟悉的话就容易理解了，简单说呢，就是在写数据前先上锁，那么别人就无法使用这块数据了，直到你执行完数据操作、解锁。</p>
<ol start="2">
<li>私有函数，按照scale对图片进行伸缩处理</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个按照scale收缩的图片</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">UIImage</span> * AFImageWithDataAtScale(<span class="built_in">NSData</span> *data, <span class="built_in">CGFloat</span> scale) &#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> af_safeImageWithData:data];</span><br><span class="line">    <span class="keyword">if</span> (image.images) &#123;<span class="comment">//gif图不需要伸缩</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">UIImage</span> alloc] initWithCGImage:[image <span class="built_in">CGImage</span>] scale:scale orientation:image.imageOrientation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于image.images：这个属性第一次接触，大致看了一下，常见的应用是用来生成一个gif效果。在gif图中表示这个Gif包含了多少张图片。</p>
<ol start="3">
<li>根据响应结果和scale返回一张图片.完成图像解压工作</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">UIImage</span> * AFInflatedImageFromResponseWithDataAtScale(<span class="built_in">NSHTTPURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">CGFloat</span> scale)</span><br></pre></td></tr></table></figure>

<p>这个函数实现很长，用到了CoreGraphics上的一些东西，主要完成iOS、TV、Watch设备下的图像解压工作。关于图像解压的目的，我在这篇文章中读到这么一段话：</p>
<blockquote>
<p>AFJSONResponseSerializer使用系统内置的NSJSONSerialization解析json，NSJSON只支持解析UTF8编码的数据（还有UTF-16LE之类的，都不常用），所以要先把返回的数据转成UTF8格式。这里会尝试用HTTP返回的编码类型和自己设置的stringEncoding去把数据解码转成字符串NSString，再把NSString用UTF8编码转成NSData，再用NSJSONSerialization解析成对象返回。<br><br>上述过程是NSData-&gt;NSString-&gt;NSData-&gt;NSObject，这里有个问题，如果你能确定服务端返回的是UTF8编码的json数据，那NSData-&gt;NSString-&gt;NSData这两步就是无意义的，而且这两步进行了两次编解码，很浪费性能，所以如果确定服务端返回utf8编码数据，就建议自己再写个JSONResponseSerializer，跳过这两个步骤。<br><br>此外AFJSONResponseSerializer专门写了个方法去除NSNull，直接把对象里值是NSNull的键去掉，还蛮贴心，若不去掉，上层很容易忽略了这个数据类型，判断了数据是否nil没判断是否NSNull，进行了错误的调用导致core。<br><br><strong>图片解压</strong><br><br>当我们调用UIImage的方法imageWithData:方法把数据转成UIImage对象后，其实这时UIImage对象还没准备好需要渲染到屏幕的数据，现在的网络图像PNG和JPG都是压缩格式，需要把它们解压转成bitmap后才能渲染到屏幕上，如果不做任何处理，当你把UIImage赋给UIImageView，在渲染之前底层会判断到UIImage对象未解压，没有bitmap数据，这时会在主线程对图片进行解压操作，再渲染到屏幕上。这个解压操作是比较耗时的，如果任由它在主线程做，可能会导致速度慢UI卡顿的问题。<br><br>AFImageResponseSerializer除了把返回数据解析成UIImage外，还会把图像数据解压，这个处理是在子线程（AFNetworking专用的一条线程，详见AFURLConnectionOperation），处理后上层使用返回的UIImage在主线程渲染时就不需要做解压这步操作，主线程减轻了负担，减少了UI卡顿问题。<br>具体实现上在AFInflatedImageFromResponseWithDataAtScale里，创建一个画布，把UIImage画在画布上，再把这个画布保存成UIImage返回给上层。只有JPG和PNG才会尝试去做解压操作，期间如果解压失败，或者遇到CMKY颜色格式的jpg，或者图像太大(解压后的bitmap太占内存，一个像素3-4字节，搞不好内存就爆掉了)，就直接返回未解压的图像。<br><br>另外在代码里看到iOS才需要这样手动解压，MacOS上已经有封装好的对象NSBitmapImageRep可以做这个事。</p>
</blockquote>
<h3 id="AFCompoundResponseSerializer"><a href="#AFCompoundResponseSerializer" class="headerlink" title="AFCompoundResponseSerializer"></a>AFCompoundResponseSerializer</h3><p>这是一个对复合类型的响应进行处理的子类。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历数组，只要是属于AFHTTPResponseSerializer及其子类的类型，就执行相应的响应操作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> &lt;AFURLResponseSerialization&gt; serializer <span class="keyword">in</span> <span class="keyword">self</span>.responseSerializers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![serializer isKindOfClass:[AFHTTPResponseSerializer <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSError</span> *serializerError = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">id</span> responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError];</span><br><span class="line">        <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = AFErrorWithUnderlyingError(serializerError, *error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> responseObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上类型都不是，就执行默认响应操作。</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> responseObjectForResponse:response data:data error:error];<span class="comment">//调用父类方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>responseSerializers属性，这个数组中装着多种序列化类型，比如上面讲到的JSON、XML等等。<br>遍历数组，只要是属于AFHTTPResponseSerializer及其子类的类型，就执行相应的响应操作。如果以上类型都不是，就执行默认的响应。</p>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="https://nixzhang5.github.io">
            <img src="/img/avatar.jpg" alt="张新平">
            张新平
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AFNetWorking原理/">AFNetWorking原理</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://nixzhang5.github.io/AFNetWorking原理四.html&title=《AFNetWorking原理四 AFURLResponseSerialization》 — Xinping's Blog&pic=https://nixzhang5.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://nixzhang5.github.io/AFNetWorking原理四.html&title=《AFNetWorking原理四 AFURLResponseSerialization》 — Xinping's Blog&source=AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://nixzhang5.github.io/AFNetWorking原理四.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《AFNetWorking原理四 AFURLResponseSerialization》 — Xinping's Blog&url=https://nixzhang5.github.io/AFNetWorking原理四.html&via=https://nixzhang5.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://nixzhang5.github.io/AFNetWorking原理四.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/AFNetWorking原理五.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">AFNetWorking原理五 AFNetworkReachabilityManager</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/AFNetWorking原理三.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">AFNetWorking原理三 AFURLRequestSerialization</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>张新平 &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://nixzhang5.github.io/AFNetWorking原理四.html&title=《AFNetWorking原理四 AFURLResponseSerialization》 — Xinping's Blog&pic=https://nixzhang5.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://nixzhang5.github.io/AFNetWorking原理四.html&title=《AFNetWorking原理四 AFURLResponseSerialization》 — Xinping's Blog&source=AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://nixzhang5.github.io/AFNetWorking原理四.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《AFNetWorking原理四 AFURLResponseSerialization》 — Xinping's Blog&url=https://nixzhang5.github.io/AFNetWorking原理四.html&via=https://nixzhang5.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://nixzhang5.github.io/AFNetWorking原理四.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMklEQVR42u3aQY6DMAwF0N7/0ow0q5FG0G+HVsJ5WVUtgTwWbmzn9YrH8TvOvjn+jLPr/195Nuts7g0DAwPjsYzjclQfny/u+vp8bRgYGPswroPs9S2SUJtcWQ3cGBgYGNXb5cvKXwQGBgZGb4nVZLW3DcXAwMBYufUn5ibf3JaLY2BgPJBRbQx88/MH+xsYGBgPYRzFkc/qbRabq8LAwBjNyFuJvYMXeUjNg2xhh4uBgTGCkaeRKw2DlUJb0kjAwMDYmZG0Hqshu/fK3gRuDAyM0YzrUJj8ul7iz19fOYnFwMAYxMhDYQLoHQtbOWqGgYGxG+OuIJikpitNzah2iIGBMYiRB9ZealotuvWei4GBMZtRbUauLC4q9C/jMTAwJjHyDVxvEb30tbytxMDA2ICRl+x7G8EkdPYOW2BgYOzASErz5clxAO2V267vhoGBMZWRh7Zqmax3RKN57AwDA2Moo1pcqwbcakrcLNhhYGCMZvS2ayuhNvoHWNkaYmBgjGMkxbVqqE0CaK/leUrFwMDYklFtT/aaBNWS3CkJAwNjNKOXiFYLZHmmuZISY2BgTGWsbNqqh72q1xf+DDAwMEYzqmEuiW/VWdVTIYUzIxgYGIMYybI+0eDsNQ/etDAxMDBGM5IgmwfTpJTWK5+9qR1iYGBsz+ht4PIGwMp6MDAwMPKQupKU5hk2BgbGnow8ie01GnufC+0KDAyM0YxqY6C3+bsOzXmJ7YYzIxgYGE9i/ABjFFH3+v70egAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来！';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
