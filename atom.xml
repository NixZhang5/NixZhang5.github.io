<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinping&#39;s Blog</title>
  
  <subtitle>因为有了危机感，所以才会义无反顾。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nixzhang5.github.io/"/>
  <updated>2019-07-03T11:01:49.485Z</updated>
  <id>https://nixzhang5.github.io/</id>
  
  <author>
    <name>张新平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>离屏渲染</title>
    <link href="https://nixzhang5.github.io/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93.html"/>
    <id>https://nixzhang5.github.io/离屏渲染.html</id>
    <published>2019-07-03T10:09:32.000Z</published>
    <updated>2019-07-03T11:01:49.485Z</updated>
    
    <content type="html"><![CDATA[<p>渲染机制：<br>CPU将计算好的需要显示的内容提交给GPU，GPU渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照Vsync(垂直脉冲)信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器进行显示。</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//nixzhang5.github.io/draw-principle.png" alt="渲染机制图" title>                </div>                <div class="image-caption">渲染机制图</div>            </figure><h3 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h3><p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用：</p><ul><li>CPU(Central Processing Unit, 中央处理器)就是机器的“大脑”，也是布局谋略、发号施令、控制行动的“总司令官”。</li><li>CPU的结构主要包括运算器（ALU, Arithmetic and Logic Unit）、控制单元（CU, Control Unit）、寄存器（Register）、高速缓存器（Cache）和它们之间通 讯的数据、控制及状态的总线。</li><li>GPU全称为Graphics Processing Unit，中文为图形处理器，就如它的名字一样，GPU最初是用在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上运行绘图运算工作的微处理器。</li></ul><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存，即GPU会预先渲染好一帧放入一个缓冲区内（前帧缓存），让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器（后帧缓存）。当你视频控制器已经读完一帧，准备读下一帧的时候，GPU会等待显示器的VSync信号发出后，前帧缓存和后帧缓存会瞬间切换，后帧缓存会变成新的前帧缓存，同时旧的前帧缓存会变成新的后帧缓存。</p><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象。</p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h3 id="屏幕成像原理"><a href="#屏幕成像原理" class="headerlink" title="屏幕成像原理"></a>屏幕成像原理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//nixzhang5.github.io/signal.png" alt="同步信号" title>                </div>                <div class="image-caption">同步信号</div>            </figure><p>显示器 显示出来的图像是经过 CRT电子枪一行一行的扫描。（可以是横向的也可以是纵向，具体CRT电子枪又是什么，百度文库介绍的很详细。）扫描出来就呈现了一帧画面，随后电子枪又会回到初始位置循环扫描，为了让显示器的显示跟视频控制器同步，当电子枪新扫描一行的时候。准备扫描的时候，会发送一个 水平同步信号(HSync信号)，而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization简称 VSync），显示器一般是固定刷新频率的，这个刷新的频率其实就是VSync信号产生的频率。然后CPU计算好frame等属性，就将计算好的内容提交给GPU去渲染，GPU渲染完成之后就会放入帧缓冲区，然后视频控制器会按照VSync信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器就显示出来了。</p><h3 id="卡顿原因"><a href="#卡顿原因" class="headerlink" title="卡顿原因"></a>卡顿原因</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//nixzhang5.github.io/caton.png" alt="卡顿原因" title>                </div>                <div class="image-caption">卡顿原因</div>            </figure><p>在Sync信号到来后，系统图形服务会通过CADisplayLink等机制通知App，App主线程开始在CPU中计算显示内容，比如视图的创建，布局计算，图片解码，文本绘制等。随后CPU会将计算好的内容提交到GPU去，由GPU进行交换，合成，渲染。随后GPU会把渲染结果提交到帧缓冲区，等待下一次VSync信号（垂直同步信号）到来时显示到屏幕上。由于垂直同步机制，如果在一个VSync时间内，CPU或者GPU没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏因为没有新的刷新，会保留之前的内容不变。这就造成了卡顿。</p><p>按照60FPS的刷帧率，每隔16ms就会有一次VSync信号，也就是说在这个间隔时间内CPU和GPU没有把内容提交。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p><h3 id="屏幕渲染"><a href="#屏幕渲染" class="headerlink" title="屏幕渲染"></a>屏幕渲染</h3><p>OpenGL中,GPU屏幕渲染有两种方式：</p><ol><li>On-Screen Rendering (当前屏幕渲染)<br>指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。</li><li>Off-Screen Rendering (离屏渲染)<br>指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。</li></ol><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>相比于当前屏幕渲染，离屏渲染的代价很高，主要体现在以下两个方面:</p><ol><li>创建新缓冲区<br>要想进行离屏渲染，首先需要创建一个新的缓冲区。</li><li>上下文切换<br>离屏渲染的整个过程，需要多次进行上下文切换：先从当前屏幕(On-Screen)到离屏(Off-Screen)；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换会导致GPU产生空闲，而GPU拥有大量的并行计算的处理单元，这些处理单元都空闲，会产生巨大的浪费。</li></ol><h4 id="特殊的离屏渲染-CPU渲染"><a href="#特殊的离屏渲染-CPU渲染" class="headerlink" title="特殊的离屏渲染:CPU渲染"></a>特殊的离屏渲染:CPU渲染</h4><p>如果重写了drawRect方法，并且使用任何Core Graphics 的技术进行了绘制操作，就涉及到CPU渲染。整个渲染过程由CPU在App内同步完成，渲染得到的bitmap(位图)最后再交由GPU用于显示。<br>CoreGraphic通常是线程安全的，所以可以进行一步绘制，显示的时候再回主线程，一个简单异步绘制内容如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">   <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">       <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">       <span class="comment">// draw in context...</span></span><br><span class="line">       <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">       <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">       <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">           layer.contents = img;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么产生离屏渲染"><a href="#为什么产生离屏渲染" class="headerlink" title="为什么产生离屏渲染"></a>为什么产生离屏渲染</h4><p>离屏渲染产生的原因主要有两方面：</p><ol><li>在VSync(垂直脉冲)信号作用下，视频控制器每隔16.67ms就会去帧缓冲区(当前屏幕缓冲区)读取渲染后的数据；但是有些效果被认为不能直接呈现于屏幕前，而需要在别的地方做额外的处理，进行预合成。<br> 比如图层属性的混合体再没有预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前必须在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</li><li>有些视图渲染后的纹理需要被多次复用，但屏幕内的渲染缓冲区是实时更新的，所以需要通过开辟屏幕外的渲染缓冲区，将视图的内容渲染成纹理并缓存，然后再需要的时候在调入屏幕缓冲区，可以避免多次渲染的开销。<br> 典型的例子就是光栅化。光栅化就是通过把视图的内容渲染成纹理并缓存，等到下次调用的时候直接去缓存的取出纹理，但是更新内容时候，会启用离屏渲染，所以更新的代价比较大，只能用于静态内容；而且如果光栅化的元素100ms没有被使用，也将被移除，故而不常用元素的光栅化并不会优化显示。</li></ol><h4 id="哪些操作会触发离屏渲染"><a href="#哪些操作会触发离屏渲染" class="headerlink" title="哪些操作会触发离屏渲染"></a>哪些操作会触发离屏渲染</h4><p>官方公开的的资料里关于离屏渲染的信息最早是在 2011年的 WWDC， 在多个 session 里都提到了尽量避免会触发离屏渲染的效果，包括：mask, shadow, group opacity, edge antialiasing。</p><ul><li>shouldRasterize（光栅化）将图转化为一个个栅格组成的图象。 光栅化特点：每个元素对应帧缓冲区中的一像素。</li><li>masks（遮罩）</li><li>shadows（阴影）</li><li>edge antialiasing（抗锯齿）</li><li>group opacity（不透明）</li><li>复杂形状设置圆角等</li><li>渐变</li><li>Text（UILabel, CATextLayer, Core Text, etc）…</li></ul><p>shouldRasterize = YES在其它属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer或者 sublayers没有发生改变，在下一帧的时候可以直接复用，从而减少渲染的频率。<br>当使用光栅化是，可以开启”Color Hits Green and Misses Red”来检查该场景下是否适合选择光栅化，绿色表示缓存被复用，红色表示缓存在被重复创建。对于经常变动的内容，不要开启，否则会造成性能的浪费。<br>如果cell里面的内容不断变化(cell的复用)，如果设置了cell.layer.shouldRaseterize = YES则会降低图形性能,造成离屏渲染.</p><p>代码里面会用到下面的方法去提高性能</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell.layer.shouldRasterize = <span class="literal">true</span></span><br><span class="line">cell.layer.rasterizationScale = cell.layer.contentsScale</span><br></pre></td></tr></table></figure><p><code>shouldRasterize这个属性打开不是会造成离屏渲染的吗？那为什么还要主动打开？</code><br>开启 Rasterization 后，GPU 只合成一次内容，然后复用合成的结果；合成的内容超过 100ms 没有使用会从缓存里移除，在更新内容时还会产生更多的离屏渲染。如果视图内容是动态变化的，使用这个方案有可能让性能变得更糟；但是对于内容不发生变化的视图，原本拖后腿的离屏渲染就成为了助力。</p><h3 id="CPU-资源消耗原因和解决方案"><a href="#CPU-资源消耗原因和解决方案" class="headerlink" title="CPU 资源消耗原因和解决方案"></a>CPU 资源消耗原因和解决方案</h3><p><strong>对象创建</strong><br>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p><p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p><p><strong>对象调整</strong><br>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p><p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p><p><strong>对象销毁</strong><br>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>布局计算</strong><br>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p><p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p><p><strong>Autolayout</strong><br>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p><p><strong>文本计算</strong><br>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p><p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p><p><strong>文本渲染</strong><br>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p><p><strong>图片的解码</strong><br>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p><p><strong>图像的绘制</strong><br>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPU-资源消耗原因和解决方案"><a href="#GPU-资源消耗原因和解决方案" class="headerlink" title="GPU 资源消耗原因和解决方案"></a>GPU 资源消耗原因和解决方案</h3><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p><p><strong>纹理的渲染</strong><br>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p><p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p><p><strong>视图的混合 (Composing)</strong><br>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p><p><strong>图形的生成</strong><br>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;渲染机制：&lt;br&gt;CPU将计算好的需要显示的内容提交给GPU，GPU渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照Vsync(垂直脉冲)信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器进行显示。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="离屏渲染" scheme="https://nixzhang5.github.io/tags/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
    
      <category term="性能优化" scheme="https://nixzhang5.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Masonry源码解读</title>
    <link href="https://nixzhang5.github.io/Masonry%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html"/>
    <id>https://nixzhang5.github.io/Masonry源码解读.html</id>
    <published>2019-07-02T04:28:39.000Z</published>
    <updated>2019-07-02T10:42:38.585Z</updated>
    
    <content type="html"><![CDATA[<p>学习Masonry，首先要学习一下链式语法，从中可以学到一些写法技巧。</p><a id="more"></a><h3 id="链式语法"><a href="#链式语法" class="headerlink" title="链式语法"></a>链式语法</h3><p>其实就是get方法和block的配合使用。要想实现objc.property语法，就要使用get方法，返回一个property实例。要想实现someOperation(param)这种语法，就需要使用block。两者结合，定义一个block属性并实现它的get方法，就可以实现objc.property(param)这种形式。链式语法，只需要在block内部返回自身即可，objc.property(param).property(param)。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">FP</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIView</span> *(^fp_frame)(<span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> w, <span class="built_in">CGFloat</span> h);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">FP</span>)</span></span><br><span class="line">- (<span class="built_in">UIView</span> *(^)(<span class="built_in">CGFloat</span>, <span class="built_in">CGFloat</span>, <span class="built_in">CGFloat</span>, <span class="built_in">CGFloat</span>))fp_frame &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *(^block)(<span class="built_in">CGFloat</span>, <span class="built_in">CGFloat</span>, <span class="built_in">CGFloat</span>, <span class="built_in">CGFloat</span>) = ^(<span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> w, <span class="built_in">CGFloat</span> h)&#123;</span><br><span class="line">        <span class="keyword">self</span>.frame = <span class="built_in">CGRectMake</span>(x, y, w, h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *view = [<span class="built_in">UIView</span> new];</span><br><span class="line">view.fp_frame(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);  <span class="comment">// 设置view的frame</span></span><br></pre></td></tr></table></figure><ol><li>什么时候使用链式语法？<br>在面向一些过程化处理的时候（拼接SQL、给View加约束，都可以看成需要一步步完成的过程），需要将这些“过程”拆分，然后在“组合”这些“过程”的时候，就可以使用链式编程，使得代码更加清晰，增加阅读性。</li><li>链式编程的核心实现<br>实现链式编程的关键就是声明一个block的属性，而这个block返回值必须还是一个对象（根据业务需求不同，可以返回的是任何类的实例对象）。而block中内部的逻辑就是项目的业务逻辑。</li></ol><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>大部分的OOP语言都有明确一种抽象基类的写法。Object-C中没有明确的抽象基类。于是我们可以采用一些类型判断去帮助我们建立一个抽象基类去使用。<br>Masonry中MASConstraint是一个很典型的抽象基类，里面声明了许多有关于NSLayoutConstraint的属性，并且声明了一些基类方法，并且不提供实现。我们<br>进入源码看这一过程。 </p><p>在初始化方法中，通过断言，不提供init方法的实现，也就是说无法获得一个MASConstraint类型的实例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="comment">// isMemberOfClass 当前类的实例对象判断  isKindOfClass 当前类或者其子类对象判断</span></span><br><span class="line">    <span class="comment">// 初始化判断，该基类不能直接实例化</span></span><br><span class="line"><span class="built_in">NSAssert</span>(![<span class="keyword">self</span> isMemberOfClass:[MASConstraint <span class="keyword">class</span>]], <span class="string">@"MASConstraint is an abstract class, you should not instantiate it directly."</span>);</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">super</span> init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些自身的实例方法，通过一个宏来拒绝本身实例去实现它的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MASMethodNotImplemented() \</span></span><br><span class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> \</span><br><span class="line">                                   reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"You must override %@ in a subclass."</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)] \</span><br><span class="line">                                 userInfo:<span class="literal">nil</span>]</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Abstract</span></span><br><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span> __unused)layoutAttribute &#123;</span><br><span class="line">    MASMethodNotImplemented();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> multiplier))multipliedBy &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> divider))dividedBy &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(MASLayoutPriority priority))priority &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span> key))key &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInsets:(MASEdgeInsets __unused)insets &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInset:(<span class="built_in">CGFloat</span> __unused)inset &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSizeOffset:(<span class="built_in">CGSize</span> __unused)sizeOffset &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCenterOffset:(<span class="built_in">CGPoint</span> __unused)centerOffset &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setOffset:(<span class="built_in">CGFloat</span> __unused)offset &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if TARGET_OS_MAC &amp;&amp; !(TARGET_OS_IPHONE || TARGET_OS_TV)</span></span><br><span class="line"></span><br><span class="line">- (MASConstraint *)animator &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)activate &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)deactivate &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)install &#123; MASMethodNotImplemented(); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)uninstall &#123; MASMethodNotImplemented(); &#125;</span><br></pre></td></tr></table></figure><h3 id="架构思考"><a href="#架构思考" class="headerlink" title="架构思考"></a>架构思考</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MASUtilities.h"</span>                    -&gt;masonry的一些公共的工具类</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"View+MASAdditions.h"</span>               -&gt;view的类扩展，常用的方法就是定义在这里</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"View+MASShorthandAdditions.h"</span>.     -&gt;Shorthand view additions without the 'mas_' prefixes,</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController+MASAdditions.h"</span>.  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+MASAdditions.h"</span>            -&gt;一组views进行约束，没什么特别</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+MASShorthandAdditions.h"</span>   -&gt;同上</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MASConstraint.h"</span>                   -&gt;Constraint的抽象基类。其子类有MASViewConstraint和MASCompositeConstraint</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MASCompositeConstraint.h"</span>          -&gt;包装多个MASViewConstraint实例。（例如size和center）</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MASViewAttribute.h"</span>                -&gt;用来包装一个view的功能类，让一个view和NSLayoutAttribute产生关联</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MASViewConstraint.h"</span>               -&gt;包装一些用于设置NSLayoutConstraint的属性</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MASConstraintMaker.h"</span>              -&gt;顾名思义，用来制造Constraint</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MASLayoutConstraint.h"</span>             -&gt;NSLayoutConstraint的子类，仅仅添加了一个mas_key，作为标志属性</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSLayoutConstraint+MASDebugAdditions.h"</span></span></span><br></pre></td></tr></table></figure><p>入口通过一个类扩展</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="comment">//将view的translatesAutoresizingMaskIntoConstraint关掉</span></span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//初始化一个maker并将view传进去</span></span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">//通过block去设置constraintMaker。一般一条语句对应一个或者两个MASLayoutConstraint。然后保存在一个可变数组@property (nonatomic, strong) NSMutableArray *constraints;</span></span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="comment">//取出constraintMaker中的constraints，遍历后根据constraint生成MASLayoutConstraint并添加至每个视图的约束。</span></span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键方法有两个，block(constraintMaker)和constraintMaker install。在block中，我们通常会去设置一些layout的属性，然后保存在一个可变数组中，最终通过install方法去完成约束的添加。</p><p>系统的NSLayoutConstraint添加约束：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[superview addConstraints:@[</span><br><span class="line"></span><br><span class="line">    <span class="comment">//view1 constraints</span></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:padding.top],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeLeft</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeLeft</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:padding.left],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:-padding.bottom],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                                multiplier:<span class="number">1</span></span><br><span class="line">                                  constant:-padding.right],</span><br><span class="line"></span><br><span class="line"> ]];</span><br></pre></td></tr></table></figure><p>我们要一直重复去写太多代码，而且attribute的枚举名词过长，导致写起来也十分冗杂，对比一下链式语法的简洁性也就体现出来。而且在使用系统的NSLayoutConstraints还是极容易出现布局错误导致app崩溃。所以masonry也做了很多边界值处理和防止重复layout的机制。 其实masonry的源码要封装的系统的方法不多，可以说看了所有代码就发现关键方法也就封装了这里。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line">- (<span class="keyword">void</span>)install &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果已经被加载 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hasBeenInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果系统layout对象已经创建 直接添加之后 返回</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> supportsActiveProperty] &amp;&amp; <span class="keyword">self</span>.layoutConstraint) &#123;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint.active = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span>.firstViewAttribute.view.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取布局的视图与属性</span></span><br><span class="line">    MAS_VIEW *firstLayoutItem = <span class="keyword">self</span>.firstViewAttribute.item;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> firstLayoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    MAS_VIEW *secondLayoutItem = <span class="keyword">self</span>.secondViewAttribute.item;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> secondLayoutAttribute = <span class="keyword">self</span>.secondViewAttribute.layoutAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不是尺寸布局并且 相对视图不存在 默认对父视图进行相对布局</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute &amp;&amp; !<span class="keyword">self</span>.secondViewAttribute) &#123;</span><br><span class="line">        secondLayoutItem = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">        secondLayoutAttribute = firstLayoutAttribute;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用系统NSLayoutConstraint的方法（相当于二次封装），创建布局对象</span></span><br><span class="line">    <span class="comment">//通过一个for循环，每有一个NSLayoutConstraint就install一次。</span></span><br><span class="line">    MASLayoutConstraint *layoutConstraint</span><br><span class="line">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line">                                        attribute:firstLayoutAttribute</span><br><span class="line">                                        relatedBy:<span class="keyword">self</span>.layoutRelation</span><br><span class="line">                                           toItem:secondLayoutItem</span><br><span class="line">                                        attribute:secondLayoutAttribute</span><br><span class="line">                                       multiplier:<span class="keyword">self</span>.layoutMultiplier</span><br><span class="line">                                         constant:<span class="keyword">self</span>.layoutConstant];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置key和优先级</span></span><br><span class="line">    layoutConstraint.priority = <span class="keyword">self</span>.layoutPriority;</span><br><span class="line">    layoutConstraint.mas_key = <span class="keyword">self</span>.mas_key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置约束对象对用于的视图</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</span><br><span class="line">        <span class="comment">//获取共同的父视图</span></span><br><span class="line">        MAS_VIEW *closestCommonSuperview = [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</span><br><span class="line">        <span class="built_in">NSAssert</span>(closestCommonSuperview,</span><br><span class="line">                 <span class="string">@"couldn't find a common superview for %@ and %@"</span>,</span><br><span class="line">                 <span class="keyword">self</span>.firstViewAttribute.view, <span class="keyword">self</span>.secondViewAttribute.view);</span><br><span class="line">        <span class="keyword">self</span>.installedView = closestCommonSuperview;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//更新约束的操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123;</span><br><span class="line">        existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existingConstraint) &#123;</span><br><span class="line">        <span class="comment">// just update the constant</span></span><br><span class="line">        existingConstraint.constant = layoutConstraint.constant;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint = existingConstraint;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//最终添加约束</span></span><br><span class="line">        [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</span><br><span class="line">        [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他代码都是为了这个方法服务的。这也就看出oc代码的一个灵活性。masonry的源码不难看懂，而且代码量比较少，所以还是比较容易了解它的核心。<br>关键还是要想得懂那些block方法的回调。用block作为返回值，其实就是把一个函数作为返回值，这种做法在js中比较常见，而且js中写法也更加简洁易懂。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"View+MASAdditions.m"</span></span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MASConstraintMaker.m"</span></span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)install &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.constraints removeAllObjects];</span><br><span class="line">    <span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MASConstraintMaker接受MASConstraint的代理方法，constraints数组添加newConstraint对象，最后通过install方法，循环遍历添加约束。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Masonry，首先要学习一下链式语法，从中可以学到一些写法技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="Masonry" scheme="https://nixzhang5.github.io/tags/Masonry/"/>
    
      <category term="链式语法" scheme="https://nixzhang5.github.io/tags/%E9%93%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView和UIWebView对比</title>
    <link href="https://nixzhang5.github.io/WKWebView%E5%92%8CUIWebView.html"/>
    <id>https://nixzhang5.github.io/WKWebView和UIWebView.html</id>
    <published>2019-07-01T03:51:54.000Z</published>
    <updated>2019-07-01T10:52:12.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WKWebView和UIWebView"><a href="#WKWebView和UIWebView" class="headerlink" title="WKWebView和UIWebView"></a>WKWebView和UIWebView</h3><p>UIWebView自iOS2就有，WKWebView从iOS8才有，毫无疑问WKWebView将逐步取代笨重的UIWebView。通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度也有提升，但是并不像内存那样提升那么多。</p><a id="more"></a><p>WKWebView的优势：</p><ol><li>性能和稳定性的大幅提高</li><li>内存占用的减少，大概是UIWebView的1/4 - 1/3</li><li>更多的支持HTML5的特性<ul><li>允许JavaScript的Nitro的库加载并使用（移动设备的 Safari 使用 Nitro 引擎，但是 UIWebView 不包括 JIT 编译，所以不支持，体验会慢一些）</li></ul></li><li>官方宣称的高达60fps的滚动刷新率以及内置手势</li><li>Safari相同的JavaScript引擎</li><li>将UIWebViewDelegate与UIWebView拆分成了14类与3个协议(官方文档说明)，JS交互方便</li><li>另外用的比较多的，增加加载进度属性：estimatedProgress</li></ol><p>WKWebView的缺点：</p><ol><li>不自带cookie</li><li>获取cookie</li><li>不支持自定义NSURLProtocol，否则无法发送POST参数</li></ol><h3 id="UIWebView-OC和JS相互调用"><a href="#UIWebView-OC和JS相互调用" class="headerlink" title="UIWebView OC和JS相互调用"></a>UIWebView OC和JS相互调用</h3><p><strong>OC调用JS代码</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)stringByEvaluatingJavaScriptFromString:(<span class="built_in">NSString</span> *)string;</span><br></pre></td></tr></table></figure><p><strong>JS调用OC代码</strong><br>在代理方法里面拦截实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">让Native 代码拦截， </span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView </span><br><span class="line">shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>:)request </span><br><span class="line">navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType;</span><br></pre></td></tr></table></figure><h3 id="WKWebView-OC和JS相互调用"><a href="#WKWebView-OC和JS相互调用" class="headerlink" title="WKWebView OC和JS相互调用"></a>WKWebView OC和JS相互调用</h3><p><strong>OC调用JS</strong><br>WKWebView 本身提供一个方法进行处理JS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)evaluateJavaScript:(<span class="built_in">NSString</span> *)javaScriptString completionHandler:(<span class="keyword">void</span> (^_Nullable)(_Nullable <span class="keyword">id</span>,<span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure><p><strong>JS调用OC</strong><br>JS端调用操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.&lt;方法名&gt;.postMessage(&lt;数据&gt;)</span><br></pre></td></tr></table></figure><p>在OC中的处理方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addScriptMessageHandler:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置addScriptMessageHandler与name.并且设置&lt;WKScriptMessageHandler&gt;协议与协议方法</span></span><br><span class="line">[[_webView configuration].userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"方法名"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//WKScriptMessageHandler协议方法</span></span><br><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会导致内存泄露，因为这里userContentController持有了self，然后 userContentController 又被configuration持有，最终被webview持有，然后webview是self的一个私有变量，所以self也持有self。</p><p>解决办法：</p><ol><li>在viewWillAppear和viewWillDisappear注册和移除</li><li>将传入的vc实例参数通过一个过度类来实现，此时vc的dealloc方法会调用在销毁方法里边释放掉注册的方法</li></ol><h3 id="Cookie问题"><a href="#Cookie问题" class="headerlink" title="Cookie问题"></a>Cookie问题</h3><p>cookie（是存储在客户端的，本质是个字符串）:<br>cookie是随着数据请求，传来传去的，也就是每个request，response，都携带有cookie<br>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失</p><h4 id="WKWebView-Cookie存储"><a href="#WKWebView-Cookie存储" class="headerlink" title="WKWebView Cookie存储"></a>WKWebView Cookie存储</h4><p>业界普遍认为 WKWebView 拥有自己的私有存储，不会将 Cookie 存入到标准的 Cookie 容器 NSHTTPCookieStorage 中。</p><p>实践发现 WKWebView 实例其实也会将 Cookie 存储于 NSHTTPCookieStorage 中，但存储时机有延迟，在iOS 8上，当页面跳转的时候，当前页面的 Cookie 会写入 NSHTTPCookieStorage 中，而在 iOS 10 上，JS 执行 document.cookie 或服务器 set-cookie 注入的 Cookie 会很快同步到 NSHTTPCookieStorage 中。</p><p>WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。</p><p>比如，NSHTTPCookieStorage 中存储了一个 Cookie:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=Nicholas;value=test;domain=y.qq.com;expires=Sat, <span class="number">02</span> May <span class="number">2019</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">25</span> GMT；</span><br></pre></td></tr></table></figure><p>通过 UIWebView 发起请求，则请求头会自动带上 cookie: Nicholas=test；<br>而通过 WKWebView发起请求，请求头不会自动带上 cookie: Nicholas=test。</p><h4 id="WKProcessPool"><a href="#WKProcessPool" class="headerlink" title="WKProcessPool"></a>WKProcessPool</h4><p>通过让所有 WKWebView 共享同一个 WKProcessPool 实例，可以实现多个 WKWebView 之间共享 Cookie（session Cookie and persistent Cookie）数据。不过 WKWebView WKProcessPool 实例在 app 杀进程重启后会被重置，导致 WKProcessPool 中的 Cookie、session Cookie 数据丢失，目前也无法实现 WKProcessPool 实例本地化保存。</p><h4 id="Workaround"><a href="#Workaround" class="headerlink" title="Workaround"></a>Workaround</h4><p>由于许多 H5 业务都依赖于 Cookie 作登录态校验，而 WKWebView 上请求不会自动携带 Cookie, 目前的主要解决方案是：</p><p>a、WKWebView loadRequest 前，在 request header 中设置 Cookie, 解决首个请求 Cookie 带不上的问题；</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> * webView = [<span class="built_in">WKWebView</span> new]; </span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> * request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://h5.qzone.qq.com/mqzone/index"</span>]]; </span><br><span class="line"></span><br><span class="line">[request addValue:<span class="string">@"skey=skeyValue"</span> forHTTPHeaderField:<span class="string">@"Cookie"</span>]; </span><br><span class="line">[webView loadRequest:request];</span><br></pre></td></tr></table></figure><p>b、通过 document.cookie 设置 Cookie 解决后续页面(同域)Ajax、iframe 请求的 Cookie 问题；<br>注意：document.cookie()无法跨域设置 cookie</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKUserContentController</span>* userContentController = [<span class="built_in">WKUserContentController</span> new]; </span><br><span class="line"><span class="built_in">WKUserScript</span> * cookieScript = [[<span class="built_in">WKUserScript</span> alloc] initWithSource: <span class="string">@"document.cookie = 'skey=skeyValue';"</span> injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">NO</span>]; </span><br><span class="line"></span><br><span class="line">[userContentController addUserScript:cookieScript];</span><br></pre></td></tr></table></figure><p>这种方案无法解决302请求的 Cookie 问题，比如，第一个请求是 <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a>, 我们通过在 request header 里带上 Cookie 解决该请求的 Cookie 问题，接着页面302跳转到 <a href="http://www.b.com" target="_blank" rel="noopener">www.b.com</a>, 这个时候 <a href="http://www.b.com" target="_blank" rel="noopener">www.b.com</a> 这个请求就可能因为没有携带 cookie 而无法访问。当然，由于每一次页面跳转前都会调用回调函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure><p>可以在该回调函数里拦截302请求，copy request，在 request header 中带上 cookie 并重新 loadRequest。不过这种方法依然解决不了页面 iframe 跨域请求的 Cookie 问题，毕竟-[WKWebView loadRequest:]只适合加载 mainFrame 请求。</p><h3 id="白屏问题"><a href="#白屏问题" class="headerlink" title="白屏问题"></a>白屏问题</h3><p>WKWebView 自诩拥有更快的加载速度，更低的内存占用，但实际上 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行。初次适配 WKWebView 的时候，我们也惊讶于打开 WKWebView 后，App 进程内存消耗反而大幅下降，但是仔细观察会发现，Other Process 的内存占用会增加。在一些用 webGL 渲染的复杂页面，使用 WKWebView 总体的内存占用（App Process Memory + Other Process Memory）不见得比 UIWebView 少很多。</p><p>在 UIWebView 上当内存占用太大的时候，App Process 会 crash；而在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。</p><p>这个时候 WKWebView.URL 会变为 nil, 简单的 reload 刷新操作已经失效，对于一些长驻的H5页面影响比较大。</p><p>解决方案：</p><ol><li>借助 WKNavigtionDelegate<br>iOS 9以后 WKNavigtionDelegate 新增了一个回调函数：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webViewWebContentProcessDidTerminate:(<span class="built_in">WKWebView</span> *)webView API_AVAILABLE(macosx(<span class="number">10.11</span>), ios(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure></li></ol><p>当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行[webView reload](这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。</p><ol start="2"><li>检测 webView.title 是否为空<br>并不是所有H5页面白屏的时候都会调用上面的回调函数，比如，最近遇到在一个高内存消耗的H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，WebContent Process 被系统挂起），但上面的回调函数并没有被调用。在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空, 因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。</li></ol><h3 id="NSURLProtocol问题"><a href="#NSURLProtocol问题" class="headerlink" title="NSURLProtocol问题"></a>NSURLProtocol问题</h3><p>WKWebView 在独立于 app 进程之外的进程中执行网络请求，请求数据不经过主进程，因此，在 WKWebView 上直接使用 NSURLProtocol 无法拦截请求。苹果开源的 webKit2 源码暴露了私有API：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ [<span class="built_in">WKBrowsingContextController</span> registerSchemeForCustomProtocol:]</span><br></pre></td></tr></table></figure><p>通过注册 http(s) scheme 后 WKWebView 将可以使用 NSURLProtocol 拦截 http(s) 请求：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"WKBrowsingContextController”); </span></span><br><span class="line"><span class="string">SEL sel = NSSelectorFromString(@"</span>registerSchemeForCustomProtocol:<span class="string">"); </span></span><br><span class="line"><span class="string">if ([(id)cls respondsToSelector:sel]) &#123; </span></span><br><span class="line"><span class="string">           // 注册http(s) scheme, 把 http和https请求交给 NSURLProtocol处理 </span></span><br><span class="line"><span class="string">           [(id)cls performSelector:sel withObject:@"</span>http<span class="string">"]; </span></span><br><span class="line"><span class="string">           [(id)cls performSelector:sel withObject:@"</span>https<span class="string">"]; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>但是这种方案目前存在两个严重缺陷：</p><ol><li><p>post 请求 body 数据被清空<br>由于 WKWebView 在独立进程里执行网络请求。一旦注册 http(s) scheme 后，网络请求将从 Network Process 发送到 App Process，这样 NSURLProtocol 才能拦截网络请求。在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了。</p><p> 因此，如果通过 registerSchemeForCustomProtocol 注册了 http(s) scheme, 那么由 WKWebView 发起的所有 http(s)请求都会通过 IPC 传给主进程 NSURLProtocol 处理，导致 post 请求 body 被清空；</p></li><li><p>对ATS支持不足<br>测试发现一旦打开ATS开关：Allow Arbitrary Loads 选项设置为NO，同时通过 registerSchemeForCustomProtocol 注册了 http(s) scheme，WKWebView 发起的所有 http 网络请求将被阻塞（即便将Allow Arbitrary Loads in Web Content 选项设置为YES）；</p><p> WKWebView 可以注册 customScheme, 比如 dynamic://, 因此希望使用离线功能又不使用 post 方式的请求可以通过 customScheme 发起请求，比如 dynamic://<a href="http://www.dynamicalbumlocalimage.com/" target="_blank" rel="noopener">www.dynamicalbumlocalimage.com/</a>, 然后在 app 进程 NSURLProtocol 拦截这个请求并加载离线数据。不足：使用 post 方式的请求该方案依然不适用，同时需要 H5 侧修改请求 scheme 以及 CSP 规则；</p></li></ol><h3 id="loadRequest-问题"><a href="#loadRequest-问题" class="headerlink" title="loadRequest 问题"></a>loadRequest 问题</h3><p>在 WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样是由于进程间通信性能问题，HTTPBody字段被丢弃</span></span><br><span class="line">[request setHTTPMethod:<span class="string">@"POST"</span>];</span><br><span class="line">[request setHTTPBody:[<span class="string">@"bodyData"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line">[wkwebview loadRequest: request];</span><br></pre></td></tr></table></figure><p>workaround:<br>假如想通过-[WKWebView loadRequest:]加载 post 请求 request1: <a href="http://h5.qzone.qq.com/mqzone/index" target="_blank" rel="noopener">http://h5.qzone.qq.com/mqzone/index</a>, 可以通过以下步骤实现：</p><ol><li>替换请求 scheme，生成新的 post 请求 request2: post://h5.qzone.qq.com/mqzone/index, 同时将 request1 的 body 字段复制到 request2 的 header 中（WebKit 不会丢弃 header 字段）;</li><li>通过-[WKWebView loadRequest:]加载新的 post 请求 request2;</li><li>通过 +[WKBrowsingContextController registerSchemeForCustomProtocol:]注册 scheme: post://;</li><li>注册 NSURLProtocol 拦截请求post://h5.qzone.qq.com/mqzone/index ,替换请求 scheme, 生成新的请求 request3: <a href="http://h5.qzone.qq.com/mqzone/index" target="_blank" rel="noopener">http://h5.qzone.qq.com/mqzone/index</a>, 将 request2 header的body 字段复制到 request3 的 body 中，并使用 NSURLConnection 加载 request3，最后通过 NSURLProtocolClient 将加载结果返回 WKWebView;</li></ol><h3 id="样式问题"><a href="#样式问题" class="headerlink" title="样式问题"></a>样式问题</h3><p>在 WKWebView 适配过程中，我们发现部分H5页面元素位置向下偏移或被拉伸变形，追踪后发现主要是H5页面高度值异常导致：</p><p>a. 空间H5页面有透明导航、透明导航下拉刷新、全屏等需求，因此之前 webView 整个是从（0, 0）开始布局，通过调整webView.scrollView.contentInset 来适配特殊导航栏需求。而在 WKWebView 上对 contentInset 的调整会反馈到webView.scrollView.contentSize.height的变化上，比如设置 webView.scrollView.contentInset.top = a，那么contentSize.height的值会增加a,导致H5页面长度增加，页面元素位置向下偏移；</p><p>解决方案是：调整WKWebView布局方式，避免调整webView.scrollView.contentInset。实际上，即便在 UIWebView 上也不建议直接调整webView.scrollView.contentInset的值，这确实会带来一些奇怪的问题。如果某些特殊情况下非得调整 contentInset 不可的话，可以通过下面方式让H5页面恢复正常显示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**设置contentInset值后通过调整webView.frame让页面恢复正常显示 </span></span><br><span class="line"><span class="comment"> *参考：http://km.oa.com/articles/show/277372</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">webView.scrollView.contentInset = <span class="built_in">UIEdgeInsetsMake</span>(a, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">webView.frame = <span class="built_in">CGRectMake</span>(webView.frame.origin.x, webView.frame.origin.y, webView.frame.size.width, webView.frame.size.height - a);</span><br></pre></td></tr></table></figure><p>b. 在接入 now 直播的时候，我们发现在 iOS 9 上 WKWebView 会出现页面被拉伸变形的情况，最后发现是window.innerHeight值不准确导致（在WKWebView上返回了一个非常大的值），而H5同学通过获取window.innerHeight来设置页面高度，导致页面整体被拉伸。通过查阅相关资料发现，这个bug只在 iOS 9 的几个系统版本上出现，苹果后来fix了这个bug。我们最后的解决方案是：延迟调用window.innerHeight</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;height = <span class="built_in">window</span>.innerHeight&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use shrink-to-fit meta-tag </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="截屏问题"><a href="#截屏问题" class="headerlink" title="截屏问题"></a>截屏问题</h3><p>空间玩吧H5小游戏有截屏分享的功能，WKWebView 下通过 -[CALayer renderInContext:]实现截屏的方式失效，需要通过以下方式实现截屏功能：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">ImageSnapshot</span>) </span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)imageSnapshot &#123; </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size,<span class="literal">YES</span>,<span class="keyword">self</span>.contentScaleFactor); </span><br><span class="line">    [<span class="keyword">self</span> drawViewHierarchyInRect:<span class="keyword">self</span>.bounds afterScreenUpdates:<span class="literal">YES</span>]; </span><br><span class="line">    <span class="built_in">UIImage</span>* newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>(); </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>(); </span><br><span class="line">    <span class="keyword">return</span> newImage; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然而这种方式依然解决不了 webGL 页面的截屏问题，webKit2 源码里的截屏私有API，也没有找到合适的解决方案，同时发现 Safari 以及 Chrome 这两个全量切换到 WKWebView 的浏览器也存在同样的问题：对webGL 页面的截屏结果不是空白就是纯黑图片。无奈之下，我们只能约定一个JS接口，让游戏开发商实现该接口，具体是通过 canvas getImageData()方法取得图片数据后返回 base64 格式的数据，客户端在需要截图的时候，调用这个JS接口获取 base64 String 并转换成 UIImage。</p><h3 id="crash问题"><a href="#crash问题" class="headerlink" title="crash问题"></a>crash问题</h3><p>WKWebView 放量后，外网新增了一些 crash, 其中一类 crash 的主要堆栈如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="number">28</span> <span class="built_in">UIKit</span> <span class="number">0x0000000190513360</span> <span class="built_in">UIApplicationMain</span> + <span class="number">208</span> </span><br><span class="line"><span class="number">29</span> Qzone <span class="number">0x0000000101380570</span> main (main.m:<span class="number">181</span>) </span><br><span class="line"><span class="number">30</span> libdyld.dylib <span class="number">0x00000001895205b8</span> _dyld_process_info_notify_release + <span class="number">36</span> </span><br><span class="line">Completion handler passed to -[QZWebController webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:] was not called</span><br></pre></td></tr></table></figure><p>主要是JS调用window.alert()函数引起的，从 crash 堆栈可以看出是 WKWebView 回调函数:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) presentAlertOnController:(<span class="keyword">nonnull</span> <span class="built_in">UIViewController</span>*)parentController title:(<span class="keyword">nullable</span> <span class="built_in">NSString</span>*)title message:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)message handler:(<span class="keyword">nonnull</span> <span class="keyword">void</span> (^)())completionHandler;</span><br></pre></td></tr></table></figure><p>completionHandler 没有被调用导致的。在适配 WKWebView 的时候，我们需要自己实现该回调函数，window.alert()才能调起 alert 框，我们最初的实现是这样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">UIAlertController</span> *alertController = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@""</span> message:message preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>]; </span><br><span class="line">    [alertController addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确认"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> *action) &#123; completionHandler(); &#125;]]; </span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:^&#123;&#125;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 WKWebView 退出的时候，JS刚好执行了window.alert(), alert 框可能弹不出来，completionHandler 最后没有被执行，导致 crash；另一种情况是在 WKWebView 一打开，JS就执行window.alert()，这个时候由于 WKWebView 所在的 UIViewController 出现（push或present）的动画尚未结束，alert 框可能弹不出来，completionHandler 最后没有被执行，导致 crash。我们最终的实现大致是这样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*UIViewController of WKWebView has finish push or present animation*/</span>) &#123; </span><br><span class="line">        completionHandler(); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">UIAlertController</span> *alertController = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@""</span> message:message preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>]; </span><br><span class="line">    [alertController addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确认"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> *action) &#123; completionHandler(); &#125;]]; </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*UIViewController of WKWebView is visible*/</span>) </span><br><span class="line">        [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:^&#123;&#125;]; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        completionHandler(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保上面两种情况下 completionHandler 都能被执行，消除了 WKWebView 下弹 alert 框的 crash，WKWebView 下弹 confirm 框的 crash 的原因与解决方式与 alert 类似。</p><p>另一个 crash 发生在 WKWebView 退出前调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[<span class="built_in">WKWebView</span> evaluateJavaScript: completionHandler:]</span><br></pre></td></tr></table></figure><p>执行JS代码的情况下。WKWebView 退出并被释放后导致completionHandler变成野指针，而此时 javaScript Core 还在执行JS代码，待 javaScript Core 执行完毕后会调用completionHandler()，导致 crash。这个 crash 只发生在 iOS 8 系统上，参考Apple Open Source，在iOS9及以后系统苹果已经修复了这个bug，主要是对completionHandler block做了copy；对于iOS 8系统，可以通过在 completionHandler 里 retain WKWebView 防止 completionHandler 被过早释放。我们最后用 methodSwizzle hook 了这个系统方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) load </span><br><span class="line">&#123; </span><br><span class="line">     [<span class="keyword">self</span> jr_swizzleMethod:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"evaluateJavaScript:completionHandler:"</span>) withMethod:<span class="keyword">@selector</span>(altEvaluateJavaScript:completionHandler:) error:<span class="literal">nil</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fix: WKWebView crashes on deallocation if it has pending JavaScript evaluation </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">- (<span class="keyword">void</span>)altEvaluateJavaScript:(<span class="built_in">NSString</span> *)javaScriptString completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>, <span class="built_in">NSError</span> *))completionHandler </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">id</span> strongSelf = <span class="keyword">self</span>; </span><br><span class="line">    [<span class="keyword">self</span> altEvaluateJavaScript:javaScriptString completionHandler:^(<span class="keyword">id</span> r, <span class="built_in">NSError</span> *e) &#123; </span><br><span class="line">        [strongSelf title]; </span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123; </span><br><span class="line">            completionHandler(r, e); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="视频自动播放"><a href="#视频自动播放" class="headerlink" title="视频自动播放"></a>视频自动播放</h4><p>WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。</p><h4 id="goBack-API问题"><a href="#goBack-API问题" class="headerlink" title="goBack API问题"></a>goBack API问题</h4><p>WKWebView 上调用 -[WKWebView goBack], 回退到上一个页面后不会触发window.onload()函数、不会执行JS。</p><h4 id="页面滚动速率"><a href="#页面滚动速率" class="headerlink" title="页面滚动速率"></a>页面滚动速率</h4><p>WKWebView 需要通过scrollView delegate调整滚动速率：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">     scrollView.decelerationRate = <span class="built_in">UIScrollViewDecelerationRateNormal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="初始化优化"><a href="#初始化优化" class="headerlink" title="初始化优化"></a>初始化优化</h4><p>WKWebView初始化耗时长（启动浏览器内核），初始化之后才去加载。</p><p>优化方案：</p><ol><li>全局WebView，打开app，创建一个全局的webView隐藏起来备用<ul><li>额外的内存开销</li><li>页面跳转需要清空上一个页面的痕迹，更容易内存泄露</li></ul></li><li>客户端代理数据请求，初始化webView的同时进行网络请求数据，同步进行</li></ol><h3 id="建立连接-服务器处理"><a href="#建立连接-服务器处理" class="headerlink" title="建立连接/服务器处理"></a>建立连接/服务器处理</h3><p>在页面请求的数据返回之前，主要有以下过程耗费时间。</p><ul><li>DNS</li><li>connection</li><li>服务器处理</li></ul><p>优化方案：</p><ol><li><code>DNS采用和客户端API相同的域名</code><br>DNS会在系统级别进行缓存，对于WebView的地址，如果使用的域名与native的API相同，则可以直接使用缓存的DNS而不用再发起请求图片。</li></ol><p>以美团为例，美团的客户端请求域名主要位于api.meituan.com，然而内嵌的WebView主要位于 i.meituan.com。</p><p>当我们初次打开App时：</p><ul><li>客户端首次打开都会请求api.meituan.com，其DNS将会被系统缓存。</li><li>然而当打开WebView的时候，由于请求了不同的域名，需要重新获取i.meituan.com的IP。</li></ul><p>根据上面的统计，至少10%的用户打开WebView时耗费了60ms在DNS上面，如果WebView的域名与App的API域名统一，则可以让WebView的DNS时间全部达到1.3ms的量级。</p><p>静态资源同理，最好与客户端的资源域名保持一致。</p><ol start="2"><li><code>同步渲染采用chunk编码</code><br>同步渲染时如果后端请求时间过长，可以考虑采用chunk编码，将数据放在最后，并优先将静态内容flush。对于传统的后端渲染页面，往往都是使用的【浏览器】–&gt; 【Web API】 –&gt; 【业务 API】的加载模式，其中后端时间就指的是Web API的处理时间了。在这里Web API一般有两个作用：<ol><li>确定静态资源的版本。</li><li>根据用户的请求，去业务API获取数据。</li></ol></li></ol><p>而一般确定静态资源的版本往往是直接读取代码版本，基本无耗时；而主要的后端时间都花费在了业务API请求上面。</p><p>那么怎么优化利用这段时间呢？</p><p>在HTTP协议中，我们可以在header中设置 transfer-encoding:chunked 使得页面可以分块输出。如果合理设计页面，让head部分都是确定的静态资源版本相关内容，而body部分是业务数据相关内容，那么我们可以在用户请求的时候，首先将Web API可以确定的部分先输出给浏览器，然后等API完全获取后，再将API数据传输给浏览器。</p><p>分chunk输出和一起输出的区别：</p><ul><li>如果采用普通方式输出页面，则页面会在服务器请求完所有API并处理完成后开始传输。浏览器要在后端所有API都加载完成后才能开始解析。</li><li>如果采用chunk-encoding: chunked，并优先将页面的静态部分输出；然后处理API请求，并最终返回页面，可以让后端的API请求和前端的资源加载同时进行。</li><li>两者的总共后端时间并没有区别，但是可以提升首字节速度，从而让前端加载资源和后端加载API不互相阻塞。</li></ul><h4 id="页面框架渲染"><a href="#页面框架渲染" class="headerlink" title="页面框架渲染"></a>页面框架渲染</h4><p>页面在解析到足够多的节点，且所有CSS都加载完成后进行首屏渲染。在此之前，页面保持白屏；在页面完全下载并解析完成之前，页面处于不完整展示状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//ms0.meituan.net/css/eve.9d9eee71.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">onload</span>=<span class="string">"MT.pageData.eveTime=Date.now()"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.fk = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">require</span>([<span class="string">'util/native/risk.js'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">risk</span>) </span>&#123;</span></span><br><span class="line">    risk.getFk(callback);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>通常情况下，上面代码的link部分和script部分如果单独出现，都不会阻塞页面的解析：</p><ul><li>CSS不会阻止页面继续向下继续。</li><li>内联的JS很快执行完成，然后继续解析文档。</li></ul><p>然而，当这两部分同时出现的时候，问题就来了。</p><ul><li>CSS加载阻塞了下面的一段内联JS的执行，而被阻塞的内联JS则阻塞了HTML的解析。</li></ul><p>通常情况下，CSS不会阻塞HTML的解析，但如果CSS后面有JS，则会阻塞JS的执行直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。</p><p>优化：<br>在页面框架加载这一部分，能够优化的点参照雅虎14条就够了；但注意不要犯错，一个小小的内联JS放错位置也会让性能下降很多。</p><ol><li>CSS的加载会在HTML解析到CSS的标签时开始，所以CSS的标签要尽量靠前。</li><li>但是，CSS链接下面不能有任何的JS标签（包括很简单的内联JS），否则会阻塞HTML的解析。</li><li>如果必须要在头部增加内联脚本，一定要放在CSS标签之前。</li></ol><h4 id="JS加载"><a href="#JS加载" class="headerlink" title="JS加载"></a>JS加载</h4><p>经过测试可以得出以下结论：</p><ul><li>偏重的框架，例如React，仅仅初始化的时间就会达到50ms ~ 350ms，这在对性能敏感的业务中时比较不利的。</li><li>在App的启动周期内，统一域名下的代码会被缓存编辑和初始化结果，重复调用性能较好。</li></ul><p>所以，在移动浏览器上，JS的解析和执行时间并不是不可忽略的。</p><p>在低端安卓机上，（框架的初始化+异步数据请求+业务代码执行）会远高于几KB网络请求时间；高性能的Web网站需要仔细斟酌前端渲染带来的性能问题。</p><p>优化：</p><ul><li>高性能要求页面还是需要后端渲染。</li><li>React还是太重了，面向用户写系统需要谨慎考虑。</li><li>JS代码的编译和执行会有缓存，同App中网页尽量统一框架。</li></ul><h4 id="WebView性能优化总结"><a href="#WebView性能优化总结" class="headerlink" title="WebView性能优化总结"></a>WebView性能优化总结</h4><p>一个加载网页的过程中，native、网络、后端处理、CPU都会参与，各自都有必要的工作和依赖关系；让他们相互并行处理而不是相互阻塞才可以让网页加载更快：</p><ul><li>WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。</li><li>后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。</li><li>脚本执行慢，就让脚本在最后运行，不阻塞页面解析。</li><li>同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。</li><li>WebView初始化慢，就随时初始化好一个WebView待用。</li><li>DNS和链接慢，想办法复用客户端使用的域名和链接。</li><li>脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;WKWebView和UIWebView&quot;&gt;&lt;a href=&quot;#WKWebView和UIWebView&quot; class=&quot;headerlink&quot; title=&quot;WKWebView和UIWebView&quot;&gt;&lt;/a&gt;WKWebView和UIWebView&lt;/h3&gt;&lt;p&gt;UIWebView自iOS2就有，WKWebView从iOS8才有，毫无疑问WKWebView将逐步取代笨重的UIWebView。通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度也有提升，但是并不像内存那样提升那么多。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="WebView" scheme="https://nixzhang5.github.io/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking原理五 AFNetworkReachabilityManager</title>
    <link href="https://nixzhang5.github.io/AFNetWorking%E5%8E%9F%E7%90%86%E4%BA%94.html"/>
    <id>https://nixzhang5.github.io/AFNetWorking原理五.html</id>
    <published>2019-06-30T02:25:55.000Z</published>
    <updated>2019-07-01T03:37:15.700Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetworkReachabilityManager类是对接入网络类型的监听。</p><a id="more"></a><h3 id="AFNetworkReachabilityManager使用"><a href="#AFNetworkReachabilityManager使用" class="headerlink" title="AFNetworkReachabilityManager使用"></a>AFNetworkReachabilityManager使用</h3><p>AFNetworkReachabilityManager对网络的监测使用如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> AFNetworkReachabilityManager *networkReachManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">[networkReachManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWWAN:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"蜂窝网络"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWiFi:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"WIFI"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusNotReachable:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"没有网络"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusUnknown:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"未知"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 开始监测网络</span></span><br><span class="line">[networkReachManager startMonitoring];</span><br></pre></td></tr></table></figure><p>当网络状态发生变化时就会执行block, 将网络状态AFNetworkReachabilityStatus返回给我们。</p><h3 id="AFNetworkReachabilityManager-h文件"><a href="#AFNetworkReachabilityManager-h文件" class="headerlink" title="AFNetworkReachabilityManager.h文件"></a>AFNetworkReachabilityManager.h文件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 网络类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> - AFNetworkReachabilityStatusUnknown: 未知网络</span></span><br><span class="line"><span class="comment"> - AFNetworkReachabilityStatusNotReachable: 网络不可达, 无网络</span></span><br><span class="line"><span class="comment"> - AFNetworkReachabilityStatusReachableViaWWAN: 手机网络</span></span><br><span class="line"><span class="comment"> - AFNetworkReachabilityStatusReachableViaWiFi: WiFi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkReachabilityStatus) &#123;</span><br><span class="line">    AFNetworkReachabilityStatusUnknown          = <span class="number">-1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusNotReachable     = <span class="number">0</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWWAN = <span class="number">1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWiFi = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>四种网络状态类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当前网络状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFNetworkReachabilityStatus networkReachabilityStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 网络是否可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isReachable) <span class="built_in">BOOL</span> reachable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当前连接是否是WWAN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isReachableViaWWAN) <span class="built_in">BOOL</span> reachableViaWWAN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当前连接是否是WiFi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isReachableViaWiFi) <span class="built_in">BOOL</span> reachableViaWiFi;</span><br></pre></td></tr></table></figure><p>在.h文件中对外提供了4个只读属性, 并且给出了对应的getter方法.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 单例初始化，调用的manager方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 通过默认的socket地址初始化，返回一个manager对象，sin_family表示协议族，AF_INET表示TCP/IP协议族的地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)manager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 这种方法就是可以根据特定的域来初始化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)managerForDomain:(<span class="built_in">NSString</span> *)domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> manager方法里面又调用了此方法，通过传入一个socket地址来初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)managerForAddress:(<span class="keyword">const</span> <span class="keyword">void</span> *)address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> managerForAddress、managerForDomain方法里面，都调用了这个初始化方法，因为该方法的后缀里面有NS_DESIGNATED_INITIALIZER，所以最终都会调到它，这里就是做了初始化的工作，将起始的网络状态定为Unknown。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithReachability:(<span class="built_in">SCNetworkReachabilityRef</span>)reachability <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  不可用的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  不可用的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  开始监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)startMonitoring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  结束监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)stopMonitoring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回一个网络状态的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)localizedNetworkReachabilityStatusString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 网络状态改变的回调</span></span><br><span class="line"><span class="comment"> 监听网络状态的改变有两种方法:1.是实现这个block 2.是监听通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setReachabilityStatusChangeBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(AFNetworkReachabilityStatus status))block;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 网络状态改变时 发送的通知</span></span><br><span class="line"><span class="comment"> 在userInfo下有以AFNetworkingReachabilityNotificationStatusItem为key的一个NSNumber类型的值, 这个值对应着AFNetworkReachabilityStatus枚举, 反应网络状态</span></span><br><span class="line"><span class="comment"> FOUNDATION_EXPORT主要用于定义常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns a localized string representation of an `AFNetworkReachabilityStatus` value.</span></span><br><span class="line"><span class="comment">这个是定义的一个C语言函数, 返回本地化的status字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status);</span><br></pre></td></tr></table></figure><p>定义了两个通知的名称, 当网络状态改变时发出的通知, 接收的通知中会有一个userInfo, 可根据key为AFNetworkingReachabilityNotificationStatusItem取出通知的内容.</p><h3 id="AFNetworkReachabilityManager-m文件"><a href="#AFNetworkReachabilityManager-m文件" class="headerlink" title="AFNetworkReachabilityManager.m文件"></a>AFNetworkReachabilityManager.m文件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个静态字符串, 网络状态发生变化时发出的通知 对应.h</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityDidChangeNotification = <span class="string">@"com.alamofire.networking.reachability.change"</span>;</span><br><span class="line"><span class="comment">// 网络状态发生变化时发出通知, 携带的数据</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingReachabilityNotificationStatusItem = <span class="string">@"AFNetworkingReachabilityNotificationStatusItem"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义block类型, 当网络状态改变时调用的block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFNetworkReachabilityStatusBlock)(AFNetworkReachabilityStatus status);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将枚举类型转换成字符串(这是对在.h中声明的实现)</span></span><br><span class="line"><span class="built_in">NSString</span> * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusNotReachable:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Not Reachable"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWWAN:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Reachable via WWAN"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWiFi:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Reachable via WiFi"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusUnknown:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Unknown"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(<span class="built_in">SCNetworkReachabilityFlags</span> flags) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != <span class="number">0</span>) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">BOOL</span> canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;</span><br><span class="line">    <span class="keyword">if</span> (isNetworkReachable == <span class="literal">NO</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusNotReachable;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#if TARGET_OS_IPHONE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class="number">0</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据SCNetworkReachabilityFlags这个网络标记转换成AFN中的网络状态<br>static修饰全局, 只能在当前文件使用：</p><ol><li>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，在编译期就会初始化，也就是说这个静态变量值要么为nil，要么在编译期就可以确定其值，生命周期和程序相同，其内存只被分配一次并存储到全局变量区，因此其值在下次调用时仍维持上次的值； </li><li>在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问； </li><li>在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内； </li><li>在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； </li><li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。</li></ol><p>修饰局部变量：</p><ol><li>延长局部变量的生命周期,程序结束才会销毁。</li><li>局部变量只会生成一份内存,只会初始化一次。</li><li>改变局部变量的作用域。</li></ol><p>修饰全局变量：</p><ol><li>只能在本文件中访问,修改全局变量的作用域,生命周期不会改</li><li>避免重复定义全局变量 </li></ol><p>优点：</p><ol><li>节省内存。静态变量只存储一处，但供所有对象使用。</li><li>它的值是可以更新的。</li><li>可提高时间效率。只要某个对象对静态变量更新一次，所有的对象都能访问更新后的值</li></ol><p>注意：</p><ol><li>静态方法只能调用静态方法和静态变量</li><li>如果.m文件和方法体里面定义了同名的static 变量，那么方法体里面的实例变量和全局的static变量不会冲突，在方法体内部访问的static变量和全局的static变量是不同的。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFPostReachabilityStatusChange(<span class="built_in">SCNetworkReachabilityFlags</span> flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">            block(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSNotificationCenter</span> *notificationCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:<span class="literal">nil</span> userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听网络状态的改变有两种, 一种是实现setReachabilityStatusChangeBlock:中的block, 另一种是监听通知AFNetworkingReachabilityDidChangeNotification, 此方法将监听网络状态改变的两种方式封装到一个函数中, 在主队列中异步执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数直接调用AFPostReachabilityStatusChange函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFNetworkReachabilityCallback(<span class="built_in">SCNetworkReachabilityRef</span> __unused target, <span class="built_in">SCNetworkReachabilityFlags</span> flags, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * AFNetworkReachabilityRetainCallback(<span class="keyword">const</span> <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">return</span> Block_copy(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFNetworkReachabilityReleaseCallback(<span class="keyword">const</span> <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info) &#123;</span><br><span class="line">        Block_release(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>void *表示“任意类型的指针” 或 表示“该指针与一地址值相关，但是不清楚在此地址上的对象的类型”。<blockquote><p>为什么不用void表示任意类型的数据呢？<br>大家都知道，C/C++是静态类型的语言，定义变量就会分配内存，然而，不同类型的变量所占内存不同，如果定义一个任意类型的变量，如何为其分配内存呢？所以，C、C++中没有任意类型的变量。<br>但是，所有指针类型的变量，无论是int、char、string、Student等等，他们的内存空间都是相同的，所以可以定义“任意类型的指针”。</p></blockquote></li><li>void * 指针只支持几种有限的操作：</li></ul><ol><li>与另一个指针进行比较</li><li>向函数传递void * 指针或从函数返回void * 指针</li><li>给另一个void *指针赋值<blockquote><p>不允许使用void * 指针操作它所指向的对象，例如，不允许对void * 指针进行解引用<br>不允许对void * 指针进行算术操作</p></blockquote></li></ol><p>block其实也是对象, 我们可以对其进行retain、copy操作,  在block做为属性的时候我们通常用copy去修饰block, 将block拷贝到堆内存中。<br>这两个block用于创建SCNetworkReachabilityContext结构体。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SCNetworkReachabilityRef 网络连接引用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">SCNetworkReachabilityRef</span> networkReachability;</span><br><span class="line"><span class="comment">// 网络状态, 枚举类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFNetworkReachabilityStatus networkReachabilityStatus;</span><br><span class="line"><span class="comment">// 网络状态切换block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFNetworkReachabilityStatusBlock networkReachabilityStatusBlock;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 句柄</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到callback调用后，将status通过networkReachabilityStatusBlock回调出去</span></span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     typedef struct &#123;</span></span><br><span class="line"><span class="comment">     CFIndex        version;</span></span><br><span class="line"><span class="comment">     void *        __nullable info;// void * 相当于oc中的id类型, 可以指向任何类型的参数</span></span><br><span class="line"><span class="comment">     const void    * __nonnull (* __nullable retain)(const void *info);// 接收一个函数, 目的是对info做retain操作</span></span><br><span class="line"><span class="comment">     void        (* __nullable release)(const void *info);// 接收一个函数, 目的是对info做release操作</span></span><br><span class="line"><span class="comment">     CFStringRef    __nonnull (* __nullable copyDescription)(const void *info);// 接收一个函数, 根据info获取description字符串</span></span><br><span class="line"><span class="comment">     &#125; SCNetworkReachabilityContext;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     context是一个结构体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 根据上下文设置回调</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilitySetCallback</span>(<span class="keyword">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    <span class="comment">// 加入线程池中 mainRunLoop commonModes</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的网络状态，调用callback</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>),^&#123;</span><br><span class="line">        <span class="built_in">SCNetworkReachabilityFlags</span> flags;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SCNetworkReachabilityGetFlags</span>(<span class="keyword">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是主要讲解的方法, AFNetworkReachabilityManager监测网络状态的核心就在此方法.<br>SCNetworkReachabilityContext是一个结构体(个人理解为结构体主要用于存储数据), void * __nullable info是指向需要执行的block的指针, 包含了用户指定的数据和用于SCNetworkReachabilitySetCallback方法的回调函数.<br>SCNetworkReachabilitySetCallback设置回调, 可以看我的另一篇文章有简要介绍.<br>SCNetworkReachabilityScheduleWithRunLoop将networkReachability网络连接引用加入到运行循环中. 个人理解为加入运行循环以后会一直监测networkReachability网络状态, 如果网络状态有变化就会调用AFNetworkReachabilityCallback.<br>在异步线程中发送一次网络状态, 调用SCNetworkReachabilityGetFlags获取网络状态, AFPostReachabilityStatusChange发送网路状态.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopMonitoring &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityUnscheduleFromRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从指定的运行循环和模式中移除网络连接引用的调度. 也就是说不再监听networkReachability的网络状态.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - NSKeyValueObserving</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"reachable"</span>] || [key isEqualToString:<span class="string">@"reachableViaWWAN"</span>] || [key isEqualToString:<span class="string">@"reachableViaWiFi"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"networkReachabilityStatus"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键值依赖, 返回一个键集合, 这些属性的值会影响指定的key的值, 当集合中键的值发生变化时, 就会触发指定key的监听通知.<br>当networkReachabilityStatus的值发生变化时, 就会触发指定的key的键值监听方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFNetworkReachabilityManager类是对接入网络类型的监听。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="AFNetWorking原理" scheme="https://nixzhang5.github.io/tags/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking原理四 AFURLResponseSerialization</title>
    <link href="https://nixzhang5.github.io/AFNetWorking%E5%8E%9F%E7%90%86%E5%9B%9B.html"/>
    <id>https://nixzhang5.github.io/AFNetWorking原理四.html</id>
    <published>2019-06-28T06:06:40.000Z</published>
    <updated>2019-06-28T09:03:10.316Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。</p><a id="more"></a><h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>AFURLResponseSerialization协议，通过协议来处理返回值，代码结构清晰、易于扩展</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"><span class="comment">// 对返回的数据进行解析，解析response为对应的数据类型（JSON、XML、plist、Image）,AFHTTPResponseSerializer的子类会重写这个方法，根据不同的需要解析成不同的结果，如AFJSONResponseSerializer会将数据解析成为JSON数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>父类</p><ul><li>AFHTTPResponseSerializer遵循AFURLResponseSerialization协议</li></ul><p>子类 所有子类都遵循AFURLResponseSerialization协议</p><ul><li>AFJSONResponseSerializer          JSON响应</li><li>AFXMLParserResponseSerializer     XMLParse响应</li><li>AFXMLDocumentResponseSerializer   XMLDocument响应</li><li>AFPropertyListResponseSerializer  PropertyList响应</li><li>AFImageResponseSerializer         Image响应</li><li>AFCompoundResponseSerializer      符合响应</li></ul><h3 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h3><p>对返回数据进行解析的父类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPResponseSerializer</span> : <span class="title">NSObject</span> &lt;<span class="title">AFURLResponseSerialization</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)serializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Configuring Response Serialization</span></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置接收的状态码，不在接受范围内的状态码会在验证时返回错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSIndexSet</span> *acceptableStatusCodes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置接收的contentTypes，不在范围内的contentType会在验证时返回错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSString</span> *&gt; *acceptableContentTypes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    验证服务器返回的数据，这个会使用到NSIndexSet *acceptableStatusCodes，NSIndexSet *acceptableStatusCodes这两个属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="keyword">nullable</span> <span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>初始化成功的状态码默认值 200 ~ 299</p><table><thead><tr><th align="left"></th><th align="left">类别</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left">1XX</td><td align="left">信息性状态码</td><td align="left">接收的请求正在处理</td></tr><tr><td align="left">2XX</td><td align="left">成功状态码</td><td align="left">请求正常处理完毕</td></tr><tr><td align="left">3XX</td><td align="left">重定向状态码</td><td align="left">需要进行附加操作以完成请求</td></tr><tr><td align="left">4XX</td><td align="left">客户端错误状态码</td><td align="left">服务器无法处理请求</td></tr><tr><td align="left">5XX</td><td align="left">服务器错误状态码</td><td align="left">服务器处理请求出错</td></tr></tbody></table><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.acceptableStatusCodes = [<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">    <span class="keyword">self</span>.acceptableContentTypes = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证响应和数据的有效性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证响应和数据的有效性（验证MIMEType和status code）。子类可添加其他特定域的检查。</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;<span class="comment">//response是否合法</span></span><br><span class="line">    <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//response是否存在和类型判断，如果response为空或者不是NSHTTPURLResponse类型，responseIsValid=YES!</span></span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//根据在初始化方法中初始化的属性 acceptableContentTypes 和 acceptableStatusCodes 来判断当前响应是否有效</span></span><br><span class="line">        <span class="comment">//1.response的内容类型不对（MIMEType）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">            !([response MIMEType] == <span class="literal">nil</span> &amp;&amp; [data length] == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//数据解析失败</span></span><br><span class="line">            <span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line">                <span class="comment">//NSLocalizedDescriptionKey是NSError头文件中预定义的键，标识错误的本地化描述.可以通过NSError的localizedDescription方法获得对应的值信息</span></span><br><span class="line">                <span class="comment">//NSURLErrorFailingURLErrorKey相应的值是包含导致加载失败的URL的NSURL。 此键仅存在于NSURLErrorDomain中。</span></span><br><span class="line">                <span class="comment">//生成错误信息字典。会返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中</span></span><br><span class="line">                <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                                          <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: unacceptable content-type: %@"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                                                          <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                                        &#125; mutableCopy];</span><br><span class="line">                <span class="keyword">if</span> (data) &#123;                    </span><br><span class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//+errorWithDomain: code: userInfo:创建和初始化NSError对象</span></span><br><span class="line">                <span class="comment">//NSErrorDomain错误域 - 这可以是预定义的NSError域之一，也可以是描述自定义域的任意字符串。 域名不能为空。</span></span><br><span class="line">                <span class="comment">//收到的内容数据具有未知内容编码（解析数据出错）。NSURLErrorCannotDecodeContentData = -1016，NSError错误码</span></span><br><span class="line">                <span class="comment">//出现错误时通过AFErrorWithUnderlyingError函数生成本地格式化的错误</span></span><br><span class="line">                validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.状态码无效</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">            <span class="comment">//-localizedStringForStatusCode:根据状态码获取本地化文本内容</span></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                               <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: %@ (%ld)"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response.statusCode], (<span class="keyword">long</span>)response.statusCode],</span><br><span class="line">                                               <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                       &#125; mutableCopy];</span><br><span class="line">            <span class="keyword">if</span> (data) &#123;                </span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//收到从服务器来的错误数据 NSURLErrorBadServerResponse = -1011,NSError错误码</span></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">            responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorCannotDecodeContentData。</span></span><br><span class="line"><span class="comment">如果MIME type不满足，，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorBadServerResponse。</span></span><br><span class="line"><span class="comment"> 2.方法中，有可能会出现两个错误，在self.acceptableContentTypes和self.acceptableStatusCodes这两个判断中，如果都出现错误怎么办呢？</span></span><br><span class="line"><span class="comment"> 这就用到了NSUnderlyingErrorKey 这个字段，它表示一个优先的错误，value为NSError对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol><li>根据初始化中的属性acceptableContentTypes和acceptableStatusCodes判断响应是否有效。</li><li>content-type不对，返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中。MIME type不对，处理相似，这里不展开。</li></ol><p>这个记录了错误信息的字典，系统提供的KEY值：</p><ul><li><p>NSError的Key:</p><ul><li>NSUnderlyingErrorKey                  优先错误，value是NSError</li><li>NSLocalizedDescriptionKey             错误描述</li><li>NSLocalizedFailureReasonErrorKey      错误的简要说明</li><li>NSLocalizedRecoverySuggestionErrorKey 修复建议</li><li>NSLocalizedRecoveryOptionErrorKey     修复选项</li></ul></li><li><p>NSURLError</p><ul><li>NSURLErrorFailingURLErrorKey</li><li>NSURLErrorFailingURLStringErrorKey</li><li>NSErrorFailingURLStringKey</li><li>NSURLErrorFailingURLPeeTrustErrorKey</li><li>NSURLErrorBackgroundTaskCancelledReasonKey</li></ul></li></ul><p>AF中自定义了AFNetworkingOperationFailingURLResponseErrorKey和AFNetworkingOperationFailingURLResponseDataErrorKey。</p><ol start="3"><li>出现错误时通过AFErrorWithUnderlyingError函数生成本地格式化的错误。<br> 3.1 如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为 NSURLErrorCannotDecodeContentData的自定义NSError。<br> 3.2 如果MIME type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为 NSURLErrorBadServerResponse的自定义NSError。</li><li>如果content type和MIMEtype同时出错，这就用到了NSUnderlyingErrorKey这个字段，它表示一个优先的错误，value为NSError对象。</li></ol><p>具体看下面这个函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成本地格式化的错误。填充错误信息，一些处理过程中产生的错误信息填充到我们需要返回给用户的自定义错误中</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSError</span> * AFErrorWithUnderlyingError(<span class="built_in">NSError</span> *error, <span class="built_in">NSError</span> *underlyingError) &#123;</span><br><span class="line">    <span class="comment">//NSUnderlyingErrorKey表示优先错误</span></span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!underlyingError || error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[<span class="built_in">NSUnderlyingErrorKey</span>] = underlyingError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSError</span> alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两者都出错的情况下，那么UnderlyingError就是content type error。</p><p>AFURLResponseSerialization协议的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从与指定响应相关联的数据中decode得到的响应对象。</span></span><br><span class="line"> - (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error&#123;</span><br><span class="line">    <span class="comment">//调用验证方法，返回data</span></span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把验证方法调用完之后就返回data，没有其他实现了。</p><h3 id="AFJSONResponseSerializer"><a href="#AFJSONResponseSerializer" class="headerlink" title="AFJSONResponseSerializer"></a>AFJSONResponseSerializer</h3><p>可接受的数据类型：application/json，text/json，text/javascript。<br>实现协议：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//验证MIMEType和status code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="comment">//error为空或者 错误、优先错误匹配error code和domain（在这里是content type类型的错误）</span></span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">    <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line">    <span class="comment">//数据是否是一个空格</span></span><br><span class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">" "</span> length:<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//如果数据为空或者是空格，就不json解析</span></span><br><span class="line">    <span class="keyword">if</span> (data.length == <span class="number">0</span> || isSpace) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//json解析。NSJSON只支持解析UTF8编码的数据</span></span><br><span class="line">    <span class="keyword">id</span> responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseObject)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">//用json解析的error去填充错误信息</span></span><br><span class="line">            *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否要从响应的JSON数据中删除带有“NSNull”值的键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>验证响应<br>验证失败。在没有error 或者 错误中的code是NSURLErrorCannotDecodeContentData（即content type不匹配）的情况下，是不能解析数据的，就返回nil。用到的函数：</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测错误或者优先错误中是否匹配code和domain</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFErrorOrUnderlyingErrorHasCodeInDomain(<span class="built_in">NSError</span> *error, <span class="built_in">NSInteger</span> code, <span class="built_in">NSString</span> *domain) &#123;</span><br><span class="line">    <span class="comment">//判断错误域和传过来的域名是否一致，错误code是否一致</span></span><br><span class="line">    <span class="keyword">if</span> ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;<span class="comment">//如果NSUnderlyingErrorKey对应有值，就再进行判断</span></span><br><span class="line">        <span class="keyword">return</span> AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>], code, domain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>处理返回的数据中只有空格的情况<br>如果数据为空或者只有一个空格，就不解析。</p></li><li><p>解析JSON<br>readingOptions属性设置json的读取选项。这里的默认值是NSJSONReadingMutableContainers</p></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSJSONReadingOptions</span>) &#123;</span><br><span class="line">    <span class="comment">//返回可变容器，NSMutableDictionary或NSMutableArray</span></span><br><span class="line">    <span class="built_in">NSJSONReadingMutableContainers</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), </span><br><span class="line">    <span class="comment">//返回的JSON对象中字符串的值为NSMutableString</span></span><br><span class="line">    <span class="built_in">NSJSONReadingMutableLeaves</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    <span class="comment">//允许JSON字符串最外层既不是NSArray也不是NSDictionary，但必须是有效的JSON Fragment。例如使用这个选项可以解析 @“123” 这样的字符串。</span></span><br><span class="line">    <span class="built_in">NSJSONReadingAllowFragments</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0);</span><br></pre></td></tr></table></figure><ol start="4"><li>是否要从响应的JSON数据中删除带有“NSNull”值的键<br>用到的函数：主要通过递归的手段来实现的。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从响应的JSON数据中删除带有“NSNull”值的键</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="comment">//遍历数组，通过递归的手段清空数组内的null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按位与操作，解析类型是否NSJSONReadingMutableContainers（mutableArray或者mutabledictionary）</span></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字典</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer"><a href="#AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer" class="headerlink" title="AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer"></a>AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer</h3><p>AFXMLParserResponseSerializer用来解析XML数据，支持的ContentType：application/xml、text/xml。<br>AFXMLDocumentResponseSerializer同上，但这个类只能在mac os x上使用。<br>AFPropertyListResponseSerializer用来解析plist数据，支持的ContentType：application/x-plist。<br>这三个子类的实现和上面JSON子类的实现差不多，就不具体展开了。</p><h3 id="AFImageResponseSerializer"><a href="#AFImageResponseSerializer" class="headerlink" title="AFImageResponseSerializer"></a>AFImageResponseSerializer</h3><p>用于验证和解码图像响应。</p><p>支持的ContentType：<br>image/tiff、image/jpeg、image/gif、image/png、image/ico、image/x-icon、image/bmp、image/x-bmp、image/x-xbitmap、image/x-win-bitmap</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//验证MIME type和status code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图片解压。宏判断是那种设备，进行对应的图片解压处理</span></span><br><span class="line"><span class="meta">#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.automaticallyInflatesResponseImage) &#123;<span class="comment">//是否对响应的图片进行自动处理</span></span><br><span class="line">        <span class="keyword">return</span> AFInflatedImageFromResponseWithDataAtScale((<span class="built_in">NSHTTPURLResponse</span> *)response, data, <span class="keyword">self</span>.imageScale);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AFImageWithDataAtScale(data, <span class="keyword">self</span>.imageScale);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// Ensure that the image is set to it's correct pixel width and height</span></span><br><span class="line">    <span class="built_in">NSBitmapImageRep</span> *bitimage = [[<span class="built_in">NSBitmapImageRep</span> alloc] initWithData:data];</span><br><span class="line">    <span class="built_in">NSImage</span> *image = [[<span class="built_in">NSImage</span> alloc] initWithSize:<span class="built_in">NSMakeSize</span>([bitimage pixelsWide], [bitimage pixelsHigh])];</span><br><span class="line">    [image addRepresentation:bitimage];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里用到了几个方法，写在了UIImage分类UIImage (AFNetworkingSafeImageLoading)里面。下面来看一下分类中的这几个方法：</p><ol><li>把NSData安全地转换为UIImage。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)af_safeImageWithData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">UIImage</span>* image = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        imageLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    [imageLock lock];<span class="comment">//上锁</span></span><br><span class="line">    image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    [imageLock unlock];<span class="comment">//开锁</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们读写一个数据的时候，由于数据还可能被别人读写，这就有可能出现不安全的情况，为了解决这个问题，就使用了“锁”。如果对线程锁比较熟悉的话就容易理解了，简单说呢，就是在写数据前先上锁，那么别人就无法使用这块数据了，直到你执行完数据操作、解锁。</p><ol start="2"><li>私有函数，按照scale对图片进行伸缩处理</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个按照scale收缩的图片</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">UIImage</span> * AFImageWithDataAtScale(<span class="built_in">NSData</span> *data, <span class="built_in">CGFloat</span> scale) &#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> af_safeImageWithData:data];</span><br><span class="line">    <span class="keyword">if</span> (image.images) &#123;<span class="comment">//gif图不需要伸缩</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">UIImage</span> alloc] initWithCGImage:[image <span class="built_in">CGImage</span>] scale:scale orientation:image.imageOrientation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于image.images：这个属性第一次接触，大致看了一下，常见的应用是用来生成一个gif效果。在gif图中表示这个Gif包含了多少张图片。</p><ol start="3"><li>根据响应结果和scale返回一张图片.完成图像解压工作</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">UIImage</span> * AFInflatedImageFromResponseWithDataAtScale(<span class="built_in">NSHTTPURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">CGFloat</span> scale)</span><br></pre></td></tr></table></figure><p>这个函数实现很长，用到了CoreGraphics上的一些东西，主要完成iOS、TV、Watch设备下的图像解压工作。关于图像解压的目的，我在这篇文章中读到这么一段话：</p><blockquote><p>AFJSONResponseSerializer使用系统内置的NSJSONSerialization解析json，NSJSON只支持解析UTF8编码的数据（还有UTF-16LE之类的，都不常用），所以要先把返回的数据转成UTF8格式。这里会尝试用HTTP返回的编码类型和自己设置的stringEncoding去把数据解码转成字符串NSString，再把NSString用UTF8编码转成NSData，再用NSJSONSerialization解析成对象返回。<br><br>上述过程是NSData-&gt;NSString-&gt;NSData-&gt;NSObject，这里有个问题，如果你能确定服务端返回的是UTF8编码的json数据，那NSData-&gt;NSString-&gt;NSData这两步就是无意义的，而且这两步进行了两次编解码，很浪费性能，所以如果确定服务端返回utf8编码数据，就建议自己再写个JSONResponseSerializer，跳过这两个步骤。<br><br>此外AFJSONResponseSerializer专门写了个方法去除NSNull，直接把对象里值是NSNull的键去掉，还蛮贴心，若不去掉，上层很容易忽略了这个数据类型，判断了数据是否nil没判断是否NSNull，进行了错误的调用导致core。<br><br><strong>图片解压</strong><br><br>当我们调用UIImage的方法imageWithData:方法把数据转成UIImage对象后，其实这时UIImage对象还没准备好需要渲染到屏幕的数据，现在的网络图像PNG和JPG都是压缩格式，需要把它们解压转成bitmap后才能渲染到屏幕上，如果不做任何处理，当你把UIImage赋给UIImageView，在渲染之前底层会判断到UIImage对象未解压，没有bitmap数据，这时会在主线程对图片进行解压操作，再渲染到屏幕上。这个解压操作是比较耗时的，如果任由它在主线程做，可能会导致速度慢UI卡顿的问题。<br><br>AFImageResponseSerializer除了把返回数据解析成UIImage外，还会把图像数据解压，这个处理是在子线程（AFNetworking专用的一条线程，详见AFURLConnectionOperation），处理后上层使用返回的UIImage在主线程渲染时就不需要做解压这步操作，主线程减轻了负担，减少了UI卡顿问题。<br>具体实现上在AFInflatedImageFromResponseWithDataAtScale里，创建一个画布，把UIImage画在画布上，再把这个画布保存成UIImage返回给上层。只有JPG和PNG才会尝试去做解压操作，期间如果解压失败，或者遇到CMKY颜色格式的jpg，或者图像太大(解压后的bitmap太占内存，一个像素3-4字节，搞不好内存就爆掉了)，就直接返回未解压的图像。<br><br>另外在代码里看到iOS才需要这样手动解压，MacOS上已经有封装好的对象NSBitmapImageRep可以做这个事。</p></blockquote><h3 id="AFCompoundResponseSerializer"><a href="#AFCompoundResponseSerializer" class="headerlink" title="AFCompoundResponseSerializer"></a>AFCompoundResponseSerializer</h3><p>这是一个对复合类型的响应进行处理的子类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历数组，只要是属于AFHTTPResponseSerializer及其子类的类型，就执行相应的响应操作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> &lt;AFURLResponseSerialization&gt; serializer <span class="keyword">in</span> <span class="keyword">self</span>.responseSerializers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![serializer isKindOfClass:[AFHTTPResponseSerializer <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSError</span> *serializerError = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">id</span> responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError];</span><br><span class="line">        <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = AFErrorWithUnderlyingError(serializerError, *error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> responseObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上类型都不是，就执行默认响应操作。</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> responseObjectForResponse:response data:data error:error];<span class="comment">//调用父类方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>responseSerializers属性，这个数组中装着多种序列化类型，比如上面讲到的JSON、XML等等。<br>遍历数组，只要是属于AFHTTPResponseSerializer及其子类的类型，就执行相应的响应操作。如果以上类型都不是，就执行默认的响应。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="AFNetWorking原理" scheme="https://nixzhang5.github.io/tags/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking原理三 AFURLRequestSerialization</title>
    <link href="https://nixzhang5.github.io/AFNetWorking%E5%8E%9F%E7%90%86%E4%B8%89.html"/>
    <id>https://nixzhang5.github.io/AFNetWorking原理三.html</id>
    <published>2019-06-27T03:28:59.000Z</published>
    <updated>2019-07-01T03:39:01.038Z</updated>
    
    <content type="html"><![CDATA[<p>AFURLRequestSerialization序列化网络请求参数</p><a id="more"></a><p>AFURLRequestSerialization包含了四个部分：</p><ol><li>全局方法:AFPercentEscapedStringFromString和AFQueryStringFromParameters。</li><li>协议AFURLRequestSerialization提供了一个序列化parameters参数的方法。我们可以把参数转换为查询字符串、HTTP请求体、设置恰当的请求头等。</li><li>AFHTTPRequestSerializer继承自AFURLRequestSerialization协议。提供了查询字符串/URL格式的参数序列化、默认请求头处理。同时以提供HTTP状态码和返回数据的验证等工作。<br>_ AFMultipartFormData协议。主要用于添加multipart/form-data请求的Content-Disposition: file; filename=#{generated filename}; name=#{name}” 和 Content-Type: #{generated mimeType}的请求体域。</li><li>类型AFJSONRequestSerializer和AFPropertyListRequestSerializer。主要针对JSON和Plist类型的序列化优化。</li></ol><h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><h4 id="AFPercentEscapedStringFromString"><a href="#AFPercentEscapedStringFromString" class="headerlink" title="AFPercentEscapedStringFromString"></a>AFPercentEscapedStringFromString</h4><p>把字符串转化成符合标准的URL编码字符串，主要是通过一个字符集NSMutableCharacterSet来定义需要进行转码的字符，再通过-[NSString stringByAddingPercentEncodingWithAllowedCharacters]方法来进行转码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">AFURLRequestSerialization.h</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * AFPercentEscapedStringFromString(<span class="built_in">NSString</span> *string);</span><br><span class="line"></span><br><span class="line">AFURLRequestSerialization.m</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> * AFPercentEscapedStringFromString(<span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="comment">// does not include "?" or "/" due to RFC 3986 - Section 3.4</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kAFCharactersGeneralDelimitersToEncode = <span class="string">@":#[]@"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kAFCharactersSubDelimitersToEncode = <span class="string">@"!$&amp;'()*+,;="</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableCharacterSet</span> * allowedCharacterSet = [[<span class="built_in">NSCharacterSet</span> URLQueryAllowedCharacterSet] mutableCopy];</span><br><span class="line">    [allowedCharacterSet removeCharactersInString:[kAFCharactersGeneralDelimitersToEncode stringByAppendingString:kAFCharactersSubDelimitersToEncode]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSUInteger</span> <span class="keyword">const</span> batchSize = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *escaped = <span class="string">@""</span>.mutableCopy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; string.length) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> length = MIN(string.length - index, batchSize);</span><br><span class="line">        <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(index, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To avoid breaking up character sequences such as 👴🏻👮🏽</span></span><br><span class="line">        range = [string rangeOfComposedCharacterSequencesForRange:range];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *substring = [string substringWithRange:range];</span><br><span class="line">        <span class="built_in">NSString</span> *encoded = [substring stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet];</span><br><span class="line">        [escaped appendString:encoded];</span><br><span class="line"></span><br><span class="line">        index += range.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> escaped;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AFQueryStringFromParameters"><a href="#AFQueryStringFromParameters" class="headerlink" title="AFQueryStringFromParameters"></a>AFQueryStringFromParameters</h4><p>把字典转化为&amp;拼接的参数，通过AFQueryStringPair类来实现的。</p><p>AFQueryStringPair来存取每一个查询属性，将查询的键值保持起来，然后通过URLEncodedStringValue方法在需要时进行拼接，并且使用了上面所述的AFPercentEscapedStringFromString方法进行了URLEncode。其中最主要的方法是AFQueryStringPairsFromKeyAndValue，它将字典的每一个键值对生成的对应的AFQueryStringPair对象，例如将machine:[iphone, mac]转换为URLEncodedStringValue值是machine[]=iphone和machine[]=mac的两个AFQueryStringPair对象。之后AFQueryStringFromParameters方法再以’&amp;’符号对它们进行拼接。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AFURLRequestSerialization.h</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters);</span><br><span class="line"></span><br><span class="line">AFURLRequestSerialization.m</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFQueryStringPair</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> field;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> value;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFQueryStringPair</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.field = field;</span><br><span class="line">    <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.value || [<span class="keyword">self</span>.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@=%@"</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]), AFPercentEscapedStringFromString([<span class="keyword">self</span>.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary);</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">    <span class="keyword">return</span> AFQueryStringPairsFromKeyAndValue(<span class="literal">nil</span>, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"description"</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = value;</span><br><span class="line">        <span class="comment">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedKey <span class="keyword">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="keyword">id</span> nestedValue = dictionary[nestedKey];</span><br><span class="line">            <span class="keyword">if</span> (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@[%@]"</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedValue <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@[]"</span>, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSSet</span> *set = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h3><p>先声明了一个协议AFURLRequestSerialization继承了NSSecureCoding和NSCopying来保证所有实现这个序列化协议的序列化器类都有安全编码和复制的能力。协议也定义了序列化的规范方法。（协议，有利于扩展）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    AFURLRequestSerialization协议可以被一个编码特定http请求的对象实现。</span></span><br><span class="line"><span class="comment">    请求序列化器（Request serializer）可以编码查询语句、HTTP请求体，如果必须的话，可以自行设置合适的HTTP请求体内容（如：Agent:iOS）。</span></span><br><span class="line"><span class="comment">    例如，一个JSON请求序列化器会把请求体Content-Type设置为application/json。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    返回一个使用了指定参数编码的请求的拷贝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                        withParameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                                 error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h3><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSURLRequestCachePolicy</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        默认缓存策略。具体工作：如果一个NSCachedURLResponse对于请求并不存在，数据将会从源端获取。如果请求拥有一个缓存的响应，那么URL加载系统会检查这个响应来决定，如果它指定内容必须重新生效的话。假如内容必须重新生效，将建立一个连向源端的连接来查看内容是否发生变化。假如内容没有变化，那么响应就从本地缓存返回数据。如果内容变化了，那么数据将从源端获取</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        URL应该加载源端数据，不使用本地缓存数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        本地缓存数据、代理和其他中介都要忽视他们的缓存，直接加载源数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span> = <span class="number">4</span>, <span class="comment">// Unimplemented</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringCacheData</span> = <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        指定已存的缓存数据应该用来响应请求，不管它的生命时长和过期时间。如果在缓存中没有已存数据来响应请求的话，数据从源端加载。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        指定已存的缓存数据用来满足请求，不管生命时长和过期时间。如果在缓存中没有已存数据来响应URL加载请求的话，不去尝试从源段加载数据，此时认为加载请求失败。这个常量指定了一个类似于离线模式的行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span> = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        指定如果已存的缓存数据被提供它的源段确认为有效则允许使用缓存数据响应请求，否则从源段加载数据。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadRevalidatingCacheData</span> = <span class="number">5</span>, <span class="comment">// Unimplemented</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NSURLRequestReturnCacheDataDontLoad是用于离线模式的，我为了能让用户在离线下面阅读，我就设计了当没有网络的时候的策略为NSURLRequestReturnCacheDataDontLoad。</p><h4 id="创建普通NSMutableURLRequest请求对象声明"><a href="#创建普通NSMutableURLRequest请求对象声明" class="headerlink" title="创建普通NSMutableURLRequest请求对象声明"></a>创建普通NSMutableURLRequest请求对象声明</h4><p>HTTP序列化器类AFHTTPRequestSerializer，实现了AFURLRequestSerialization协议，并参考了NSMutableURLRequest类声明了很多请求设置相关属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    AFHTTPRequestSerializer实现了AFURLRequestSerialization协议，为查询语句、URL表单编码参数的序列化提供一个具体的实现和默认的请求头，以及状态码和内容类型的校验。</span></span><br><span class="line"><span class="comment">    所有的request和response都被鼓励去继承AFHTTPRequestSerializer类，以确保默认方法和属性的一致性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPRequestSerializer</span> : <span class="title">NSObject</span> &lt;<span class="title">AFURLRequestSerialization</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    字符串编码方式，默认为NSUTF8StringEncoding</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    是否允许手机访问，默认为YES</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowsCellularAccess;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    缓存策略。默认为NSURLRequestUseProtocolCachePolicy</span></span><br><span class="line"><span class="comment">    参考NSMutableURLRequest -setCachePolicy:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    是否用cookie来处理创建的请求。默认为YES</span></span><br><span class="line"><span class="comment">    参考NSMutableURLRequest -setHTTPShouldHandleCookies</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> HTTPShouldHandleCookies;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    创建的请求在收到上个传输（transmission）响应之前是否继续发送数据。</span></span><br><span class="line"><span class="comment">    默认为NO(即等待上次传输完成后再请求)</span></span><br><span class="line"><span class="comment">    参考NSMutableURLRequest -setHTTPShouldUsePipelining:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> HTTPShouldUsePipelining;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    请求的网络服务类型。</span></span><br><span class="line"><span class="comment">    这个服务类型向整个网络传输层次提供了一个关于该请求目的的提示。</span></span><br><span class="line"><span class="comment">    （The service type is used to provide the networking layers a hint of the purpose of the request.）</span></span><br><span class="line"><span class="comment">    默认为NSURLNetworkServiceTypeDefault</span></span><br><span class="line"><span class="comment">    参考NSMutableURLRequest -setNetworkServiceType:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSURLRequestNetworkServiceType</span> networkServiceType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    请求的超时间隔，单位秒。默认为60秒</span></span><br><span class="line"><span class="comment">    参考NSMutableURLRequest -setTimeoutInterval:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeoutInterval;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Configuring HTTP Request Headers</span></span><br><span class="line"><span class="comment">///---------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    序列请求的默认请求头。默认值包括</span></span><br><span class="line"><span class="comment">    'Accept-Language’  内容为 'NSLocale +preferredLanguages’ 方法获取的语音</span></span><br><span class="line"><span class="comment">    'User-Agent’  内容为各种bundle的标志已经系统信息</span></span><br><span class="line"><span class="comment">    可以使用'setValue:forHTTPHeaderField:’方法添加或删除请求头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *HTTPRequestHeaders;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    类方法创建实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)serializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置HTTPHeader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="built_in">NSString</span> *)field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    获取HTTPHeader field对应的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置身份信息header</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setAuthorizationHeaderFieldWithUsername:(<span class="built_in">NSString</span> *)username</span><br><span class="line">                                       password:(<span class="built_in">NSString</span> *)password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    清除身份认证信息header</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)clearAuthorizationHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Configuring Query String Parameter Serialization</span></span><br><span class="line"><span class="comment">///-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    哪些HTTP请求方法会将参数编码成查询字符串（如:name=xgb&amp;gender=1）。默认为GET, HEAD和DELETE。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSString</span> *&gt; *HTTPMethodsEncodingParametersInURI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    查询参数的转义样式.(目前只有一种)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    自定义参数的转义方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setQueryStringSerializationWithBlock:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> * (^)(<span class="built_in">NSURLRequest</span> *request, <span class="keyword">id</span> parameters, <span class="built_in">NSError</span> * __autoreleasing *error))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------------</span></span><br><span class="line"><span class="comment">/// @name Creating Request Objects</span></span><br><span class="line"><span class="comment">///-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    如果请求方式为GET`, `HEAD`, or `DELETE时、参数会被拼接到URL中、否则当做body处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="创建普通NSMutableURLRequest请求对象实现"><a href="#创建普通NSMutableURLRequest请求对象实现" class="headerlink" title="创建普通NSMutableURLRequest请求对象实现"></a>创建普通NSMutableURLRequest请求对象实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFHTTPRequestSerializerObservedKeyPaths方法定义可以需要被观察的属性（这些属性为公开的属性，可能被用户修改），包括cachePolicy、HTTPShouldHandleCookies、HTTPShouldUsePipelining、networkServiceType和timeoutInterval。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPRequestSerializer</span> ()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    保存用户修改过的属性，包括AFHTTPRequestSerializerObservedKeyPaths包含的属性。</span></span><br><span class="line"><span class="comment">    当用户修改这些属性值时记录起来，创建Request时使用，没修改的使用默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *mutableObservedChangedKeyPaths;</span><br><span class="line"><span class="comment">/** 真正存储Header的属性。 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableHTTPRequestHeaders;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    用一个串行线程来统一处理Header的修改，避免多线程造成的线程安全问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> requestHeaderModificationQueue;</span><br><span class="line"><span class="comment">/** 目前只有一个值 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFHTTPRequestQueryStringSerializationStyle queryStringSerializationStyle;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    用于自定义查询字符串的拼接。</span></span><br><span class="line"><span class="comment">    因为AFURLRequestSerialization协议定义的方法-requestBySerializingRequest:withParameters:error:传入的parameters是以字典的形式传入，所以需要将字典拼接成查询字符串，默认是使用AFQueryStringFromParameters方法拼接。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFQueryStringSerializationBlock queryStringSerialization;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFHTTPRequestSerializer</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    初始化方法主要是对一些属性初始化，以及将HTTP头部按照w3c标准进行了封装，根据AFHTTPRequestSerializerObservedKeyPaths方法对一些必要的属性使用KVO进行了监听。在这些被监听的属性的setter里面手动地发送通知，避免出现奇怪的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.stringEncoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mutableHTTPRequestHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="keyword">self</span>.requestHeaderModificationQueue = dispatch_queue_create(<span class="string">"requestHeaderModificationQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accept-Language HTTP Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *acceptLanguagesComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [[<span class="built_in">NSLocale</span> preferredLanguages] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">float</span> q = <span class="number">1.0</span>f - (idx * <span class="number">0.1</span>f);</span><br><span class="line">        [acceptLanguagesComponents addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@;q=%0.1g"</span>, obj, q]];</span><br><span class="line">        *stop = q &lt;= <span class="number">0.5</span>f;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span> setValue:[acceptLanguagesComponents componentsJoinedByString:<span class="string">@", "</span>] forHTTPHeaderField:<span class="string">@"Accept-Language"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *userAgent = <span class="literal">nil</span>;</span><br><span class="line"><span class="meta">#if TARGET_OS_IOS</span></span><br><span class="line">    <span class="comment">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span></span><br><span class="line">    userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (%@; iOS %@; Scale/%0.2f)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">UIDevice</span> currentDevice] model], [[<span class="built_in">UIDevice</span> currentDevice] systemVersion], [[<span class="built_in">UIScreen</span> mainScreen] scale]];</span><br><span class="line"><span class="meta">#elif TARGET_OS_WATCH</span></span><br><span class="line">    <span class="comment">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span></span><br><span class="line">    userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (%@; watchOS %@; Scale/%0.2f)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">WKInterfaceDevice</span> currentDevice] model], [[<span class="built_in">WKInterfaceDevice</span> currentDevice] systemVersion], [[<span class="built_in">WKInterfaceDevice</span> currentDevice] screenScale]];</span><br><span class="line"><span class="meta">#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)</span></span><br><span class="line">    userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (Mac OS X %@)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">NSProcessInfo</span> processInfo] operatingSystemVersionString]];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">if</span> (userAgent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![userAgent canBeConvertedToEncoding:<span class="built_in">NSASCIIStringEncoding</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSMutableString</span> *mutableUserAgent = [userAgent mutableCopy];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)(mutableUserAgent), <span class="literal">NULL</span>, (__bridge <span class="built_in">CFStringRef</span>)<span class="string">@"Any-Latin; Latin-ASCII; [:^ASCII:] Remove"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                userAgent = mutableUserAgent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> setValue:userAgent forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</span></span><br><span class="line">    <span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"GET"</span>, <span class="string">@"HEAD"</span>, <span class="string">@"DELETE"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mutableObservedChangedKeyPaths = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> removeObserver:<span class="keyword">self</span> forKeyPath:keyPath context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Workarounds for crashing behavior using Key-Value Observing with XCTest</span></span><br><span class="line"><span class="comment">// See https://github.com/AFNetworking/AFNetworking/issues/2523</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAllowsCellularAccess:(<span class="built_in">BOOL</span>)allowsCellularAccess &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess))];</span><br><span class="line">    _allowsCellularAccess = allowsCellularAccess;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCachePolicy:(<span class="built_in">NSURLRequestCachePolicy</span>)cachePolicy &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy))];</span><br><span class="line">    _cachePolicy = cachePolicy;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHTTPShouldHandleCookies:(<span class="built_in">BOOL</span>)HTTPShouldHandleCookies &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies))];</span><br><span class="line">    _HTTPShouldHandleCookies = HTTPShouldHandleCookies;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHTTPShouldUsePipelining:(<span class="built_in">BOOL</span>)HTTPShouldUsePipelining &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining))];</span><br><span class="line">    _HTTPShouldUsePipelining = HTTPShouldUsePipelining;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setNetworkServiceType:(<span class="built_in">NSURLRequestNetworkServiceType</span>)networkServiceType &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType))];</span><br><span class="line">    _networkServiceType = networkServiceType;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTimeoutInterval:(<span class="built_in">NSTimeInterval</span>)timeoutInterval &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    _timeoutInterval = timeoutInterval;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)HTTPRequestHeaders &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> __block *value;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.requestHeaderModificationQueue, ^&#123;</span><br><span class="line">        value = [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:<span class="keyword">self</span>.mutableHTTPRequestHeaders];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value</span><br><span class="line">forHTTPHeaderField:(<span class="built_in">NSString</span> *)field</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.requestHeaderModificationQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.mutableHTTPRequestHeaders setValue:value forKey:field];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    <span class="built_in">NSString</span> __block *value;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.requestHeaderModificationQueue, ^&#123;</span><br><span class="line">        value = [<span class="keyword">self</span>.mutableHTTPRequestHeaders valueForKey:field];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过账号密码设置授权请求头</span></span><br><span class="line">- (<span class="keyword">void</span>)setAuthorizationHeaderFieldWithUsername:(<span class="built_in">NSString</span> *)username</span><br><span class="line">                                       password:(<span class="built_in">NSString</span> *)password</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *basicAuthCredentials = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:%@"</span>, username, password] dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(<span class="built_in">NSDataBase64EncodingOptions</span>)<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Basic %@"</span>, base64AuthCredentials] forHTTPHeaderField:<span class="string">@"Authorization"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除授权用请求头</span></span><br><span class="line">- (<span class="keyword">void</span>)clearAuthorizationHeader &#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.requestHeaderModificationQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.mutableHTTPRequestHeaders removeObjectForKey:<span class="string">@"Authorization"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//设置查询参数的编码方式</span></span><br><span class="line">- (<span class="keyword">void</span>)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style &#123;</span><br><span class="line">    <span class="keyword">self</span>.queryStringSerializationStyle = style;</span><br><span class="line">    <span class="keyword">self</span>.queryStringSerialization = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置查询参数自定义编码的block</span></span><br><span class="line">- (<span class="keyword">void</span>)setQueryStringSerializationWithBlock:(<span class="built_in">NSString</span> *(^)(<span class="built_in">NSURLRequest</span> *, <span class="keyword">id</span>, <span class="built_in">NSError</span> *__autoreleasing *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.queryStringSerialization = block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//通过请求方式、URL、参数字典生成请求</span></span><br><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(URLString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line">    <span class="comment">//如果某个关键属性被自主设置过、则用新的。不然直接用模板生成的`NSMutableURLRequest`即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对req进一步设置(拼接URL、请求体、请求头)</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - AFURLRequestSerialization</span></span><br><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请求头</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据参数parameters设置查询字段</span></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断参数是拼到url还是放到HTTPBody</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSKeyValueObserving</span></span><br><span class="line"><span class="comment">// 可以决定是否发送KVO通知</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            <span class="comment">//如果没有新值、则清空所属监听</span></span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSSecureCoding</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)supportsSecureCoding &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mutableHTTPRequestHeaders = [[decoder decodeObjectOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(mutableHTTPRequestHeaders))] mutableCopy];</span><br><span class="line">    <span class="keyword">self</span>.queryStringSerializationStyle = (AFHTTPRequestQueryStringSerializationStyle)[[decoder decodeObjectOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(queryStringSerializationStyle))] unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.requestHeaderModificationQueue, ^&#123;</span><br><span class="line">        [coder encodeObject:<span class="keyword">self</span>.mutableHTTPRequestHeaders forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(mutableHTTPRequestHeaders))];</span><br><span class="line">    &#125;);</span><br><span class="line">    [coder encodeInteger:<span class="keyword">self</span>.queryStringSerializationStyle forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(queryStringSerializationStyle))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSCopying</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFHTTPRequestSerializer *serializer = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.requestHeaderModificationQueue, ^&#123;</span><br><span class="line">        serializer.mutableHTTPRequestHeaders = [<span class="keyword">self</span>.mutableHTTPRequestHeaders mutableCopyWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    serializer.queryStringSerializationStyle = <span class="keyword">self</span>.queryStringSerializationStyle;</span><br><span class="line">    serializer.queryStringSerialization = <span class="keyword">self</span>.queryStringSerialization;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现里面用到了 KVO 和 GCD<br>KVO很巧妙的把几个属性值的更改统一处理，代码清晰、简洁<br>GCD栅栏函数</p><h4 id="AFMultipartFormData协议"><a href="#AFMultipartFormData协议" class="headerlink" title="AFMultipartFormData协议"></a>AFMultipartFormData协议</h4><p>上传图片或者其他文件的</p><ol><li>初始化边界</li><li>body头</li><li>body</li><li>结束边界</li></ol><p>协议：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)appendPartWithFileURL:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                         name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)appendPartWithFileURL:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                         name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                     fileName:(<span class="built_in">NSString</span> *)fileName</span><br><span class="line">                     mimeType:(<span class="built_in">NSString</span> *)mimeType</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithInputStream:(<span class="keyword">nullable</span> <span class="built_in">NSInputStream</span> *)inputStream</span><br><span class="line">                             name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                         fileName:(<span class="built_in">NSString</span> *)fileName</span><br><span class="line">                           length:(int64_t)length</span><br><span class="line">                         mimeType:(<span class="built_in">NSString</span> *)mimeType;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithFileData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                      fileName:(<span class="built_in">NSString</span> *)fileName</span><br><span class="line">                      mimeType:(<span class="built_in">NSString</span> *)mimeType;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithFormData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          name:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithHeaders:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                         body:(<span class="built_in">NSData</span> *)body;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)throttleBandwidthWithPacketSize:(<span class="built_in">NSUInteger</span>)numberOfBytes</span><br><span class="line">                                  delay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure><p>Body部分：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPBodyPart</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 编码方式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"><span class="comment">// 头</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> *headers;</span><br><span class="line"><span class="comment">// 边界</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *boundary;</span><br><span class="line"><span class="comment">// 主体</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> body;</span><br><span class="line"><span class="comment">// 主题内容长度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bodyContentLength;</span><br><span class="line"><span class="comment">// 流</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSInputStream</span> *inputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否有初始边界</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasInitialBoundary;</span><br><span class="line"><span class="comment">// 是否有结束边界</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasFinalBoundary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否有可用字节，是否为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = hasBytesAvailable) <span class="built_in">BOOL</span> bytesAvailable;</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> contentLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer</span><br><span class="line">        maxLength:(<span class="built_in">NSUInteger</span>)length;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AFHTTPBodyPart类属性可以看出，已经包含了四大组成部分</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    AFEncapsulationBoundaryPhase = <span class="number">1</span>,</span><br><span class="line">    AFHeaderPhase                = <span class="number">2</span>,</span><br><span class="line">    AFBodyPhase                  = <span class="number">3</span>,</span><br><span class="line">    AFFinalBoundaryPhase         = <span class="number">4</span>,</span><br><span class="line">&#125; AFHTTPBodyPartReadPhase;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPBodyPart</span> () &lt;<span class="title">NSCopying</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 使用枚举 包装body4大组成部分</span></span><br><span class="line">    AFHTTPBodyPartReadPhase _phase;</span><br><span class="line">    <span class="comment">// 输入流</span></span><br><span class="line">    <span class="built_in">NSInputStream</span> *_inputStream;</span><br><span class="line">    <span class="comment">// 每个组成部分的位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> _phaseReadOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移到下一个阶段</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)transitionToNextPhase;</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)readData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">           intoBuffer:(uint8_t *)buffer</span><br><span class="line">            maxLength:(<span class="built_in">NSUInteger</span>)length;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对AFHTTPBodyPart的扩展部分，可以看出曾加了三个属性、两个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFHTTPBodyPart 实现部分</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFHTTPBodyPart</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> transitionToNextPhase];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (_inputStream) &#123;</span><br><span class="line">        [_inputStream close];</span><br><span class="line">        _inputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// body可能有好几种类型，根据不同的类型返回不同方法创建的NSInputStream 。</span></span><br><span class="line">- (<span class="built_in">NSInputStream</span> *)inputStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_inputStream) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithData:<span class="keyword">self</span>.body];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithURL:<span class="keyword">self</span>.body];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSInputStream</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = <span class="keyword">self</span>.body;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithData:[<span class="built_in">NSData</span> data]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _inputStream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据header字典拼body头</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringForHeaders &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *headerString = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *field <span class="keyword">in</span> [<span class="keyword">self</span>.headers allKeys]) &#123;</span><br><span class="line">        [headerString appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@: %@%@"</span>, field, [<span class="keyword">self</span>.headers valueForKey:field], kAFMultipartFormCRLF]];</span><br><span class="line">    &#125;</span><br><span class="line">    [headerString appendString:kAFMultipartFormCRLF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithString:headerString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取body的大小  用到几个函数</span></span><br><span class="line">- (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)contentLength &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> length = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化边界</span></span><br><span class="line">    <span class="built_in">NSData</span> *encapsulationBoundaryData = [([<span class="keyword">self</span> hasInitialBoundary] ? AFMultipartFormInitialBoundary(<span class="keyword">self</span>.boundary) : AFMultipartFormEncapsulationBoundary(<span class="keyword">self</span>.boundary)) dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">    length += [encapsulationBoundaryData length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头</span></span><br><span class="line">    <span class="built_in">NSData</span> *headersData = [[<span class="keyword">self</span> stringForHeaders] dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">    length += [headersData length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主体</span></span><br><span class="line">    length += _bodyContentLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束边界</span></span><br><span class="line">    <span class="built_in">NSData</span> *closingBoundaryData = ([<span class="keyword">self</span> hasFinalBoundary] ? [AFMultipartFormFinalBoundary(<span class="keyword">self</span>.boundary) dataUsingEncoding:<span class="keyword">self</span>.stringEncoding] : [<span class="built_in">NSData</span> data]);</span><br><span class="line">    length += [closingBoundaryData length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否还有数据</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasBytesAvailable &#123;</span><br><span class="line">    <span class="comment">// Allows `read:maxLength:` to be called again if `AFMultipartFormFinalBoundary` doesn't fit into the available buffer</span></span><br><span class="line">    <span class="keyword">if</span> (_phase == AFFinalBoundaryPhase) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.inputStream.streamStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusNotOpen</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusOpening</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusOpen</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusReading</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusWriting</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusAtEnd</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusClosed</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamStatusError</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这两个方法是把body数据写入到buffer中。通过观察着这两个方法，可得知，这两个方法肯定在其他的代码中的某个循环中被调用，目的是得到想要的数据格式</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer</span><br><span class="line">        maxLength:(<span class="built_in">NSUInteger</span>)length</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> totalNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_phase == AFEncapsulationBoundaryPhase) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *encapsulationBoundaryData = [([<span class="keyword">self</span> hasInitialBoundary] ? AFMultipartFormInitialBoundary(<span class="keyword">self</span>.boundary) : AFMultipartFormEncapsulationBoundary(<span class="keyword">self</span>.boundary)) dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_phase == AFHeaderPhase) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *headersData = [[<span class="keyword">self</span> stringForHeaders] dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_phase == AFBodyPhase) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> numberOfBytesRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        numberOfBytesRead = [<span class="keyword">self</span>.inputStream read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">        <span class="keyword">if</span> (numberOfBytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalNumberOfBytesRead += numberOfBytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.inputStream streamStatus] &gt;= <span class="built_in">NSStreamStatusAtEnd</span>) &#123;</span><br><span class="line">                [<span class="keyword">self</span> transitionToNextPhase];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_phase == AFFinalBoundaryPhase) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *closingBoundaryData = ([<span class="keyword">self</span> hasFinalBoundary] ? [AFMultipartFormFinalBoundary(<span class="keyword">self</span>.boundary) dataUsingEncoding:<span class="keyword">self</span>.stringEncoding] : [<span class="built_in">NSData</span> data]);</span><br><span class="line">        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalNumberOfBytesRead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)readData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">           intoBuffer:(uint8_t *)buffer</span><br><span class="line">            maxLength:(<span class="built_in">NSUInteger</span>)length</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 比较数据和允许的最大长度 选取比较小的那个</span></span><br><span class="line">    <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>((<span class="built_in">NSUInteger</span>)_phaseReadOffset, MIN([data length] - ((<span class="built_in">NSUInteger</span>)_phaseReadOffset), length));</span><br><span class="line">    <span class="comment">// copy data中range的数据到buffer</span></span><br><span class="line">    [data getBytes:buffer range:range];</span><br><span class="line"></span><br><span class="line">    _phaseReadOffset += range.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="built_in">NSUInteger</span>)_phaseReadOffset) &gt;= [data length]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> transitionToNextPhase];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">NSInteger</span>)range.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)transitionToNextPhase &#123;</span><br><span class="line">    <span class="comment">// 保证主线程执行代码</span></span><br><span class="line">    <span class="keyword">if</span> (![[<span class="built_in">NSThread</span> currentThread] isMainThread]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> transitionToNextPhase];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (_phase) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFEncapsulationBoundaryPhase:</span><br><span class="line">            _phase = AFHeaderPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFHeaderPhase: <span class="comment">// 打开流，准备接收数据</span></span><br><span class="line">            [<span class="keyword">self</span>.inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">            [<span class="keyword">self</span>.inputStream open];</span><br><span class="line">            _phase = AFBodyPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFBodyPhase: <span class="comment">// 关闭流</span></span><br><span class="line">            [<span class="keyword">self</span>.inputStream close];</span><br><span class="line">            _phase = AFFinalBoundaryPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFFinalBoundaryPhase:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            _phase = AFEncapsulationBoundaryPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置offset</span></span><br><span class="line">    _phaseReadOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSCopying</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line"></span><br><span class="line">    bodyPart.stringEncoding = <span class="keyword">self</span>.stringEncoding;</span><br><span class="line">    bodyPart.headers = <span class="keyword">self</span>.headers;</span><br><span class="line">    bodyPart.bodyContentLength = <span class="keyword">self</span>.bodyContentLength;</span><br><span class="line">    bodyPart.body = <span class="keyword">self</span>.body;</span><br><span class="line">    bodyPart.boundary = <span class="keyword">self</span>.boundary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bodyPart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>其实AFHTTPBodyPart就像是一个个具体的数据一样，而AFMultipartBodyStream更像是一个管道，和body相连，数据从body沿着管道流入request中去。</p><p>这层抽象的概念还是蛮重要的。再设计之初，这两个抽象类就应该各自完成各自的任务，即使body中也有stream 但那也只属于body自身的业务。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFHTTPBodyPart就像是一个个具体的数据一样，而AFMultipartBodyStream更像是一个管道</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFMultipartBodyStream</span> : <span class="title">NSInputStream</span> &lt;<span class="title">NSStreamDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">// 读取包的大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> numberOfBytesInPacket;</span><br><span class="line"><span class="comment">// 延时</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> delay;</span><br><span class="line"><span class="comment">// 输入流</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSInputStream</span> *inputStream;</span><br><span class="line"><span class="comment">// 内容大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> contentLength;</span><br><span class="line"><span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isEmpty) <span class="built_in">BOOL</span> empty;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithStringEncoding:(<span class="built_in">NSStringEncoding</span>)encoding;</span><br><span class="line">- (<span class="keyword">void</span>)setInitialAndFinalBoundaries;</span><br><span class="line">- (<span class="keyword">void</span>)appendHTTPBodyPart:(AFHTTPBodyPart *)bodyPart;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它是继承自NSInputStream的，数据最终是通过setHTTPBodySteam方法传递给Request的。是一个NSInputStream类型，因此AFMultipartBodyStream 继承自NSInputStream</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - NSInputStream</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer</span><br><span class="line">        maxLength:(<span class="built_in">NSUInteger</span>)length</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> streamStatus] == <span class="built_in">NSStreamStatusClosed</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInteger</span> totalNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历读取数据</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead &lt; MIN(length, <span class="keyword">self</span>.numberOfBytesInPacket)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前读取的body不存在或者body没有可读字节</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.currentHTTPBodyPart || ![<span class="keyword">self</span>.currentHTTPBodyPart hasBytesAvailable]) &#123;</span><br><span class="line">            <span class="comment">// 把下一个body赋值给当前的body 如果下一个为nil 就退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!(<span class="keyword">self</span>.currentHTTPBodyPart = [<span class="keyword">self</span>.HTTPBodyPartEnumerator nextObject])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前body存在</span></span><br><span class="line">            <span class="comment">// 剩余可读文件的大小</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> maxLength = MIN(length, <span class="keyword">self</span>.numberOfBytesInPacket) - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead;</span><br><span class="line">            <span class="comment">// 把当前的body的数据读入到buffer中</span></span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesRead = [<span class="keyword">self</span>.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength];</span><br><span class="line">            <span class="keyword">if</span> (numberOfBytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.streamError = <span class="keyword">self</span>.currentHTTPBodyPart.inputStream.streamError;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalNumberOfBytesRead += numberOfBytesRead;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.delay &gt; <span class="number">0.0</span>f) &#123;</span><br><span class="line">                    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="keyword">self</span>.delay];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalNumberOfBytesRead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是AFMultipartBodyStream通过body读取数据的核心方法。下面通过举一个例子来看看这个方法究竟是怎么工作的？</p><ol><li>假如我们上传一张图片img.png 他的大小为80000，也就是差不多80k吧。</li><li>通过AFMultipartBodyStream读取数据，会首先调用上边的方法。读取数据并不是一次性读取的，而是分批分次读取的，这这个方法中，每次读取的大小为32k，也就是32*1024 = 32768的大小。</li><li>第一次调用后self.currentHTTPBodyPart 指向我们的img.png 通过NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; 方法在body中读取了32768大小的数据保存到了缓存buffer中。</li><li>由于整个图片大小是80000 一次调用只读取了32768 还有数据没读完，一次这个方法还会再次被调用。</li><li>第二次调用这个方法，由于[self.currentHTTPBodyPart hasBytesAvailable]还有数据，所以还是会走到else的方法中，self.currentHTTPBodyPart并没有指向别的body。因此继续执行 3.的方法。</li><li>至于为什么能接着从上次的已读取的数据开始读数据，这个是body内部封装实现的，可参考本文上边关于body的介绍。</li><li>重复 3 4 5 的步骤，直到没有数据可读时，stream就会关闭流。到此我们的突变数据就以流的形式上传到服务器了。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)multipartFormRequestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                              URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                             parameters:(<span class="built_in">NSDictionary</span> *)parameters</span><br><span class="line">                              constructingBodyWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                                  error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(![method isEqualToString:<span class="string">@"GET"</span>] &amp;&amp; ![method isEqualToString:<span class="string">@"HEAD"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [<span class="keyword">self</span> requestWithMethod:method URLString:URLString parameters:<span class="literal">nil</span> error:error];</span><br><span class="line"></span><br><span class="line">    __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> ([pair.value isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                data = pair.value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([pair.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                data = [<span class="built_in">NSData</span> data];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = [[pair.value description] dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                [formData appendPartWithFormData:data name:[pair.field description]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        block(formData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [formData requestByFinalizingMultipartFormData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setHTTPBodyStream方法  需要设置NSInputStream类型的对象</span></span><br><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestByFinalizingMultipartFormData &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.bodyStream isEmpty]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the initial and final boundaries to ensure correct Content-Length</span></span><br><span class="line">    [<span class="keyword">self</span>.bodyStream setInitialAndFinalBoundaries];</span><br><span class="line">    [<span class="keyword">self</span>.request setHTTPBodyStream:<span class="keyword">self</span>.bodyStream];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, <span class="keyword">self</span>.boundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%llu"</span>, [<span class="keyword">self</span>.bodyStream contentLength]] forHTTPHeaderField:<span class="string">@"Content-Length"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传多个文件的时候回用到这个方法，里面有一个接受AFMultipartFormData协议的对象，AFN没有让AFMultipartBodyStream接受这个协议来处理。而是用另外一个类AFStreamingMultipartFormData来接受这个协议，就是为了把功能和业务代码逻辑分开。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFStreamingMultipartFormData</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableURLRequest</span> *request;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *boundary;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFMultipartBodyStream *bodyStream;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFStreamingMultipartFormData</span> : <span class="title">NSObject</span> &lt;<span class="title">AFMultipartFormData</span>&gt;</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURLRequest:(<span class="built_in">NSMutableURLRequest</span> *)urlRequest</span><br><span class="line">                    stringEncoding:(<span class="built_in">NSStringEncoding</span>)encoding;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestByFinalizingMultipartFormData;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFStreamingMultipartFormData</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURLRequest:(<span class="built_in">NSMutableURLRequest</span> *)urlRequest</span><br><span class="line">                    stringEncoding:(<span class="built_in">NSStringEncoding</span>)encoding</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.request = urlRequest;</span><br><span class="line">    <span class="keyword">self</span>.stringEncoding = encoding;</span><br><span class="line">    <span class="keyword">self</span>.boundary = AFCreateMultipartFormBoundary();</span><br><span class="line">    <span class="keyword">self</span>.bodyStream = [[AFMultipartBodyStream alloc] initWithStringEncoding:encoding];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setRequest:(<span class="built_in">NSMutableURLRequest</span> *)request</span><br><span class="line">&#123;</span><br><span class="line">    _request = [request mutableCopy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)appendPartWithFileURL:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                         name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(fileURL);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *fileName = [fileURL lastPathComponent];</span><br><span class="line">    <span class="built_in">NSString</span> *mimeType = AFContentTypeForPathExtension([fileURL pathExtension]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> appendPartWithFileURL:fileURL name:name fileName:fileName mimeType:mimeType error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)appendPartWithFileURL:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                         name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                     fileName:(<span class="built_in">NSString</span> *)fileName</span><br><span class="line">                     mimeType:(<span class="built_in">NSString</span> *)mimeType</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(fileURL);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(fileName);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(mimeType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (![fileURL isFileURL]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedFailureReasonErrorKey</span>: <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Expected URL to be a file URL"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>)&#125;;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:<span class="built_in">NSURLErrorBadURL</span> userInfo:userInfo];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([fileURL checkResourceIsReachableAndReturnError:error] == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedFailureReasonErrorKey</span>: <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"File URL not reachable."</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>)&#125;;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:<span class="built_in">NSURLErrorBadURL</span> userInfo:userInfo];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *fileAttributes = [[<span class="built_in">NSFileManager</span> defaultManager] attributesOfItemAtPath:[fileURL path] error:error];</span><br><span class="line">    <span class="keyword">if</span> (!fileAttributes) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"form-data; name=\"%@\"; filename=\"%@\""</span>, name, fileName] forKey:<span class="string">@"Content-Disposition"</span>];</span><br><span class="line">    [mutableHeaders setValue:mimeType forKey:<span class="string">@"Content-Type"</span>];</span><br><span class="line"></span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line">    bodyPart.stringEncoding = <span class="keyword">self</span>.stringEncoding;</span><br><span class="line">    bodyPart.headers = mutableHeaders;</span><br><span class="line">    bodyPart.boundary = <span class="keyword">self</span>.boundary;</span><br><span class="line">    bodyPart.body = fileURL;</span><br><span class="line">    bodyPart.bodyContentLength = [fileAttributes[<span class="built_in">NSFileSize</span>] unsignedLongLongValue];</span><br><span class="line">    [<span class="keyword">self</span>.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithInputStream:(<span class="built_in">NSInputStream</span> *)inputStream</span><br><span class="line">                             name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                         fileName:(<span class="built_in">NSString</span> *)fileName</span><br><span class="line">                           length:(int64_t)length</span><br><span class="line">                         mimeType:(<span class="built_in">NSString</span> *)mimeType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(fileName);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(mimeType);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"form-data; name=\"%@\"; filename=\"%@\""</span>, name, fileName] forKey:<span class="string">@"Content-Disposition"</span>];</span><br><span class="line">    [mutableHeaders setValue:mimeType forKey:<span class="string">@"Content-Type"</span>];</span><br><span class="line"></span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line">    bodyPart.stringEncoding = <span class="keyword">self</span>.stringEncoding;</span><br><span class="line">    bodyPart.headers = mutableHeaders;</span><br><span class="line">    bodyPart.boundary = <span class="keyword">self</span>.boundary;</span><br><span class="line">    bodyPart.body = inputStream;</span><br><span class="line"></span><br><span class="line">    bodyPart.bodyContentLength = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)length;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithFileData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                      fileName:(<span class="built_in">NSString</span> *)fileName</span><br><span class="line">                      mimeType:(<span class="built_in">NSString</span> *)mimeType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(fileName);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(mimeType);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"form-data; name=\"%@\"; filename=\"%@\""</span>, name, fileName] forKey:<span class="string">@"Content-Disposition"</span>];</span><br><span class="line">    [mutableHeaders setValue:mimeType forKey:<span class="string">@"Content-Type"</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> appendPartWithHeaders:mutableHeaders body:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithFormData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"form-data; name=\"%@\""</span>, name] forKey:<span class="string">@"Content-Disposition"</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> appendPartWithHeaders:mutableHeaders body:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithHeaders:(<span class="built_in">NSDictionary</span> *)headers</span><br><span class="line">                         body:(<span class="built_in">NSData</span> *)body</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(body);</span><br><span class="line"></span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line">    bodyPart.stringEncoding = <span class="keyword">self</span>.stringEncoding;</span><br><span class="line">    bodyPart.headers = headers;</span><br><span class="line">    bodyPart.boundary = <span class="keyword">self</span>.boundary;</span><br><span class="line">    bodyPart.bodyContentLength = [body length];</span><br><span class="line">    bodyPart.body = body;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)throttleBandwidthWithPacketSize:(<span class="built_in">NSUInteger</span>)numberOfBytes</span><br><span class="line">                                  delay:(<span class="built_in">NSTimeInterval</span>)delay</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.bodyStream.numberOfBytesInPacket = numberOfBytes;</span><br><span class="line">    <span class="keyword">self</span>.bodyStream.delay = delay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestByFinalizingMultipartFormData &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.bodyStream isEmpty]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the initial and final boundaries to ensure correct Content-Length</span></span><br><span class="line">    [<span class="keyword">self</span>.bodyStream setInitialAndFinalBoundaries];</span><br><span class="line">    [<span class="keyword">self</span>.request setHTTPBodyStream:<span class="keyword">self</span>.bodyStream];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, <span class="keyword">self</span>.boundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%llu"</span>, [<span class="keyword">self</span>.bodyStream contentLength]] forHTTPHeaderField:<span class="string">@"Content-Length"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>定义AFStreamingMultipartFormData，接受AFMultipartFormData，实现协议方法，把文件封装成bodyPart对象存储到AFStreamingMultipartFormData对象的属性bodyStream的数组中。通过read maxLength读取数据。</p><h3 id="AFJSONRequestSerializer和AFPropertyListRequestSerializer"><a href="#AFJSONRequestSerializer和AFPropertyListRequestSerializer" class="headerlink" title="AFJSONRequestSerializer和AFPropertyListRequestSerializer"></a>AFJSONRequestSerializer和AFPropertyListRequestSerializer</h3><p>这两个类继承自AFHTTPRequestSerializer。他们的基本实现都是继承自父类。但是也根据自身不同情况，做了处理。<br>对于AFJSONRequestSerializer。需要把Content-Type指定为”application/json。同时HTTPBody<br>需要使用JSON序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(request);</span><br><span class="line">    /*</span><br><span class="line">     对于`GET`,`HEAD`,`DELETE`等方法中。直接使用父类的处理方式</span><br><span class="line">     */</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        return [super requestBySerializingRequest:request withParameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line">    //把`HTTPRequestHeaders`中的值添加进入请求头中。</span><br><span class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</span><br><span class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    if (parameters) &#123;</span><br><span class="line">        //设置请求头的`Content-Type`类型</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (![NSJSONSerialization isValidJSONObject:parameters]) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@&quot;The `parameters` argument is not valid JSON.&quot;, @&quot;AFNetworking&quot;, nil)&#125;;</span><br><span class="line">                *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        //把parameters转换为JSON序列化的data</span><br><span class="line">        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error];</span><br><span class="line">        if (!jsonData) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        //JSON序列化的数据设置为httpbody</span><br><span class="line">        [mutableRequest setHTTPBody:jsonData];</span><br><span class="line">    &#125;</span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于AFPropertyListRequestSerializer也是同样的道理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     对于`GET`,`HEAD`,`DELETE`等方法中。直接使用父类的处理方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> requestBySerializingRequest:request withParameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    <span class="comment">//把`HTTPRequestHeaders`中的值添加进入请求头中。</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="comment">//设置请求头的`Content-Type`类型</span></span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@"application/x-plist"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把parameters转换为Plist序列化的data</span></span><br><span class="line">        <span class="built_in">NSData</span> *plistData = [<span class="built_in">NSPropertyListSerialization</span> dataWithPropertyList:parameters format:<span class="keyword">self</span>.format options:<span class="keyword">self</span>.writeOptions error:error];</span><br><span class="line">        <span class="keyword">if</span> (!plistData) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Plist序列化的数据设置为httpbody</span></span><br><span class="line">        [mutableRequest setHTTPBody:plistData];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFURLRequestSerialization序列化网络请求参数&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="AFNetWorking原理" scheme="https://nixzhang5.github.io/tags/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>App签名原理</title>
    <link href="https://nixzhang5.github.io/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86.html"/>
    <id>https://nixzhang5.github.io/App签名原理.html</id>
    <published>2019-06-26T03:29:11.000Z</published>
    <updated>2019-06-27T03:24:35.971Z</updated>
    
    <content type="html"><![CDATA[<p>App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。</p><a id="more"></a><p>苹果签名需求：</p><ul><li>为了保证系统的安全性，所有iPhone上安装的应用必须是经过苹果授权的</li><li>安装包不需要上传到App Store也能被安装 （开发调试 企业灰度）</li><li>防止证书权限滥用：设备限制、指定APP、iCloud/PUSH/后台运行等附加权限控制</li></ul><h3 id="下载App签名"><a href="#下载App签名" class="headerlink" title="下载App签名"></a>下载App签名</h3><p>签名原理：</p><ol><li>App上传到App Store时，苹果公司拿到App的HASH(MD5,SHA等)值，然后用私钥进行加密(签名)，这时候只有手机上的公钥才可以解密；</li><li>手机下载应用安装App时，先用公钥解密(验证签名)，拿到HASH值，然后将此HASH值，与要安装的App的HASH值进行校验，如果App有被修改过，则校验失败。这样就可以有效的保证每个App都是经过苹果公司官方认证的。</li></ol><h3 id="双层签名"><a href="#双层签名" class="headerlink" title="双层签名"></a>双层签名</h3><p>真机调试，企业包上面的签名方式就不适合了。这时候需要双层签名：</p><ol><li>在Mac系统中生成一对非对称加密算法的公私钥M（keychain 里的 <code>从证书颁发机构请求证书</code>，保存的CertificateSigningRequest就包含公钥M，私钥保存在本地）。</li><li>苹果自己有固定的一对公私钥：私钥A在苹果后台，公钥A在每个iOS系统的手机中。</li><li>申请证书，把CertificateSigningRequest.certSigningRequest文件（包含公钥M，以及一些开发者信息）发送给苹果后台，用苹果后台的私钥A对公钥M签名，得到一份包含公钥M以及其签名结果的数据就是证书。<ul><li>生成的证书下载下来，keychain会把这两个证书关联起来，因为公私钥是对应的。这个私钥只有这台电脑有，团队开发需要把这个私钥导出.p12给其他Mac.</li></ul></li><li>配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件（包含设备IDs,AppID,Entitlements(权力文件包含是否可调试，推送，后台运行等信息)）。</li><li>XCode 会通过第3步下载回来的证书（存着公钥），在本地找到对应的私钥（第1步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。<ul><li>打包过程用私钥M对App的HASH值进行加密(签名)，这时的APP内部实际包含了APP的签名(私钥M加密App的HASH值)、第3步生成的证书文件(包含公钥M和公钥M的HASH值)、Provision Profile(描述文件)，App可执行文件以及其他信息</li></ul></li><li>解密：<ol><li>iPhone手机拿到证书文件(包含公钥M和公钥M的HASH值)，因为手机里有公钥A，所以能解密证书文件，得到公钥M和公钥M的HASH值，先验证公钥M生成的HASH值(MD5,SHA等)是不是和证书文件里的公钥M的HASH值一致，确保证书没有被修改；</li><li>验证一致后，就可以用公钥M来解密第2步的APP的签名，同样道理可以验证App是否被修改过。 因为在开发阶段App会经常修改，所以App就算是修改过，也能安装。第4步主要是验证证书是不是苹果认证的，只要证书对就可以安装运行。</li></ol></li></ol><p>加密解密：</p><ul><li>mac电脑：私钥M和公钥M(电脑生成)</li><li>苹果服务器：私钥A</li><li>iPhone手机：公钥A</li></ul><p>.ipa包含的信息：</p><ol><li>资源文件，例如图片、html、等等。</li><li>_CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。</li><li>可执行文件。此文件跟资源文件一样需要签名。</li><li>一个mobileprovision文件.打包的时候使用的，从MC上生成的。</li><li>Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件。</li></ol><h3 id="签名原理图："><a href="#签名原理图：" class="headerlink" title="签名原理图："></a>签名原理图：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//nixzhang5.github.io/sign.png" alt="签名原理图" title>                </div>                <div class="image-caption">签名原理图</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="Encryption" scheme="https://nixzhang5.github.io/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>加密</title>
    <link href="https://nixzhang5.github.io/%E5%8A%A0%E5%AF%86.html"/>
    <id>https://nixzhang5.github.io/加密.html</id>
    <published>2019-06-26T02:27:44.000Z</published>
    <updated>2019-06-26T03:25:10.730Z</updated>
    
    <content type="html"><![CDATA[<p>加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。</p><a id="more"></a><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。</p><ul><li>优点<br>简单快捷，密钥较短，且破译困难。</li><li>缺点<br>如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通的两个用户之间怎么确定密钥也需要考虑，这其中就会有密钥泄露的风险，以及存在更换密钥的需求。</li></ul><p>对称加密通常有 AES, DES, IDEA, 3DES 加密算法。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。</p><ul><li>缺点<br>加解密比对称加密耗时.</li><li>优点<br>比对称加密安全.</li></ul><p>但是非对称加密也是存在漏洞，因为公钥是公开的，如果有 C 冒充 B 的身份利用 A 的公钥给 A 发消息，这样就乱套了，所以接下来就采用<code>非对称加密+摘要算法+数字签名的机制</code>来确保传输安全。</p><p>常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h3 id="Hash算法（摘要算法）"><a href="#Hash算法（摘要算法）" class="headerlink" title="Hash算法（摘要算法）"></a>Hash算法（摘要算法）</h3><p>Hash算法的特点是单向不可还原，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。只要源数据不同，算法得到的摘要必定不同。</p><p>常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。</p><p>数字签名是 A将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要一起发送给B；B接收到后解密，得到这个摘要 a 和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要 b，比较 a 与 b 就可得知在传输过程中是否被更改过。</p><p>因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。</p><h3 id="完整的非对称加密过程"><a href="#完整的非对称加密过程" class="headerlink" title="完整的非对称加密过程"></a>完整的非对称加密过程</h3><p>假如现在 你向支付宝 转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为：</p><ol><li>首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息，</li><li>你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等；</li><li>你 对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）；</li><li>你 用自己的私钥对信息摘要进行加密得到 你 的数字签名，并将其附在数字信息上；</li><li>你 随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）；</li><li>你用 支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝；</li><li>支付宝收到 你 传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到 你随机产生的加密密钥；</li><li>支付宝 然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃；</li><li>支付宝 用你 的公钥对 你的的数字签名进行解密，得到信息摘要；</li><li>支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要；</li><li>支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。</li><li>确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。在这后面的流程就不属于本次非对称加密的范畴，算支付宝个人的自我流程，也就是循环以上过程。</li></ol><h3 id="iOS常用的加密方式"><a href="#iOS常用的加密方式" class="headerlink" title="iOS常用的加密方式"></a>iOS常用的加密方式</h3><p>Base64加密、MD5加密、AES加密、RSA加密</p><h4 id="Base64加密"><a href="#Base64加密" class="headerlink" title="Base64加密"></a>Base64加密</h4><p>Base64编码的思想是：采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组，以3个字节为一组，按顺序排列24位数据，再把这24位数据分成4组，即每组6位；再在每组的的最高位前补两个0凑足一个字节，这样就把一个3字节为一组的数据重新编码成了4个字节；当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节，这时在最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。例如：将对ABC进行Base64编码首先取ABC对应的ASCII码值，A : 65、B : 66、C : 67，再取二进制值A : 01000001、B : 01000010、C : 01000011，然后把这三个字节的二进制码接起来010000010100001001000011，再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值00010000、00010100、00001001、00000011；再把这4个字节数据转化成10进制数得16、20、19、3；最后根据Base64给出的64个基本字符表，查出对应的ASCII码字符Q、U、J、D，这里的值实际就是数据在字符表中的索引。解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。注：Base64字符表，包括大写A-Z小写a-z数字0-9和+以及/。<br>Base64加密原则：6bit（原8bit）一个字节，不足的位数用0补齐，两个0用一个=表示。<br>Base64加密特点：</p><ul><li>数据加密之后，数据量会变大，变大1/3左右。</li><li>可进行反向解密。</li><li>编码后有个非常显著的特点，末尾有个=号。</li></ul><p>其实Base64不算是加密，只是一种编码格式。</p><p>在iOS中Base64加解密使用方法介绍（本例使用系统API，仅支持iOS7及以后的系统版本）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************Base64.m类实现文件内容****************************/</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)base64EncodedStringWithData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否传入需要加密数据参数</span></span><br><span class="line">    <span class="keyword">if</span> ((data == <span class="literal">nil</span>) || (data == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![data isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断设备系统是否满足条件</span></span><br><span class="line">    <span class="keyword">if</span> ([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] doubleValue] &lt;= <span class="number">6.9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用系统的API进行Base64加密操作</span></span><br><span class="line">    <span class="built_in">NSDataBase64EncodingOptions</span> options;</span><br><span class="line">    options = <span class="built_in">NSDataBase64EncodingEndLineWithLineFeed</span>;</span><br><span class="line">    <span class="keyword">return</span> [data base64EncodedStringWithOptions:options];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)base64DecodeDataWithString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否传入需要加密数据参数</span></span><br><span class="line">    <span class="keyword">if</span> ((string == <span class="literal">nil</span>) || (string == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![string isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断设备系统是否满足条件</span></span><br><span class="line">    <span class="keyword">if</span> ([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] doubleValue] &lt;= <span class="number">6.9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用系统的API进行Base64解密操作</span></span><br><span class="line">    <span class="built_in">NSDataBase64DecodingOptions</span> options;</span><br><span class="line">    options = <span class="built_in">NSDataBase64DecodingIgnoreUnknownCharacters</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSData</span> alloc] initWithBase64EncodedString:string options:options];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Base64文件进行Base64加密和解密</span></span><br><span class="line"><span class="comment">/*********************************使用Base64类*********************************/</span></span><br><span class="line"><span class="comment">//使用Base64执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSString</span> *encodeString = [Base64 base64EncodedStringWithData:data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeString : %@"</span>, encodeString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Base64执行解密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *decodeString = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSData</span> *decodeData = [Base64 base64DecodeDataWithString:encodeString];</span><br><span class="line">decodeString = [[<span class="built_in">NSString</span> alloc] initWithData:decodeData</span><br><span class="line">                                     encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"decodeString : %@"</span>, decodeString);</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br></pre></td></tr></table></figure><h4 id="MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）"><a href="#MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）" class="headerlink" title="MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）"></a>MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）</h4><p>MD5的全称是Message-DigestAlgorithm 5，Message-Digest泛指字节串(Message)的Hash变换，就是把一个任意长度的字节串变换成一定长的大整数。请注意我使用了字节串而不是字符串这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的字节串变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被”篡改”。举个例子，你将一段话写在一个叫readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的”抵赖”，这就是所谓的数字签名应用。MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的，用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并”不知道”用户的密码是什么。MD5加密大体都应用在：验证数据或文件一致性、数字签名、安全访问认证等等。大概可比喻为：人的指纹来理解。<br>注：MD5加密是不可逆的，也就是说，MD5加密后是不能解密的，所谓的解密只是用大数据的”试用”，来测出结果的。<br>MD5特点:</p><ul><li>压缩性 : 任意长度的数据,算出的MD5值长度都是固定的。</li><li>容易计算 : 从原数据计算出MD5值很容易。</li><li>抗修改性 : 对原数据进行任何改动，哪怕只修改一个字节，所得到的MD5值都有很大区别。</li><li>弱抗碰撞 : 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li><li>强抗碰撞 : 想找到两个不同数据，使他们具有相同的MD5值，是非常困难的。</li></ul><p>在iOS中MD5加密和验签使用方法介绍</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************MD5.m类实现文件内容****************************/</span></span><br><span class="line"><span class="comment">//对字符串数据进行MD5的签名</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)md5SignWithString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *object = [string UTF8String];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> result[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(object,(CC_LONG)strlen(object),result);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *hash = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">        [hash appendFormat:<span class="string">@"%02X"</span>, result[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [hash lowercaseString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对二进制数据进行MD5的签名</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)md5SignWithData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    Byte byte[CC_MD5_DIGEST_LENGTH];    <span class="comment">//定义一个字节数组来接收结果</span></span><br><span class="line">    CC_MD5((<span class="keyword">const</span> <span class="keyword">void</span>*)([data bytes]), (CC_LONG)[data length], byte);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:byte length:CC_MD5_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用MD5文件进行MD5加密和验签</span></span><br><span class="line"><span class="comment">/*********************************使用MD5类*********************************/</span></span><br><span class="line"><span class="comment">//使用MD5执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *string2 = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *encodeString2 = [MD5 md5SignWithString:string2];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeString2 : %@"</span>, encodeString2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//MD5为不可逆的操作，使用MD5执行验签操作</span></span><br><span class="line"><span class="built_in">NSString</span> *verifyString2 = [MD5 md5SignWithString:string2];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"verifyString2 : %@"</span>, verifyString2);</span><br><span class="line"><span class="keyword">if</span> ([verifyString2 isEqualToString:encodeString2]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"md5 verify sign success"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"md5 verify sign failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br></pre></td></tr></table></figure><h4 id="AES加密（对称加密的一种）"><a href="#AES加密（对称加密的一种）" class="headerlink" title="AES加密（对称加密的一种）"></a>AES加密（对称加密的一种）</h4><p>高级加密标准Advanced Encryption Standard简称：AES，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。它是一种对称加密算法，这个标准也替代原先的DES标准，已经被多方分析且广为全世界所使用。AES设计有三个密钥长度:128、192、256位，相对而言，AES的128密钥比DES的56密钥强1021倍。AES算法主要包括三个方面：轮变化、圈数和密钥扩展。总体来说，AES作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活，在软件及硬件上都能快速地加解密且只需要很少的存储资源等优点。</p><p>AES加解密特点：</p><ul><li>AES强安全性、高性能、高效率、易用和灵活。</li><li>在软件及硬件上都能快速地加解密且只需要很少的存储资源。</li></ul><p>AES加密需要的参数：</p><ul><li><strong>密钥长度（Key Size）</strong><br>AES算法下，key的长度有三种：128、192和256 bits。由于历史原因，JDK默认只支持不大于128 bits的密钥，而128 bits的key已能够满足商用安全需求。因此本例先使用AES-128。（Java使用大于128 bits的key方法在文末提及）</li><li><strong>加密模式（Cipher Mode）</strong><br>AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。本例统一使用CBC模式。</li><li><strong>填充方式（Padding）</strong><br>由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）<br>在iOS SDK中提供了PKCS7Padding，而JDK则提供了PKCS5Padding。原则上PKCS5Padding限制了填充的Block Size为8 bytes，而Java实际上当块大于该值时，其PKCS5Padding与PKCS7Padding是相等的：每需要填充χ个字节，填充的值就是χ。</li><li><strong>初始向量（Initialization Vector）</strong><br>使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等（AES的Block Size为128 bits），而两个平台的API文档均指明当不传入初始向量时，系统将默认使用一个全0的初始向量。<br>有了上述的基础之后，可以开始分别在两个平台进行实现了。</li></ul><p>在iOS中AES加解密的实现介绍</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要导入：#import &lt;CommonCrypto/CommonCrypto.h&gt;库才能使用</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  AES128 + ECB + PKCS7</span></span><br><span class="line"><span class="comment"> *  @param data 要加密的原始数据</span></span><br><span class="line"><span class="comment"> *  @param key  加密 key</span></span><br><span class="line"><span class="comment"> *  @return  加密后数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)encryptData:(<span class="built_in">NSData</span> *)data key:(<span class="built_in">NSData</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断解密的流数据是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((data == <span class="literal">nil</span>) || (data == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![data isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([data length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断解密的Key是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((key == <span class="literal">nil</span>) || (key == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![key isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([key length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup key</span></span><br><span class="line">    <span class="built_in">NSData</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> cKey[kCCKeySizeAES128];</span><br><span class="line">    bzero(cKey, <span class="keyword">sizeof</span>(cKey));</span><br><span class="line">    [key getBytes:cKey length:kCCKeySizeAES128];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup output buffer</span></span><br><span class="line">    size_t bufferSize = [data length] + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do encrypt</span></span><br><span class="line">    size_t encryptedSize = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES128,</span><br><span class="line">                                          kCCOptionECBMode|kCCOptionPKCS7Padding,</span><br><span class="line">                                          cKey,</span><br><span class="line">                                          kCCKeySizeAES128,</span><br><span class="line">                                          <span class="literal">nil</span>,</span><br><span class="line">                                          [data bytes],</span><br><span class="line">                                          [data length],</span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize,</span><br><span class="line">                                          &amp;encryptedSize);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        result = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:encryptedSize];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  AES128 + ECB + PKCS7</span></span><br><span class="line"><span class="comment"> *  @param data 要解密的原始数据</span></span><br><span class="line"><span class="comment"> *  @param key  解密 key</span></span><br><span class="line"><span class="comment"> *  @return  解密后数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)decryptData:(<span class="built_in">NSData</span> *)data key:(<span class="built_in">NSData</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断解密的流数据是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((data == <span class="literal">nil</span>) || (data == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![data isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([data length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断解密的Key是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((key == <span class="literal">nil</span>) || (key == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![key isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([key length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup key</span></span><br><span class="line">    <span class="built_in">NSData</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> cKey[kCCKeySizeAES128];</span><br><span class="line">    bzero(cKey, <span class="keyword">sizeof</span>(cKey));</span><br><span class="line">    [key getBytes:cKey length:kCCKeySizeAES128];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup output buffer</span></span><br><span class="line">    size_t bufferSize = [data length] + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do decrypt</span></span><br><span class="line">    size_t decryptedSize = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES128,</span><br><span class="line">                                          kCCOptionECBMode|kCCOptionPKCS7Padding,</span><br><span class="line">                                          cKey,</span><br><span class="line">                                          kCCKeySizeAES128,</span><br><span class="line">                                          <span class="literal">nil</span>,</span><br><span class="line">                                          [data bytes],</span><br><span class="line">                                          [data length],</span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize,</span><br><span class="line">                                          &amp;decryptedSize);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        result = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:decryptedSize];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在iOS中AES加解密使用方法介绍</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用AES执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *aesKey = <span class="string">@"a1b2c3d4e5f6g7h8"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string3 = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *keyData3 = [aesKey dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *sourceData3 = [string3 dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *encodeData3 = [AESEncrypt encryptData:sourceData3 key:keyData3];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeData3 : %@"</span>, encodeData3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用AES执行解密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *decodeString3 = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSData</span> *decodeData3 = [AESEncrypt decryptData:encodeData3</span><br><span class="line">                                          key:keyData3];</span><br><span class="line">decodeString3 = [[<span class="built_in">NSString</span> alloc] initWithData:decodeData3</span><br><span class="line">                                      encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"decodeString3 : %@"</span>, decodeString3);</span><br></pre></td></tr></table></figure><h4 id="RSA加密（非对称加密的一种）"><a href="#RSA加密（非对称加密的一种）" class="headerlink" title="RSA加密（非对称加密的一种）"></a>RSA加密（非对称加密的一种）</h4><p>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要，对方收到信息后，用不同的密钥解密并可核对信息摘要。RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作，RSA是被研究得最广泛的公钥算法。RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。RSA加密大体都应用在：本地数据加密、网络传输数据加密、方法体和方法名高级混淆以及程序结构混排加密。例如：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取。</p><p>RSA的算法涉及三个参数，n、e1、e2。其中，n是两个大质数p、q的积，n的二进制表示时所占用的位数，就是所谓的密钥长度。e1和e2是一对相关的值，e1可以任意取，但要求e1与(p-1)(q-1)互质；再选择e2，要求(e2e1)mod((p-1)*(q-1))=1。(n，e1)，(n，e2)就是密钥对。其中(n，e1)为公钥，(n，e2)为私钥；RSA加解密的算法完全相同，公钥加密体制中，一般用公钥加密，私钥解密。假设A为明文，B为密文，则：A=B^e2 mod n；B=A^e1 mod n；e1和e2可以互换使用，即私钥加密，公钥解密，公式：A=B^e1 mod n；B=A^e2 mod n;</p><p>RSA加解密特点：</p><ul><li>RSA密钥管理的方便，计算量很大速度相对比较慢。</li><li>RSA安全性很高，能够抵抗到目前为止已知的绝大多数密码攻击。<br>在线生成RSA密钥对的网址：在线生成非对称加密公钥私钥对等，RSA密钥格式请使用PKCS#8格式。PKCS#1与PKCS#8的区别还待后续查阅资料，再进行补充记录。</li></ul><p>在iOS中RSA加解密的实现介绍（支持密钥文件&lt;.pem&gt;和字符串密钥）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************RSAEncrypt.m类实现文件内容****************************/</span></span><br><span class="line"><span class="meta">#pragma mark - Class Utils Method</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isEmptyKeyRef:(<span class="keyword">id</span>)object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object == [<span class="built_in">NSNull</span> null]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private Method</span></span><br><span class="line">+ (SecKeyRef)getPrivateKeyRefWithFilePath:(<span class="built_in">NSString</span> *)filePath keyPassword:(<span class="built_in">NSString</span> *)keyPassword</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取私钥证书文件的内容</span></span><br><span class="line">    <span class="built_in">NSData</span> *certificateData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">    <span class="keyword">if</span> ((certificateData == <span class="literal">nil</span>) || (certificateData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![certificateData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([certificateData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拼接密码参数到字典中</span></span><br><span class="line">    <span class="built_in">NSString</span> *passwordKey = (__bridge <span class="keyword">id</span>)kSecImportExportPassphrase;</span><br><span class="line">    <span class="built_in">NSString</span> *passwordValue = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,keyPassword];</span><br><span class="line">    <span class="keyword">if</span> ((keyPassword == <span class="literal">nil</span>) || (keyPassword == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        passwordValue = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![keyPassword isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        passwordValue = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPassword length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        passwordValue = <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *optionInfo = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [optionInfo setObject:passwordValue forKey:passwordKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取私钥对象</span></span><br><span class="line">    SecKeyRef privateKeyRef = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFArrayRef</span> items = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CFDataRef</span> pkcs12Data = (__bridge <span class="built_in">CFDataRef</span>)certificateData;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> options = (__bridge <span class="built_in">CFDictionaryRef</span>)optionInfo;</span><br><span class="line">    OSStatus securityStatus = SecPKCS12Import(pkcs12Data, options, &amp;items);</span><br><span class="line">    <span class="keyword">if</span> (securityStatus == noErr &amp;&amp; <span class="built_in">CFArrayGetCount</span>(items) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SecIdentityRef identity;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *secpkey = kSecImportItemIdentity;</span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> identityDict = <span class="built_in">CFArrayGetValueAtIndex</span>(items, <span class="number">0</span>);</span><br><span class="line">        identity = (SecIdentityRef)<span class="built_in">CFDictionaryGetValue</span>(identityDict,secpkey);</span><br><span class="line">        securityStatus = SecIdentityCopyPrivateKey(identity, &amp;privateKeyRef);</span><br><span class="line">        <span class="keyword">if</span> (securityStatus != noErr)</span><br><span class="line">        &#123;</span><br><span class="line">            privateKeyRef = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(items);</span><br><span class="line">    <span class="keyword">return</span> privateKeyRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SecKeyRef)privateKeyRefWithPrivateKey:(<span class="built_in">NSString</span> *)privateKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((privateKey == <span class="literal">nil</span>) || (privateKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析私钥对象内容</span></span><br><span class="line">    <span class="built_in">NSString</span> *pKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,privateKey];</span><br><span class="line">    <span class="built_in">NSRange</span> sposition = [pKey rangeOfString:<span class="string">@"-----BEGIN RSA PRIVATE KEY-----"</span>];</span><br><span class="line">    <span class="built_in">NSRange</span> eposition = [pKey rangeOfString:<span class="string">@"-----END RSA PRIVATE KEY-----"</span>];</span><br><span class="line">    <span class="keyword">if</span> (sposition.location != <span class="built_in">NSNotFound</span> &amp;&amp; eposition.location != <span class="built_in">NSNotFound</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> endposition = eposition.location;</span><br><span class="line">        <span class="built_in">NSUInteger</span> startposition = sposition.location + sposition.length;</span><br><span class="line">        <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(startposition, endposition-startposition);</span><br><span class="line">        pKey = [pKey substringWithRange:range];</span><br><span class="line">    &#125;</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\r"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\n"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\t"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@" "</span>  withString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//This will be base64 encoded, decode it.</span></span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [Base64 base64DecodeDataWithString:pKey];</span><br><span class="line">    keyData = [<span class="keyword">self</span> stripPrivateKeyHeader:keyData];</span><br><span class="line">    <span class="keyword">if</span> ((keyData == <span class="literal">nil</span>) || (keyData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![keyData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a tag to read/write keychain storage</span></span><br><span class="line">    <span class="built_in">NSString</span> *tag = <span class="string">@"RSAUtil_PrivKey"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *bytes = [tag UTF8String];</span><br><span class="line">    <span class="built_in">NSData</span> *tagData = [<span class="built_in">NSData</span> dataWithBytes:bytes length:[tag length]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Delete any old lingering key with the same tag</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attributes = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecClassKey</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecClass];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    [attributes setObject:tagData</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrApplicationTag];</span><br><span class="line">    SecItemDelete((__bridge <span class="built_in">CFDictionaryRef</span>)attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add persistent version of the key to system keychain</span></span><br><span class="line">    [attributes setObject:keyData forKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyClassPrivate</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyClass];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    </span><br><span class="line">    OSStatus status = noErr;</span><br><span class="line">    <span class="built_in">CFTypeRef</span> persistKey = <span class="literal">nil</span>;</span><br><span class="line">    status = SecItemAdd((__bridge <span class="built_in">CFDictionaryRef</span>)attributes, &amp;persistKey);</span><br><span class="line">    <span class="keyword">if</span> (persistKey != <span class="literal">nil</span>) &#123;<span class="built_in">CFRelease</span>(persistKey);&#125;</span><br><span class="line">    <span class="keyword">if</span> ((status != noErr) &amp;&amp; (status != errSecDuplicateItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnRef];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now fetch the SecKeyRef version of the key</span></span><br><span class="line">    SecKeyRef keyRef = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> query = (__bridge <span class="built_in">CFDictionaryRef</span>)attributes;</span><br><span class="line">    status = SecItemCopyMatching(query, (<span class="built_in">CFTypeRef</span> *)&amp;keyRef);</span><br><span class="line">    <span class="keyword">if</span> (status != noErr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)stripPrivateKeyHeader:(<span class="built_in">NSData</span> *)d_key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Skip ASN.1 private key header</span></span><br><span class="line">    <span class="keyword">if</span> (d_key == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = [d_key length];</span><br><span class="line">    <span class="keyword">if</span> (!len) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *c_key = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)[d_key bytes];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = <span class="number">22</span>; <span class="comment">//magic byte at offset 22</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x04</span> != c_key[idx++]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//calculate length of the key</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> c_len = c_key[idx++];</span><br><span class="line">    <span class="keyword">if</span> (!(c_len &amp; <span class="number">0x80</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        c_len = c_len &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> byteCount = c_len &amp; <span class="number">0x7f</span>;</span><br><span class="line">        <span class="keyword">if</span> (byteCount + idx &gt; len) &#123;</span><br><span class="line">            <span class="comment">//rsa length field longer than buffer</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> accum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = &amp;c_key[idx];</span><br><span class="line">        idx += byteCount;</span><br><span class="line">        <span class="keyword">while</span> (byteCount) &#123;</span><br><span class="line">            accum = (accum &lt;&lt; <span class="number">8</span>) + *ptr;</span><br><span class="line">            ptr++;</span><br><span class="line">            byteCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        c_len = accum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now make a new NSData from this buffer</span></span><br><span class="line">    <span class="keyword">return</span> [d_key subdataWithRange:<span class="built_in">NSMakeRange</span>(idx, c_len)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SecKeyRef)getPublicKeyRefWithFilePath:(<span class="built_in">NSString</span> *)filePath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取公钥证书文件的内容</span></span><br><span class="line">    <span class="built_in">NSData</span> *certificateData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">    <span class="keyword">if</span> ((certificateData == <span class="literal">nil</span>) || (certificateData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![certificateData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([certificateData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将公钥证书制作成证书对象</span></span><br><span class="line">    <span class="built_in">CFDataRef</span> data = (__bridge <span class="built_in">CFDataRef</span>)certificateData;</span><br><span class="line">    SecCertificateRef certificateRef = SecCertificateCreateWithData(<span class="literal">NULL</span>, data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取公钥对象</span></span><br><span class="line">    SecTrustRef trust = <span class="literal">NULL</span>;</span><br><span class="line">    SecKeyRef publicKey = <span class="literal">NULL</span>;</span><br><span class="line">    SecPolicyRef policies = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="keyword">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(certificateRef)]</span><br><span class="line">        &amp;&amp; ![[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(policies)])</span><br><span class="line">    &#123;</span><br><span class="line">        OSStatus status;</span><br><span class="line">        status = SecTrustCreateWithCertificates((<span class="built_in">CFTypeRef</span>)certificateRef,</span><br><span class="line">                                                policies, &amp;trust);</span><br><span class="line">        <span class="keyword">if</span> (status == noErr)</span><br><span class="line">        &#123;</span><br><span class="line">            SecTrustResultType result;</span><br><span class="line">            <span class="keyword">if</span> (SecTrustEvaluate(trust, &amp;result) == noErr)</span><br><span class="line">            &#123;</span><br><span class="line">                publicKey = SecTrustCopyPublicKey(trust);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (certificateRef != <span class="literal">NULL</span>) <span class="built_in">CFRelease</span>(certificateRef);</span><br><span class="line">    <span class="keyword">if</span> (policies != <span class="literal">NULL</span>) <span class="built_in">CFRelease</span>(policies);</span><br><span class="line">    <span class="keyword">if</span> (trust != <span class="literal">NULL</span>) <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">    <span class="keyword">return</span> publicKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SecKeyRef)publicKeyRefWithPublicKey:(<span class="built_in">NSString</span> *)publicKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKey == <span class="literal">nil</span>) || (publicKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析公钥对象内容</span></span><br><span class="line">    <span class="built_in">NSString</span> *pKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,publicKey];</span><br><span class="line">    <span class="built_in">NSRange</span> sposition = [pKey rangeOfString:<span class="string">@"-----BEGIN PUBLIC KEY-----"</span>];</span><br><span class="line">    <span class="built_in">NSRange</span> eposition = [pKey rangeOfString:<span class="string">@"-----END PUBLIC KEY-----"</span>];</span><br><span class="line">    <span class="keyword">if</span> (sposition.location != <span class="built_in">NSNotFound</span> &amp;&amp; eposition.location != <span class="built_in">NSNotFound</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> startposition = eposition.location;</span><br><span class="line">        <span class="built_in">NSUInteger</span> endposition = sposition.location + sposition.length;</span><br><span class="line">        <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(endposition, startposition-endposition);</span><br><span class="line">        pKey = [pKey substringWithRange:range];</span><br><span class="line">    &#125;</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\r"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\n"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\t"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@" "</span>  withString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//This will be base64 encoded, decode it.</span></span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [[<span class="keyword">self</span> <span class="keyword">class</span>] base64DecodeDataWithString:pKey];</span><br><span class="line">    keyData = [<span class="keyword">self</span> stripPublicKeyHeader:keyData];</span><br><span class="line">    <span class="keyword">if</span> ((keyData == <span class="literal">nil</span>) || (keyData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![keyData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a tag to read/write keychain storage</span></span><br><span class="line">    <span class="built_in">NSString</span> *tag = <span class="string">@"RSAUtil_PubKey"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *bytes = [tag UTF8String];</span><br><span class="line">    <span class="built_in">NSData</span> *tagData = [<span class="built_in">NSData</span> dataWithBytes:bytes length:[tag length]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Delete any old lingering key with the same tag</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attributes = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecClassKey</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecClass];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    [attributes setObject:tagData</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrApplicationTag];</span><br><span class="line">    SecItemDelete((__bridge <span class="built_in">CFDictionaryRef</span>)attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add persistent version of the key to system keychain</span></span><br><span class="line">    [attributes setObject:keyData</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyClassPublic</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyClass];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    </span><br><span class="line">    OSStatus status = noErr;</span><br><span class="line">    <span class="built_in">CFTypeRef</span> persistKey = <span class="literal">nil</span>;</span><br><span class="line">    status = SecItemAdd((__bridge <span class="built_in">CFDictionaryRef</span>)attributes, &amp;persistKey);</span><br><span class="line">    <span class="keyword">if</span> (persistKey != <span class="literal">nil</span>) <span class="built_in">CFRelease</span>(persistKey);</span><br><span class="line">    <span class="keyword">if</span> ((status != noErr) &amp;&amp; (status != errSecDuplicateItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnRef];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now fetch the SecKeyRef version of the key</span></span><br><span class="line">    SecKeyRef publicKeyRef = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> query = (__bridge <span class="built_in">CFDictionaryRef</span>)attributes;</span><br><span class="line">    status = SecItemCopyMatching(query, (<span class="built_in">CFTypeRef</span> *)&amp;publicKeyRef);</span><br><span class="line">    <span class="keyword">if</span> (status != noErr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> publicKeyRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)stripPublicKeyHeader:(<span class="built_in">NSData</span> *)d_key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Skip ASN.1 public key header</span></span><br><span class="line">    <span class="keyword">if</span> (d_key == <span class="literal">nil</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = [d_key length];</span><br><span class="line">    <span class="keyword">if</span> (!len) <span class="keyword">return</span>(<span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *c_key = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)[d_key bytes];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx++] != <span class="number">0x30</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx] &gt; <span class="number">0x80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx += c_key[idx] - <span class="number">0x80</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PKCS #1 rsaEncryption szOID_RSA_RSA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> seqiod[] = &#123;<span class="number">0x30</span>, <span class="number">0x0d</span>, <span class="number">0x06</span>, <span class="number">0x09</span>, <span class="number">0x2a</span>,</span><br><span class="line">        <span class="number">0x86</span>, <span class="number">0x48</span>, <span class="number">0x86</span>, <span class="number">0xf7</span>, <span class="number">0x0d</span>,</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x05</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (memcmp(&amp;c_key[idx], seqiod, <span class="number">15</span>)) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    idx += <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx++] != <span class="number">0x03</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx] &gt; <span class="number">0x80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx += c_key[idx] - <span class="number">0x80</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx++] != <span class="string">'\0'</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now make a new NSData from this buffer</span></span><br><span class="line">    <span class="keyword">return</span> ([<span class="built_in">NSData</span> dataWithBytes:&amp;c_key[idx] length:len - idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)encryptData:(<span class="built_in">NSData</span> *)data withKeyRef:(SecKeyRef)keyRef</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> uint8_t *srcbuf = (<span class="keyword">const</span> uint8_t *)[data bytes];</span><br><span class="line">    size_t srclen = (size_t)data.length;</span><br><span class="line">    </span><br><span class="line">    size_t block_size = SecKeyGetBlockSize(keyRef) * <span class="keyword">sizeof</span>(uint8_t);</span><br><span class="line">    <span class="keyword">void</span> *outbuf = malloc(block_size);</span><br><span class="line">    size_t src_block_size = block_size - <span class="number">11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *ret = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; srclen; idx += src_block_size)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t data_len = srclen - idx;</span><br><span class="line">        <span class="keyword">if</span>(data_len &gt; src_block_size)&#123;</span><br><span class="line">            data_len = src_block_size;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size_t outlen = block_size;</span><br><span class="line">        OSStatus status = noErr;</span><br><span class="line">        status = SecKeyEncrypt(keyRef, kSecPaddingPKCS1,</span><br><span class="line">                               srcbuf + idx, data_len,</span><br><span class="line">                               outbuf, &amp;outlen);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"SecKeyEncrypt fail. Error Code: %d"</span>, (<span class="keyword">int</span>)status);</span><br><span class="line">            ret = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            [ret appendBytes:outbuf length:outlen];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(outbuf);</span><br><span class="line">    <span class="built_in">CFRelease</span>(keyRef);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)decryptData:(<span class="built_in">NSData</span> *)data withKeyRef:(SecKeyRef)keyRef</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> uint8_t *srcbuf = (<span class="keyword">const</span> uint8_t *)[data bytes];</span><br><span class="line">    size_t srclen = (size_t)data.length;</span><br><span class="line">    </span><br><span class="line">    size_t block_size = SecKeyGetBlockSize(keyRef) * <span class="keyword">sizeof</span>(uint8_t);</span><br><span class="line">    <span class="built_in">UInt8</span> *outbuf = malloc(block_size);</span><br><span class="line">    size_t src_block_size = block_size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *ret = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; srclen; idx += src_block_size)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t data_len = srclen - idx;</span><br><span class="line">        <span class="keyword">if</span>(data_len &gt; src_block_size)</span><br><span class="line">        &#123;</span><br><span class="line">            data_len = src_block_size;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size_t outlen = block_size;</span><br><span class="line">        OSStatus status = noErr;</span><br><span class="line">        status = SecKeyDecrypt(keyRef, kSecPaddingNone,</span><br><span class="line">                               srcbuf + idx, data_len,</span><br><span class="line">                               outbuf, &amp;outlen);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"SecKeyEncrypt fail. Error Code: %d"</span>, (<span class="keyword">int</span>)status);</span><br><span class="line">            ret = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> idxFirstZero = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> idxNextZero = (<span class="keyword">int</span>)outlen;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outlen; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (outbuf[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (idxFirstZero &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        idxFirstZero = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        idxNextZero = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSUInteger</span> length = idxNextZero-idxFirstZero<span class="number">-1</span>;</span><br><span class="line">            [ret appendBytes:&amp;outbuf[idxFirstZero+<span class="number">1</span>] length:length];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(outbuf);</span><br><span class="line">    <span class="built_in">CFRelease</span>(keyRef);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - RSA Key File Encrypt/Decrypt Public Method</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)encryptString:(<span class="built_in">NSString</span> *)originString publicKeyPath:(<span class="built_in">NSString</span> *)publicKeyPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断originString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((originString == <span class="literal">nil</span>) || (originString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断publicKeyPath参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKeyPath == <span class="literal">nil</span>) || (publicKeyPath == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKeyPath isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKeyPath length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取公钥对象和需要加密的字符串内容编码数据流</span></span><br><span class="line">    SecKeyRef publicKeyRef = [<span class="keyword">self</span> getPublicKeyRefWithFilePath:publicKeyPath];</span><br><span class="line">    <span class="built_in">NSData</span> *originData = [originString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(publicKeyRef)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originData == <span class="literal">nil</span>) || (originData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加密源字符串内容编码数据流的数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *resultData = <span class="literal">nil</span>;</span><br><span class="line">    resultData = [<span class="keyword">self</span> encryptData:originData withKeyRef:publicKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> <span class="keyword">class</span>] base64EncodedStringWithData:resultData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)decryptString:(<span class="built_in">NSString</span> *)encryptString privateKeyPath:(<span class="built_in">NSString</span> *)privateKeyPath privateKeyPwd:(<span class="built_in">NSString</span> *)privateKeyPwd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断encryptString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((encryptString == <span class="literal">nil</span>) || (encryptString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断publicKeyPath参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((privateKeyPath == <span class="literal">nil</span>) || (privateKeyPath == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKeyPath isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKeyPath length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断密码是否存在</span></span><br><span class="line">    <span class="built_in">NSString</span> *keyPassword = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,privateKeyPwd];</span><br><span class="line">    <span class="keyword">if</span> ((privateKeyPwd == <span class="literal">nil</span>) || (privateKeyPwd == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        keyPassword = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKeyPwd isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        keyPassword = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKeyPwd length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        keyPassword = <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取私钥对象和需要加密的字符串内容编码数据流</span></span><br><span class="line">    <span class="built_in">NSData</span> *encryptData = <span class="literal">nil</span>, *decryptData = <span class="literal">nil</span>;</span><br><span class="line">    SecKeyRef privateKeyRef = [<span class="keyword">self</span> getPrivateKeyRefWithFilePath:privateKeyPath</span><br><span class="line">                                                     keyPassword:privateKeyPwd];</span><br><span class="line">    encryptData = [[<span class="keyword">self</span> <span class="keyword">class</span>] base64DecodeDataWithString:encryptString];</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(privateKeyRef)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((encryptData == <span class="literal">nil</span>) || (encryptData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line">    decryptData = [<span class="keyword">self</span> decryptData:encryptData withKeyRef:privateKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc] initWithData:decryptData encoding:encoding];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - RSA Key String Encrypt/Decrypt Public Method</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)encryptData:(<span class="built_in">NSData</span> *)originData publicKey:(<span class="built_in">NSString</span> *)publicKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断originData参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((originData == <span class="literal">nil</span>) || (originData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断publicKeyPath参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKey == <span class="literal">nil</span>) || (publicKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取需要加密的字符串内容编码数据流</span></span><br><span class="line">    SecKeyRef publicKeyRef = [<span class="keyword">self</span> publicKeyRefWithPublicKey:publicKey];</span><br><span class="line">    <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(publicKeyRef)])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> encryptData:originData withKeyRef:publicKeyRef];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)encryptString:(<span class="built_in">NSString</span> *)originString publicKey:(<span class="built_in">NSString</span> *)publicKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断publicKey参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKey == <span class="literal">nil</span>) || (publicKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断originString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((originString == <span class="literal">nil</span>) || (originString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取需要加密的字符串内容编码数据流</span></span><br><span class="line">    <span class="built_in">NSData</span> *originData = <span class="literal">nil</span>, *encryptData = <span class="literal">nil</span>;</span><br><span class="line">    SecKeyRef publicKeyRef = [<span class="keyword">self</span> publicKeyRefWithPublicKey:publicKey];</span><br><span class="line">    originData = [originString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(publicKeyRef)])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originData == <span class="literal">nil</span>) || (originData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    encryptData = [<span class="keyword">self</span> encryptData:originData withKeyRef:publicKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> <span class="keyword">class</span>] base64EncodedStringWithData:encryptData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)decryptString:(<span class="built_in">NSString</span> *)encryptString privateKey:(<span class="built_in">NSString</span> *)privateKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断publicKey参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((privateKey == <span class="literal">nil</span>) || (privateKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断originString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((encryptString == <span class="literal">nil</span>) || (encryptString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取私钥对象和需要加密的字符串内容编码数据流</span></span><br><span class="line">    SecKeyRef privateKeyRef;</span><br><span class="line">    <span class="built_in">NSData</span> *encryptData = <span class="literal">nil</span>, *decryptData = <span class="literal">nil</span>;</span><br><span class="line">    privateKeyRef = [[<span class="keyword">self</span> <span class="keyword">class</span>] privateKeyRefWithPrivateKey:privateKey];</span><br><span class="line">    encryptData = [[<span class="keyword">self</span> <span class="keyword">class</span>] base64DecodeDataWithString:encryptString];</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(privateKeyRef)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((encryptData == <span class="literal">nil</span>) || (encryptData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line">    decryptData = [<span class="keyword">self</span> decryptData:encryptData withKeyRef:privateKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc] initWithData:decryptData encoding:encoding];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br></pre></td></tr></table></figure><p>在iOS中RSA加解密使用方法介绍（RSA密钥格式请使用PKCS#8格式）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RSA执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *string4 = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *encodeString4 = [RSAEncrypt encryptString:string4</span><br><span class="line">                                          publicKey:mPublicKey];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeString4 : %@"</span>, encodeString4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RSA执行解密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *decodeString4 = [RSAEncrypt decryptString:encodeString4</span><br><span class="line">                                         privateKey:mPrivateKey];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"decodeString4 : %@"</span>, decodeString4);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="Encryption" scheme="https://nixzhang5.github.io/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking原理(二) AFSecurityPolicy</title>
    <link href="https://nixzhang5.github.io/AFNetWorking%E5%8E%9F%E7%90%86%E4%BA%8C.html"/>
    <id>https://nixzhang5.github.io/AFNetWorking原理二.html</id>
    <published>2019-06-25T03:31:07.000Z</published>
    <updated>2019-06-25T10:49:12.251Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。</p><a id="more"></a><p>AFSecurityPolicy 的校验选项 AFSSLPinningMode 有三种：</p><ol><li>AFSSLPinningModeNone 在与服务器建立安全连接时，并不会使用应用中已有的证书（也可能本就没有）对服务器传递的信息进行校验，此为默认选项</li><li>AFSSLPinningModePublicKey 使用应用中已有的公钥对服务器传递的信息进行校验</li><li>AFSSLPinningModeCertificate 使用应用中已有的数字证书对服务器传递的信息进行校验</li></ol><h3 id="HTPPS"><a href="#HTPPS" class="headerlink" title="HTPPS"></a>HTPPS</h3><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。</p><p>HTTPS连接建立 非对称加密、对称加密：<br>客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有（各个受信任的证书机构）根证书，用这些根证书对<strong>服务端返回的证书</strong>进行验证，经验证如果证书（服务端返回的证书）是可信任的，就生成一个pre-master  secret，用这个证书（服务端返回的证书）的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master  secret，客户端也同样根据这种算法从pre-master secret生成master secret（非对称加密），随后双方的通信都用这个master  secret对传输数据进行加密解密（对称加密）。</p><p>非对称加密： d(c(x))=x</p><h3 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h3><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p>HTTPS和HTTP的区别主要为以下四点：</p><ol><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL(Secure Sockets Layer安全套接层),及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p><p>SSL (Secure Socket Layer)为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。</p><p>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>SSL协议可分为两层：</p><ol><li>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</li><li>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ol><p>SSL协议提供的服务主要有哪些</p><ul><li>认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>加密数据以防止数据中途被窃取</li><li>维护数据的完整性，确保数据在传输过程中不被改变。</li></ul><p>SSL协议的工作流程</p><ul><li><p>服务器认证阶段：<br>客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；<br>服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；<br>客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；<br>服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p></li><li><p>用户认证阶段：<br>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p></li></ul><p>从SSL 协议所提供的服务及其工作流程可以看出，SSL协议运行的基础是商家对消费者信息保密的承诺，这就有利于商家而不利于消费者。在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。但随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的单一认证问题就越来越突出。虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务器双方的身份验证，但是SSL协议仍存在一些问题，比如，只能提供交易中客户与服务器间的双方认证，在涉及多方的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。在这种情况下，Visa和MasterCard两大信用卡公组织制定了SET协议，为网上信用卡支付提供了全球性的标准。</p><h3 id="SSL协议加密方式"><a href="#SSL协议加密方式" class="headerlink" title="SSL协议加密方式"></a>SSL协议加密方式</h3><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><ol><li><p>对称加密<br>速度高，可加密内容较大，用来加密会话过程中的消息</p></li><li><p>公钥加密<br>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p></li></ol><h3 id="SSL证书包含的信息"><a href="#SSL证书包含的信息" class="headerlink" title="SSL证书包含的信息"></a>SSL证书包含的信息</h3><ul><li><p>证书版本号，不同版本的证书格式不同</p></li><li><p>Serial Number　序列号，同一身份验证机构签发的证书序列号唯一</p></li><li><p>Algorithm Identifier 　签名算法，包括必要的参数Issuer 身份验证机构的标识信息</p></li><li><p>Period of Validity 　有效期</p></li><li><p>Subject　证书持有人的标识信息</p></li><li><p>Subject’s Public Key　证书持有人的公钥</p></li><li><p>Signature　身份验证机构对证书的签名</p></li><li><p>证书的格式　 认证中心所发放的证书均遵循X.509 V3 标准，其基本格式如下：</p></li><li><p>证书版本号（Certificate Format Version）<br>含义：用来指定证书格式采用的X.509 版本号。</p></li><li><p>证书序列号（Certificate Serial Number）<br>含义：用来指定证书的唯一序列号，以标识CA 发出的所有公钥证书。</p></li><li><p>签名（Signature）算法标识（Algorithm Identifier）<br>含义：用来指定 CA 签发证书所用的签名算法。</p></li><li><p>签发此证书的 CA 名称（Issuer ）<br>含义：用来指定签发证书的 CA 的X.500 唯一名称（DN，Distinguished Name）。</p></li><li><p>证书有效期（Validity Period）起始日期（notBefore） 终止日期（notAfter）<br>含义：用来指定证书起始日期和终止日期。</p></li><li><p>用户名称（Subject）<br>含义：用来指定证书用户的X.500 唯一名称（DN，Distinguished Name）。</p></li><li><p>用户公钥信息（Subject Public Key Information）算法（algorithm） 算法标识（Algorithm　Identifier）用户公钥（subject　Public　Key）<br>含义：用来标识公钥使用的算法，并包含公钥本身。</p></li><li><p>证书扩充部分（扩展域）（Extensions）<br>含义：用来指定额外信息。</p></li><li><p>X.509 V3 证书的扩充部分（扩展域）及实现方法如下：</p></li><li><p>CA 的公钥标识（Authority　Key　Identifier）</p></li><li><p>公钥标识（SET 未使用）（Key　Identifier）</p></li><li><p>签发证书者证书的签发者的甄别名（Certificate　Issuer）</p></li><li><p>签发证书者证书的序列号（Certificate Serial Number）</p></li><li><p>X.509 V3 证书的扩充部分（扩展域）及实现CA 的公钥标识（Authority　Key　Identifier）</p></li><li><p>公钥标识（SET 未使用）（Key　Identifier）</p></li><li><p>签发证书者证书的签发者的甄别名（Certificat签发证书者证书的序列号（Certificate Serial Number）<br>含义：CA 签名证书所用的密钥对的唯一标识用户的公钥标识（Subject　Key　Identifier）<br>含义：用来标识与证书中公钥相关的特定密钥进行解密。</p></li><li><p>证书中的公钥用途（Key　Usage）<br>含义：用来指定公钥用途。</p></li><li><p>用户的私钥有效期（Private　Key　Usage　Period）起始日期（Note　Before） 终止日期（Note　After）<br>含义：用来指定用户签名私钥的起始日期和终止日期。</p></li><li><p>CA 承认的证书政策列表（Certificate Policies）<br>含义：用来指定用户证书所适用的政策，证书政策可由对象标识符表示。</p></li><li><p>用户的代用名（Substitutional　Name）<br>含义：用来指定用户的代用名。</p></li><li><p>CA 的代用名（Issuer　Alt　Name）<br>含义：用来指定 CA 的代用名。</p></li><li><p>基本制约（Basic　Constraints）<br>含义：用来表明证书用户是最终用户还是CA。 在SET 系统中有一些私有扩充部分（扩展域）Hashed　Root　Key 含义：只在根证书中使用，用于证书更新时进行回溯。</p></li><li><p>证书类型（Certificate　Type）<br>含义：用来区别不同的实体。该项是必选的。</p></li><li><p>商户数据（Merchant　Data）<br>含义：包含支付网关需要的所有商户信息。</p></li><li><p>持卡人证书需求（Card　Cert　Required）<br>含义：显示支付网关是否支持与没有证书的持卡人进行交易。</p></li><li><p>SET 扩展（SETExtensions）<br>含义：列出支付网关支持的支付命令的 SET 信息扩展。</p></li><li><p>CRL 数据定义版本（Version）<br>含义：显示 CRL 的版本号。</p></li><li><p>CRL 的签发者（Issuer）<br>含义：指明签发 CRL 的CA 的甄别名。</p></li></ul><p>CRL 发布时间（this　Update）预计下一个 CRL 更新时间（Next　Update）撤销证书信息目录（Revoked　Certificates）CRL 扩展（CRL　Extension）CA 的公钥标识（Authority　Key　Identifier）CRL 号（CRL　Number）</p><p>SSL证书种类：<br>CFCA，GlobalSign，VeriSign ，Geotrust ，Thawte。</p><ul><li>域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站；</li><li>企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高；</li><li>增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。</li></ul><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p>为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：</p><ol><li>客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</li><li>服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</li><li>客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</li><li>用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</li><li>如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。</li><li>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</li><li>服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</li><li>客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</li><li>服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</li><li>SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</li></ol><h3 id="HTTPS的认证过程"><a href="#HTTPS的认证过程" class="headerlink" title="HTTPS的认证过程"></a>HTTPS的认证过程</h3><h4 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h4><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ol><li>证书是否过期</li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ol></li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</li><li>服务器将选择好的加密方案通过明文方式返回给客户端</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li></ol><h4 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h4><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ol><li>证书是否过期</li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ol></li><li>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li></ol><h3 id="AFSecurityPolicy和认证"><a href="#AFSecurityPolicy和认证" class="headerlink" title="AFSecurityPolicy和认证"></a>AFSecurityPolicy和认证</h3><h4 id="认证过程和原理"><a href="#认证过程和原理" class="headerlink" title="认证过程和原理"></a>认证过程和原理</h4><p>AFN是靠着AFSecurityPolicy这个类保证数据安全的，调用下面方法用来验证是否信任服务器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]</span><br></pre></td></tr></table></figure><p>看一下AFN中的接口</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    @typedef SecTrustRef</span></span><br><span class="line"><span class="comment">    @abstract CFType used for performing X.509 certificate trust evaluations.</span></span><br><span class="line"><span class="comment">    // 执行X.509证书信任评估，其实就是一个容器，装了服务器端需要验证的证书的基本信息、</span></span><br><span class="line"><span class="comment">    公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书，</span></span><br><span class="line"><span class="comment">    这个客户端的证书，可以用来和服务端的证书去匹配验证的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_TYPE</span>(<span class="keyword">id</span>) __SecTrust *SecTrustRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not the specified server trust should be accepted, based on the security policy.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> This method should be used when responding to an authentication challenge from a server.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust The X.509 certificate trust of the server.</span></span><br><span class="line"><span class="comment"> @param domain The domain of serverTrust. If `nil`, the domain will not be validated. // 服务器域名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return Whether or not to trust the server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)domain;</span><br></pre></td></tr></table></figure><p>根据安全策略是否接受指定的服务器信任。 响应来自服务器的身份验证质询时应使用此方法。</p><p>大家还记得这个代理方法吗？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//挑战处理类型为 默认</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeUseCredential：使用指定的证书</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span></span><br><span class="line">        <span class="comment">// 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                <span class="comment">// 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书）</span></span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="comment">// 确定挑战的方式</span></span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    <span class="comment">//证书挑战  设计policy,none，则跑到这里</span></span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//取消挑战</span></span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认挑战方式</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成挑战</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是如何进行接受挑战的</p><ul><li>首先指定了HTTPS为默认的认证方式。</li><li>判断有没有自定义Block:sessionDidReceiveAuthenticationChallenge，有的话，使用我们自定义Block,生成一个认证方式，并且可以给credential赋值，即我们需要接受认证的证书。然后直接调用completionHandler，去根据这两个参数，执行系统的认证。</li><li>如果没有自定义Block，我们判断如果服务端的认证方法要求是NSURLAuthenticationMethodServerTrust，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现）</li><li>接着我们就执行了AFSecurityPolicy相关的上面的方法- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain，关于这个方法，AF默认的处理是，如果这行返回NO、说明AF内部认证失败，则取消HTTPS认证，即取消请求。返回YES则进入if块，用服务器返回的一个serverTrust去生成了一个认证证书。（注：这个serverTrust是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。最后调用completionHandler传递认证方式和要认证的证书，去做系统根证书验证。也可以这么理解：这里securityPolicy存在的作用就是，使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。如果通不过，则直接越过系统的验证，取消HTTPS的网络请求。否则，继续去走系统根证书的验证。</li></ul><h4 id="AFSecurityPolicy实例化"><a href="#AFSecurityPolicy实例化" class="headerlink" title="AFSecurityPolicy实例化"></a>AFSecurityPolicy实例化</h4><p>先看一下该类的实例化</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个很重要的属性就是SSLPinningMode，先看一下这个枚举</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,    <span class="comment">//不验证</span></span><br><span class="line">    AFSSLPinningModePublicKey,  <span class="comment">//只验证公钥</span></span><br><span class="line">    AFSSLPinningModeCertificate,  <span class="comment">// 验证证书</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面我们看一下类AFSecurityPolicy的几个属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The criteria by which server trust should be evaluated against the pinned SSL certificates. Defaults to `AFSSLPinningModeNone`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 验证模式 这个枚举值上面讲述过</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The certificates used to evaluate server trust according to the SSL pinning mode. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  By default, this property is set to any (`.cer`) certificates included in the target compiling AFNetworking. Note that if you are using AFNetworking as embedded framework, no certificates will be pinned by default. Use `certificatesInBundle` to load certificates from your target, and then create a new policy by calling `policyWithPinningMode:withPinnedCertificates`.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> Note that if pinning is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 可以去匹配服务端证书验证的证书</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *pinnedCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not to trust servers with an invalid or expired SSL certificates. Defaults to `NO`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 是否支持非法的证书（例如自签名证书）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowInvalidCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not to validate the domain name in the certificate's CN field. Defaults to `YES`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 是否去验证证书域名是否匹配</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> validatesDomainName;</span><br></pre></td></tr></table></figure><h3 id="AFNetWorking-HTTPS请求示例"><a href="#AFNetWorking-HTTPS请求示例" class="headerlink" title="AFNetWorking HTTPS请求示例"></a>AFNetWorking HTTPS请求示例</h3><h4 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h4><p>我们手动指定securityPolicy认证属性。通过12306证书来实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自建证书认证</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)buttion1:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://kyfw.12306.cn/otn/leftTicket/init"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">   <span class="comment">// [request setValue:@"text/html" forHTTPHeaderField:@"Accept"];</span></span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">    <span class="comment">//指定安全策略</span></span><br><span class="line">    manager.securityPolicy = [<span class="keyword">self</span> ticketSecurityPolicy];</span><br><span class="line">    <span class="comment">//指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型</span></span><br><span class="line">    AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"text/html"</span>];</span><br><span class="line">    manager.responseSerializer = responseSerializer;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>],error);</span><br><span class="line">    &#125;];</span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 12306的认证证书，他的认证证书是自签名的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 返回指定的认证策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(AFSecurityPolicy*)ticketSecurityPolicy &#123;</span><br><span class="line">    <span class="comment">// /先导入证书</span></span><br><span class="line">    <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"12306"</span> ofType:<span class="string">@"cer"</span>];<span class="comment">//证书的路径</span></span><br><span class="line">    <span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</span><br><span class="line">    <span class="built_in">NSSet</span> *set = [<span class="built_in">NSSet</span> setWithObject:certData];</span><br><span class="line"></span><br><span class="line">    AFSecurityPolicy *securityPolicy;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:set];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书</span></span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line">    <span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line">    <span class="comment">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line">    <span class="comment">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line">    <span class="comment">//如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">    securityPolicy.validatesDomainName = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SSL信任证书"><a href="#SSL信任证书" class="headerlink" title="SSL信任证书"></a>SSL信任证书</h4><p>我们手动指定securityPolicy认证属性。通过百度证书来实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//认证证书认证</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)button2:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    <span class="comment">//[request setValue:@"text/html" forHTTPHeaderField:@"Accept"];</span></span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">    <span class="comment">//指定安全策略</span></span><br><span class="line">    manager.securityPolicy = [<span class="keyword">self</span> baiduSecurityPolicy];</span><br><span class="line">    <span class="comment">//指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型</span></span><br><span class="line">    AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"text/html"</span>];</span><br><span class="line">    manager.responseSerializer = responseSerializer;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>],error);</span><br><span class="line">    &#125;];</span><br><span class="line">    [dataTask resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">百度的的认证证书，他的认证证书是花钱买的，也就是不是自签名的证书。这种证书，如果我们要手动指定，pinmode只能是`AFSSLPinningModeNone`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 返回指定的认证策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(AFSecurityPolicy*)baiduSecurityPolicy &#123;</span><br><span class="line">    <span class="comment">// /先导入证书</span></span><br><span class="line">    <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"baidu"</span> ofType:<span class="string">@"cer"</span>];<span class="comment">//证书的路径</span></span><br><span class="line">    <span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</span><br><span class="line">    <span class="built_in">NSSet</span> *set = [<span class="built_in">NSSet</span> setWithObject:certData];</span><br><span class="line"></span><br><span class="line">    AFSecurityPolicy *securityPolicy;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//这里只能用AFSSLPinningModeNone才能成功，而且我系统的证书列表里面已经有百度的证书了</span></span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone withPinnedCertificates:set];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书</span></span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line">    <span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line">    <span class="comment">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line">    <span class="comment">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line">    <span class="comment">//如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">    securityPolicy.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SSL证书AFN默认处理"><a href="#SSL证书AFN默认处理" class="headerlink" title="SSL证书AFN默认处理"></a>SSL证书AFN默认处理</h4><p>这里我们不做任何额外的处理，直接使用AFN的默认证书处理机制。通过AFURLSessionManager的securityPolicy默认实现。它会和存在系统中的做对比来验证证书。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统证书认证</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)button3:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.apple.com/"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">    <span class="comment">//指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型</span></span><br><span class="line">    AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"text/html"</span>];</span><br><span class="line">    manager.responseSerializer = responseSerializer;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>],error);</span><br><span class="line">    &#125;];</span><br><span class="line">    [dataTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AFSecurityPolicy源码解析"><a href="#AFSecurityPolicy源码解析" class="headerlink" title="AFSecurityPolicy源码解析"></a>AFSecurityPolicy源码解析</h3><p>AFSecurityPolicy分三种验证模式</p><ol><li>AFSSLPinningModeNone:<br>这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。</li><li>AFSSLPinningModeCertificate:<br>这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。这里还没弄明白第一步的验证是怎么进行的，代码上跟去系统信任机构列表里验证一样调用了SecTrustEvaluate，只是这里的列表换成了客户端保存的那些证书列表。若要验证这个，是否应该把服务端证书的颁发机构根证书也放到客户端里？</li><li>AFSSLPinningModePublicKey:<br>这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</li></ol><p><strong>SecTrustRef</strong><br>这是一个需要验证的信任对象,包含待验证的证书和支持的验证方法等。</p><p><strong>SecTrustResultType</strong><br>表示验证结果。其中 kSecTrustResultProceed表示serverTrust验证成功，且该验证得到了用户认可(例如在弹出的是否信任的alert框中选择always trust)。 kSecTrustResultUnspecified表示 serverTrust验证成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书。 两者取其一就可以认为对serverTrust验证成功。</p><p><strong>SecTrustEvaluate</strong><br>证书校验函数,在函数的内部递归地从叶节点证书到根证书验证。需要验证证书本身的合法性（验证签名完整性，验证证书有效期等);验证证书颁发者的合法性（查找颁发者的证书并检查其合法性，这个过程是递归的).而递归的终止条件是证书验证过程中遇到了锚点证书(锚点证书:嵌入到操作系统中的根证书,这个根证书是权威证书颁发机构颁发的自签名证书)。</p><p>AFSecurityPolicy的源码细节如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 证书的验证类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> - AFSSLPinningModeNone: 不使用`pinned certificates`来验证证书</span></span><br><span class="line"><span class="comment"> - AFSSLPinningModePublicKey: 使用`pinned certificates`来验证证书的公钥</span></span><br><span class="line"><span class="comment"> - AFSSLPinningModeCertificate: 使用`pinned certificates`来验证整个证书</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获取指定证书的公钥</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param certificate 证书数据</span></span><br><span class="line"><span class="comment"> @return 公钥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFPublicKeyForCertificate(<span class="built_in">NSData</span> *certificate) &#123;</span><br><span class="line">    <span class="keyword">id</span> allowedPublicKey = <span class="literal">nil</span>;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecPolicyRef policy = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustRef allowedTrust = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    <span class="comment">//获取证书对象</span></span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != <span class="literal">NULL</span>, _<span class="keyword">out</span>);</span><br><span class="line">    <span class="comment">//获取X.509的认证策略</span></span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="comment">//获取allowedTrust对象的值</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _<span class="keyword">out</span>);</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">    <span class="comment">//根据allowedTrust获取对应的公钥</span></span><br><span class="line">    allowedPublicKey = (__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"><span class="comment">//C++的gumpto跳转，当前面的操作出错以后，直接跳入_out执行</span></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">if</span> (allowedTrust) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedTrust);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (policy) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(policy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allowedCertificate) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedCertificate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回公钥</span></span><br><span class="line">    <span class="keyword">return</span> allowedPublicKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在指定的证书和认证策略下，验证SecTrustRef对象是否是受信任的、合法的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust SecTrustRef对象</span></span><br><span class="line"><span class="comment"> @return 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    <span class="comment">//获取serverTrust的认证结果，调用`SecTrustEvaluate`表示通过系统的证书来比较认证</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据`serverTrust`获取认证的证书链</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust serverTrust对象</span></span><br><span class="line"><span class="comment"> @return 认证证书链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//获取认证链的总层次</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">//获取每一级认证链，把获取的证书数据存入数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回证书链数组</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获取serverTrust对象的认证链的公钥数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust serverTrust对象</span></span><br><span class="line"><span class="comment"> @return 公钥数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//X.509标准的安全策略</span></span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="comment">//获取证书链的证书数量</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line"></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        <span class="built_in">CFArrayRef</span> certificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)someCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        <span class="comment">//通过一个证书、认证策略新建一个SecTrustRef对象</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        <span class="comment">//验证SecTrustRef对象是否成功</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">        <span class="comment">//把SecTrustRef对应的公钥加入数组中</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _<span class="keyword">out</span>:</span><br><span class="line">        <span class="keyword">if</span> (trust) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (certificates) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(certificates);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(policy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFSecurityPolicy</span>()</span></span><br><span class="line"><span class="comment">//认证策略</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"><span class="comment">//公钥集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span> *pinnedPublicKeys;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFSecurityPolicy</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 从MainBundle中获取所有证书</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param bundle 返回包含在bundle中的证书集合。如果AFNetworking使用的是静态库，我们必须通过这个方法来加载证书。并且通过`policyWithPinningMode:withPinnedCertificates`方法来指定认证类型。</span></span><br><span class="line"><span class="comment"> @return 返回bundle里面的证书</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)certificatesInBundle:(<span class="built_in">NSBundle</span> *)bundle &#123;</span><br><span class="line">    <span class="comment">//获取项目里的所有.cer证书</span></span><br><span class="line">    <span class="built_in">NSArray</span> *paths = [bundle pathsForResourcesOfType:<span class="string">@"cer"</span> inDirectory:<span class="string">@"."</span>];</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *certificates = [<span class="built_in">NSMutableSet</span> setWithCapacity:[paths count]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *path <span class="keyword">in</span> paths) &#123;</span><br><span class="line">        <span class="comment">//获取证书对应的NSData，并且加入集合中</span></span><br><span class="line">        <span class="built_in">NSData</span> *certificateData = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        [certificates addObject:certificateData];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回证书集合</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithSet:certificates];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回当前类所在bundle所在的证书集合</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 证书集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)defaultPinnedCertificates &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSSet</span> *_defaultPinnedCertificates = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">//获取当前类所在bundle</span></span><br><span class="line">        <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</span><br><span class="line">        _defaultPinnedCertificates = [<span class="keyword">self</span> certificatesInBundle:bundle];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _defaultPinnedCertificates;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回默认的安全认证策略,在这里是验证系统的证书。这个策略不允许非法证书、验证主机名、不验证证书内容和公钥</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 返回认证策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据指定的认证策略和默认的证书列表初始化一个`AFSecurityPolicy`对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param pinningMode 认证策略</span></span><br><span class="line"><span class="comment"> @return `AFSecurityPolicy`对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:[<span class="keyword">self</span> defaultPinnedCertificates]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 通过制定的认证策略`pinningMode`和证书集合`pinnedCertificates`来初始化一个`AFSecurityPolicy`对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param pinningMode 认证模型</span></span><br><span class="line"><span class="comment"> @param pinnedCertificates 证书集合</span></span><br><span class="line"><span class="comment"> @return AFSecurityPolicy对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = pinningMode;</span><br><span class="line">    <span class="comment">//设置`_pinnedCertificates`和`pinnedPublicKeys`属性，分别对应证书集合和公钥集合</span></span><br><span class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class="line">    <span class="comment">//返回初始化成功的`AFSecurityPolicy`</span></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认是要认证主机名称</span></span><br><span class="line">    <span class="keyword">self</span>.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过指定的证书结合获取到对应的公钥集合。然后赋值给`pinnedPublicKeys`属性</span></span><br><span class="line"><span class="comment"> @param pinnedCertificates 证书集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="comment">//迭代每一个证书</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="comment">//获取证书对应的公钥</span></span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对应的属性</span></span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 为serverTrust对象指定认证策略，如果domain不为nil,则包括对主机名的认证。这个方法必须在接受到`authentication challenge`返回的时候调用。</span></span><br><span class="line"><span class="comment"> SecTrustRef可以理解为桥接证书与认证策略的对象，他关联指定的证书与认证策略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust 服务器的X.509标准的证书数据</span></span><br><span class="line"><span class="comment"> @param domain 认证服务器的主机名。如果是nil,则不会对主机名进行认证。</span></span><br><span class="line"><span class="comment"> @return serverTrust是否通过认证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></span><br><span class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></span><br><span class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></span><br><span class="line">        <span class="comment">//  there is nothing to evaluate against.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  From Apple Docs:</span></span><br><span class="line">        <span class="comment">//          "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></span><br><span class="line">        <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors."</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        <span class="comment">//使用需要认证主机名的认证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//使用默认的认证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给serverTrust对象指定认证策略</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据证书验证策略、数字签名认证策略、其他认证策略来处理不同情况</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:<span class="comment">//不验证公钥和证书</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;<span class="comment">//验证整个证书</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            <span class="comment">//根据指定证书获取，获取对应的证书对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把证书与serverTrust关联起来</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA)</span></span><br><span class="line">            <span class="comment">//获取serverTrust证书链。直到根证书。</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            <span class="comment">//如果`pinnedCertificates`包含`serverTrust`对象对应的证书链的根证书。则返回true</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;<span class="comment">//只验证证书里面的数字签名</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//根据serverTrust对象和SecPolicyCreateBasicX509认证策略，获取对应的公钥集合</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="comment">//把获取的公钥和系统获取的默认公钥比较，如果相等，则通过认证</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSKeyValueObserving</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingPinnedPublicKeys &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"pinnedCertificates"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSSecureCoding</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)supportsSecureCoding &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.SSLPinningMode = [[decoder decodeObjectOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(SSLPinningMode))] unsignedIntegerValue];</span><br><span class="line">    <span class="keyword">self</span>.allowInvalidCertificates = [decoder decodeBoolForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowInvalidCertificates))];</span><br><span class="line">    <span class="keyword">self</span>.validatesDomainName = [decoder decodeBoolForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(validatesDomainName))];</span><br><span class="line">    <span class="keyword">self</span>.pinnedCertificates = [decoder decodeObjectOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(pinnedCertificates))];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</span><br><span class="line">    [coder encodeObject:[<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="keyword">self</span>.SSLPinningMode] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(SSLPinningMode))];</span><br><span class="line">    [coder encodeBool:<span class="keyword">self</span>.allowInvalidCertificates forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowInvalidCertificates))];</span><br><span class="line">    [coder encodeBool:<span class="keyword">self</span>.validatesDomainName forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(validatesDomainName))];</span><br><span class="line">    [coder encodeObject:<span class="keyword">self</span>.pinnedCertificates forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(pinnedCertificates))];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - NSCopying</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = <span class="keyword">self</span>.SSLPinningMode;</span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="keyword">self</span>.allowInvalidCertificates;</span><br><span class="line">    securityPolicy.validatesDomainName = <span class="keyword">self</span>.validatesDomainName;</span><br><span class="line">    securityPolicy.pinnedCertificates = [<span class="keyword">self</span>.pinnedCertificates copyWithZone:zone];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="AFNetWorking原理" scheme="https://nixzhang5.github.io/tags/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    
      <category term="Encryption" scheme="https://nixzhang5.github.io/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking原理(一) AFURLSessionManager解读</title>
    <link href="https://nixzhang5.github.io/AFNetWorking%E5%8E%9F%E7%90%86.html"/>
    <id>https://nixzhang5.github.io/AFNetWorking原理.html</id>
    <published>2019-06-21T07:48:30.000Z</published>
    <updated>2019-06-25T03:19:09.896Z</updated>
    
    <content type="html"><![CDATA[<p>NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。</p><a id="more"></a><h3 id="AFNetworking由5个模块组成"><a href="#AFNetworking由5个模块组成" class="headerlink" title="AFNetworking由5个模块组成"></a>AFNetworking由5个模块组成</h3><ol><li>NSURLSession：网络通信模块（核心模块）<ol><li>AFURLSessionManager 对NSURLSession的封装</li><li>AFHTTPSessionManager 是继承于 AFURLSessionmanager</li></ol></li><li>Security：网络通讯安全策略模块<ol><li>AFSecurityPolicy</li></ol></li><li>Reachability：网络状态监听模块<ol><li>AFNetworkReachabilityManager</li></ol></li><li>Seriaalization：网络通信信息序列化、反序列化模块<ol><li>AFHTTPRequestSerializer</li><li>AFURLResponseSerialization</li></ol></li><li>UIKit：对于iOS UIKit的扩展库</li></ol><h3 id="网络请求类-AFURLSessionManager"><a href="#网络请求类-AFURLSessionManager" class="headerlink" title="网络请求类 AFURLSessionManager"></a>网络请求类 AFURLSessionManager</h3><h4 id="声明-h文件"><a href="#声明-h文件" class="headerlink" title="声明.h文件"></a>声明.h文件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFURLSessionManager类实现了NSURLSession相关的众多协议，用于帮助我们进行数据的处理</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManager</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionDelegate</span>, <span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLSessionDownloadDelegate</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSURLSession 作为一个实例变量，AFN发起的网络请求都是通过该session创建的task实现的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSURLSession delegate方法执行队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应序列化 不能为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全策略，用于https等需要验证的地方</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !TARGET_OS_WATCH（生成的代码将在Apple Watch操作系统下运行）</span></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Monitoring Network Reachability</span></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监测网络连通性，使用AFNetworkReachabilityManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFNetworkReachabilityManager *reachabilityManager;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///----------------------------</span></span><br><span class="line"><span class="comment">/// @name Getting Session Tasks</span></span><br><span class="line"><span class="comment">///----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的data upload download task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionTask</span> *&gt; *tasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的data task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDataTask</span> *&gt; *dataTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的upload task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionUploadTask</span> *&gt; *uploadTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的download task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDownloadTask</span> *&gt; *downloadTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------------</span></span><br><span class="line"><span class="comment">/// @name Managing Callback Queues</span></span><br><span class="line"><span class="comment">///-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成网络请求后执行回调块的队列，如果为nil则使用主队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> completionQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成网络请求后回调块的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) dispatch_group_t completionGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"><span class="comment">/// @name Working Around System Bugs</span></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// background类型的session是否尝试重新创建上传任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> attemptsToRecreateUploadTasksForBackgroundSessions;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------</span></span><br><span class="line"><span class="comment">/// @name Initialization</span></span><br><span class="line"><span class="comment">///---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数，根据指定NSURLSessionConfiguration创建session</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)configuration <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session无效，cancelPendingTasks标识是否取消session中正在执行的任务</span></span><br><span class="line"><span class="comment">// 内部还是调用NSURLSession的invalidate方法</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionCancelingTasks:(<span class="built_in">BOOL</span>)cancelPendingTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------</span></span><br><span class="line"><span class="comment">/// @name Running Data Tasks</span></span><br><span class="line"><span class="comment">///-------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的request创建一个NSURLSessionDataTask任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler DEPRECATED_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的request创建一个NSURLSessionDataTask任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------------</span></span><br><span class="line"><span class="comment">/// @name Running Upload Tasks</span></span><br><span class="line"><span class="comment">///---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定request fileURL等参数构造一个NSURLSessionUploadTask任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span>  * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定request和data等参数构造一个上传任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)bodyData</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个具有特定数据流的NSURLSessionUploadTask请求，上传的body使用的是request.HTTPBodyStream</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                 progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                        completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------</span></span><br><span class="line"><span class="comment">/// @name Running Download Tasks</span></span><br><span class="line"><span class="comment">///-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造下载任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                             progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                          destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                    completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造下载任务 断点续传</span></span><br><span class="line"><span class="comment">根据未下载完成的数据，创建一个NSURLSessionDownloadTask对象。</span></span><br><span class="line"><span class="comment">resumeData：未完成的下载数据</span></span><br><span class="line"><span class="comment">destination：决定下载文件的存放路径的block。block中有两个参数，目标路径和服务器的响应。同时返回文件下载的URL</span></span><br><span class="line"><span class="comment">completionHandler：当任务完成后completionHandler的block会被调用</span></span><br><span class="line"><span class="comment">progress：下载进度block。每当下载进度更新时就会执行这个block</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData</span><br><span class="line">                                                progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                             destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                       completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"><span class="comment">/// @name Getting Progress for Tasks</span></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据NSURLSessionTask获取对应的任务完成进度NSProgress</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSProgress</span> *)uploadProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据NSURLSessionTask获取对应下载任务的进度NSProgress</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSProgress</span> *)downloadProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Session Delegate Callbacks</span></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session无效时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session收到challenge时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Task Delegate Callbacks</span></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session需要新的流时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskNeedNewBodyStreamBlock:(<span class="keyword">nullable</span> <span class="built_in">NSInputStream</span> * (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session的任务需要执行重定向时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskWillPerformHTTPRedirectionBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> * _Nullable (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURLRequest</span> *request))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Block用于当一个session的task接收到证书验证时调用。实际上依赖由NSURLSessionTaskDelegate 的 URLSession:task:didReceiveChallenge:completionHandler:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Block每隔一段时间调用用来跟踪上传进度，实际上依赖由NSURLSessionTaskDelegate的 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidSendBodyDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个当task完成时调用的Block</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidCompleteBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSError</span> * _Nullable error))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Data Task Delegate Callbacks</span></span><br><span class="line"><span class="comment">///-------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个当DataTask请求接收到响应时调用的block。交由NSURLSessionDataDelegate的URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidReceiveResponseBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionResponseDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLResponse</span> *response))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当一个dataTask转变成downloadTak时调用的block，交由</span></span><br><span class="line"><span class="built_in">NSURLSessionDataDelegate</span> 的 URLSession:dataTask:didBecomeDownloadTask:.方法处理</span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidBecomeDownloadTaskBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当一个dataTask接受到数据时就调用的block，交由</span></span><br><span class="line"><span class="built_in">NSURLSessionDataDelegate</span> 的 URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理</span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidReceiveDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSData</span> *data))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当一个dataTask对请求结果的缓冲时的block。交由NSURLSessionDataDelegate 的 URLSession:dataTask:willCacheResponse:completionHandler:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskWillCacheResponseBlock:(<span class="keyword">nullable</span> <span class="built_in">NSCachedURLResponse</span> * (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSCachedURLResponse</span> *proposedResponse))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当session中所有消息都被发送时，调用的block。交由NSURLSessionDataDelegate的URLSessionDidFinishEventsForBackgroundURLSession：方法实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setDidFinishEventsForBackgroundURLSessionBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session))block AF_API_UNAVAILABLE(macos);</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Download Task Delegate Callbacks</span></span><br><span class="line"><span class="comment">///-----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个当下载任务完成一个下载时调用的block。最终交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didFinishDownloadingToURL:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidFinishDownloadingBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * _Nullable  (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, <span class="built_in">NSURL</span> *location))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每次追踪下载进度时调用的block，最终交由NSURLSessionDownloadDelegate的URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite：方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidWriteDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个block，当任务重新下载时调用。交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:.方式</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidResumeBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///--------------------</span></span><br><span class="line"><span class="comment">/// @name Notifications</span></span><br><span class="line"><span class="comment">///--------------------</span></span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidResumeNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidSuspendNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDidInvalidateNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDownloadTaskDidFailToMoveFileNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseDataKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteSerializedResponseKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseSerializerKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteAssetPathKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteErrorKey;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><p>通过头文件可以发现，AFURLSessionManager是封装了NSURLSession并实现了其相关的所有协议，提供了一系列方法用于构造各种网络请求任务，并提供回调块进行处理，还提供了一系列设置代理方法执行时的执行回调块的方法，这样，我们也可以监听整个网络请求的过程，当然也可以忽略这些代理方法执行情况，提供了各种通知，通过头文件可以看出，主要目的还是为了封装NSURLSession从而提供更加便捷的方法来实现网络请求。</p><h4 id="实现-m文件"><a href="#实现-m文件" class="headerlink" title="实现.m文件"></a>实现.m文件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef NSFoundationVersionNumber_iOS_8_0</span></span><br><span class="line"><span class="meta">#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C静态函数，GCD只执行一次，用于创建一个串行队列来执行各种网络请求任务的创建工作</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.creation"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C静态函数，用于执行创建网络请求任务的block</span></span><br><span class="line"><span class="comment">主要目的是为了解决ios8以下存在的一个block和task不匹配的bug</span></span><br><span class="line"><span class="comment">上面那个队列也是为了解决这个bug才创建的</span></span><br><span class="line"><span class="comment">具体可查看</span></span><br><span class="line"><span class="comment">Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span></span><br><span class="line"><span class="comment">Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSFoundationVersionNumber</span> &lt; <span class="built_in">NSFoundationVersionNumber_With_Fixed_5871104061079552_bug</span>) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C静态函数，创建一个并发队列，用于在网络请求任务完成后处理数据的，并发队列实现多线程处理多个请求完成后的数据处理</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.processing"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C静态函数创建一个dispatch的组</span></span><br><span class="line"><span class="comment">//但在接下来的源码中并没有使用这个组来实现notify等功能，仅仅是将block和组关联了，不太清楚具体用意</span></span><br><span class="line"><span class="comment">//有明白的读者还请不吝赐教</span></span><br><span class="line"><span class="keyword">static</span> dispatch_group_t url_session_manager_completion_group() &#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_group_t af_url_session_manager_completion_group;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_completion_group = dispatch_group_create();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_completion_group;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一系列通知名称的定义</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidResumeNotification = <span class="string">@"com.alamofire.networking.task.resume"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteNotification = <span class="string">@"com.alamofire.networking.task.complete"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidSuspendNotification = <span class="string">@"com.alamofire.networking.task.suspend"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDidInvalidateNotification = <span class="string">@"com.alamofire.networking.session.invalidate"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDownloadTaskDidFailToMoveFileNotification = <span class="string">@"com.alamofire.networking.session.download.file-manager-error"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteSerializedResponseKey = <span class="string">@"com.alamofire.networking.task.complete.serializedresponse"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseSerializerKey = <span class="string">@"com.alamofire.networking.task.complete.responseserializer"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseDataKey = <span class="string">@"com.alamofire.networking.complete.finish.responsedata"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteErrorKey = <span class="string">@"com.alamofire.networking.task.complete.error"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteAssetPathKey = <span class="string">@"com.alamofire.networking.task.complete.assetpath"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要使用的NSLock锁的名称</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionManagerLockName = <span class="string">@"com.alamofire.networking.session.manager.lock"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//background session重试创建上传任务次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> <span class="keyword">const</span> AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>对于url_session_manager_create_task_safely这个有什么用？其实这个是被当做是一个在ios8以下，NSURLSessionDataTask出现的一个Bug。问题产生的原因就是当队列是并发的，这是当两个任务同时在不同的线程上创建任务的时候taskIdentifier可能是一样的。<br>大致的意思就是当我们同时创建两个任务，返回了重复的taskIdentifier，这样的话第一个被创建的completionHandler就会被清空，被第二个任务的completionHandler给替换，如果第一个数据是早于第二个数据返回的，那么第一个数据返回之后就会去调用第二个任务的completionHandler。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDidBecomeInvalidBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * __autoreleasing *credential);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLRequest</span> * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURLRequest</span> *request);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * __autoreleasing *credential);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(<span class="built_in">NSURLSession</span> *session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInputStream</span> * (^AFURLSessionTaskNeedNewBodyStreamBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskDidSendBodyDataBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskDidCompleteBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSError</span> *error);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLSessionResponseDisposition</span> (^AFURLSessionDataTaskDidReceiveResponseBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLResponse</span> *response);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDataTaskDidReceiveDataBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSData</span> *data);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSCachedURLResponse</span> * (^AFURLSessionDataTaskWillCacheResponseBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSCachedURLResponse</span> *proposedResponse);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURL</span> * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, <span class="built_in">NSURL</span> *location);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDownloadTaskDidWriteDataBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDownloadTaskDidResumeBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskProgressBlock)(<span class="built_in">NSProgress</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskCompletionHandler)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error);</span><br></pre></td></tr></table></figure><p>定义一些回调的block</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个类AFURLSessionManagerTaskDelegate并实现了NSURLSessionTask的相关协议</span></span><br><span class="line"><span class="comment">//这个类是用于处理NSURLSessionTask相关代理方法的</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManagerTaskDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化构造函数，需要传入一个关联的task</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">//weak修饰的manager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) AFURLSessionManager *manager;</span><br><span class="line"><span class="comment">//可变data用于存储获取到的网络数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableData</span> *mutableData;</span><br><span class="line"><span class="comment">//上传进度NSProgress</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSProgress</span> *uploadProgress;</span><br><span class="line"><span class="comment">//下载进度NSProgress</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSProgress</span> *downloadProgress;</span><br><span class="line"><span class="comment">//下载文件的NSURL</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *downloadFileURL;</span><br><span class="line"><span class="comment">//下载完成的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="comment">//上传进度的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskProgressBlock uploadProgressBlock;</span><br><span class="line"><span class="comment">//下载进度的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskProgressBlock downloadProgressBlock;</span><br><span class="line"><span class="comment">//网络请求完成的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskCompletionHandler completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFURLSessionManagerTaskDelegate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _mutableData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    _uploadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    _downloadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历两个上传和下载NSProgress设置一些属性</span></span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSProgress</span> *progress <span class="keyword">in</span> @[ _uploadProgress, _downloadProgress ])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化progress</span></span><br><span class="line">        progress.totalUnitCount = <span class="built_in">NSURLSessionTransferSizeUnknown</span>;</span><br><span class="line">        progress.cancellable = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//设置取消进度的回调块，执行task的cancel方法</span></span><br><span class="line">        progress.cancellationHandler = ^&#123;</span><br><span class="line">            [weakTask cancel];</span><br><span class="line">        &#125;;</span><br><span class="line">        progress.pausable = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//设置暂停进度的回调块，执行task的suspend方法</span></span><br><span class="line">        progress.pausingHandler = ^&#123;</span><br><span class="line">            [weakTask suspend];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置重新开始的回调块，执行task的resume方法</span></span><br><span class="line">        <span class="keyword">if</span> ([progress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">            progress.resumingHandler = ^&#123;</span><br><span class="line">                [weakTask resume];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//progress添加kvo，监听progress的进度fractionCompleted</span></span><br><span class="line">        [progress addObserver:<span class="keyword">self</span></span><br><span class="line">                   forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                      options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      context:<span class="literal">NULL</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">//删除KVO</span></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress removeObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress removeObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSProgress Tracking</span></span><br><span class="line"><span class="comment">//KVO回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="comment">//上次或下载进度有改变时，执行上传或下载进度回调块</span></span><br><span class="line">   <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionTaskDelegate</span></span><br><span class="line"><span class="comment">//代理方法，网络请求完成或出错</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//manager用weak修饰，这里strong一下防止manager被释放</span></span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//为userInfo字典设置响应序列化</span></span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line">    <span class="comment">//赋值mutableData到data中，并释放mutableData</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果downloadFileURL存在，即是下载任务就设置下载完成后的文件存储url到字典中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="comment">//否则就设置对应的NSData数据到字典中</span></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果网络请求有错误</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">//设置error信息到字典中</span></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个三目运算符需要解释一下，在其他语言中这么写很可能就是语法错误</span></span><br><span class="line"><span class="comment">        这里的意思就是如果manager.completionGroup存在就使用它</span></span><br><span class="line"><span class="comment">        不存在就使用url_session_manager_completion_group函数返回的group</span></span><br><span class="line"><span class="comment">        后面的三目运算符同理</span></span><br><span class="line"><span class="comment">        所以如果自己不设置manager的completionGroup或completionQueue就会使用默认提供的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//执行对应的completionHandler回调块</span></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在主队列即主线程中发送通知</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果网络任务成功完成，异步在并发队列中执行数据处理</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="comment">//序列化响应数据</span></span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line">            <span class="comment">//如果是下载任务设置响应数据为文件的url</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果响应对象序列化成功或是文件url就设置相关字典key-value</span></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果序列化出错，设置相关字典值</span></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同理，在dispatch组中和特定队列执行回调块</span></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//主线程发送通知</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionDataDelegate</span></span><br><span class="line"><span class="comment">//回调方法，收到数据</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置下载进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class="line">    <span class="comment">//添加数据到mutableData</span></span><br><span class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传任务的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123;</span><br><span class="line">    <span class="comment">//设置上传进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.completedUnitCount = task.countOfBytesSent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionDownloadDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务的回调方法</span></span><br><span class="line"><span class="comment">//由于NSURLSession的downloadTask直接将文件下载到磁盘沙盒中，所以不需要mutableData自行接收数据</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</span><br><span class="line">    <span class="comment">//设置下载进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = totalBytesExpectedToWrite;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = totalBytesWritten;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复下载任务的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes&#123;</span><br><span class="line">    <span class="comment">//设置下载进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = expectedTotalBytes;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = fileOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务下载文件完成后的回调方法</span></span><br><span class="line"><span class="comment">//location就是文件下载到磁盘沙盒目录的NSURL</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置downloadFileURL为nil</span></span><br><span class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果有下载完成的回调块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="comment">//执行该回调块，这个回调块返回一个下载的文件保存的路径URL</span></span><br><span class="line">        <span class="comment">//默认保存在沙盒tmp文件中，可能会被删除，需要持久化时要自己设置一个目录存储</span></span><br><span class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="comment">//如果需要移动文件的路径使用NSFileManaegr移动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError]) &#123;</span><br><span class="line">                <span class="comment">//文件移动发生错误发送通知</span></span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AFURLSessionManagerTaskDelegate的源码，主要就是关联一个NSURLSessionTask并实现了相关任务的代理方法用于数据的获取、上传文件和下载文件。需要注意的是NSURLSessionTask的delegate属性是只读的，只能在使用session创建task的函数中传入代理对象，而且通过源码也没有发现相关代理的设置，所以AFURLSessionManagerTaskDelegate类实现相关代理是为了其他类手动调用相关方法，AFURLSessionManager也实现了这些代理，所以具体的调用是由AFURLSessionManger手动触发的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNSURLSessionTaskDidResumeNotification  = <span class="string">@"com.alamofire.networking.nsurlsessiontask.resume"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNSURLSessionTaskDidSuspendNotification = <span class="string">@"com.alamofire.networking.nsurlsessiontask.suspend"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_AFURLSessionTaskSwizzling</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_AFURLSessionTaskSwizzling</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     WARNING: Trouble Ahead</span></span><br><span class="line"><span class="comment">     https://github.com/AFNetworking/AFNetworking/pull/2702</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky.</span></span><br><span class="line"><span class="comment">         Many Unit Tests have been built to validate as much of this behavior has possible.</span></span><br><span class="line"><span class="comment">         Here is what we know:</span></span><br><span class="line"><span class="comment">            - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn't actually the type of class you will get back.</span></span><br><span class="line"><span class="comment">            - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there.</span></span><br><span class="line"><span class="comment">            - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`.</span></span><br><span class="line"><span class="comment">            - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`.</span></span><br><span class="line"><span class="comment">            - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled.</span></span><br><span class="line"><span class="comment">            - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled.</span></span><br><span class="line"><span class="comment">            - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there.</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">         Some Assumptions:</span></span><br><span class="line"><span class="comment">            - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we'd need to handle it.</span></span><br><span class="line"><span class="comment">            - No background task classes override `resume` or `suspend`</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         The current solution:</span></span><br><span class="line"><span class="comment">            1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task.</span></span><br><span class="line"><span class="comment">            2) Grab a pointer to the original implementation of `af_resume`</span></span><br><span class="line"><span class="comment">            3) Check to see if the current class has an implementation of resume. If so, continue to step 4.</span></span><br><span class="line"><span class="comment">            4) Grab the super class of the current class.</span></span><br><span class="line"><span class="comment">            5) Grab a pointer for the current class to the current implementation of `resume`.</span></span><br><span class="line"><span class="comment">            6) Grab a pointer for the super class to the current implementation of `resume`.</span></span><br><span class="line"><span class="comment">            7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods</span></span><br><span class="line"><span class="comment">            8) Set the current class to the super class, and repeat steps 3-8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#pragma GCC diagnostic push</span></span><br><span class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wnonnull"</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionTaskState</span>)state &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"State method should never be called in the actual dummy class"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSURLSessionTaskStateCanceling</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里用到了method-swizzling的技术，交换了 resume 和 suspend方法的实现，因为iOS7和iOS8中NSURLSessionTask的父类不同，需要做一些处理（发送task暂停、继续通知）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManager</span> ()</span></span><br><span class="line"><span class="comment">//管理的session运行模式，默认情况下使用默认运行模式，defaultConfiguration</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NSOperation队列，代理方法执行的队列</span></span><br><span class="line"><span class="comment">.h文件里是readonly，所以这里定义一个readwrite用于赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"><span class="comment">//管理的session，readwrite</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="comment">//可变字典，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class="line"><span class="comment">//只读属性，通过getter返回数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *taskDescriptionForSessionTasks;</span><br><span class="line"><span class="comment">//NSLock锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> *lock;</span><br><span class="line"><span class="comment">//下面是一系列回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>延展里面定义了一些属性和响应的回调block。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFURLSessionManager</span></span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有指定session运行模式就使用默认的</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line">    <span class="comment">//创建代理方法执行的队列，最大并发数为1，即串行队列</span></span><br><span class="line">    <span class="comment">//感觉这里设置为1是为了让回调一个个执行</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建session，注意代理对象是self</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line">    <span class="comment">//创建响应序列化器</span></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    <span class="comment">//设置默认安全策略</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="comment">//获取网络可达性manager</span></span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取session中的任务，并调用相关方法关联AFURLSessionManagerTaskDelegate</span></span><br><span class="line"><span class="comment">    不太明白这里为什么要这么做，刚创建的session应该没有任何任务在执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构方法，移除所有通知监听</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法里面有一个有一个不明白的点，创建完session之后就去获取它正在执行的任务，刚创建完session为何会有任务呢？<br>这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//taskDescriptionForSessionTasks属性的getter，返回地址的字符串形式数据，可以保证这个字符串是唯一的</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)taskDescriptionForSessionTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通知的回调方法，接下来的代码会添加相关通知</span></span><br><span class="line">- (<span class="keyword">void</span>)taskDidResume:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//发送通知的时候会将task添加进通知中</span></span><br><span class="line">    <span class="built_in">NSURLSessionTask</span> *task = notification.object;</span><br><span class="line">    <span class="comment">//判断这个任务是否是当前manager管理的，如果是就发送相关通知</span></span><br><span class="line">    <span class="comment">//task的taskDescription属性在下文的源码中会设置</span></span><br><span class="line">    <span class="keyword">if</span> ([task respondsToSelector:<span class="keyword">@selector</span>(taskDescription)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([task.taskDescription isEqualToString:<span class="keyword">self</span>.taskDescriptionForSessionTasks]) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">- (<span class="keyword">void</span>)taskDidSuspend:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionTask</span> *task = notification.object;</span><br><span class="line">    <span class="keyword">if</span> ([task respondsToSelector:<span class="keyword">@selector</span>(taskDescription)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([task.taskDescription isEqualToString:<span class="keyword">self</span>.taskDescriptionForSessionTasks]) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是通知的回调方法，用于通知resume和suspend事件。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据task获取相关联的AFURLSessionManagerTaskDelegate对象</span></span><br><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="comment">//task不能为空</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="comment">//上锁，通过task的唯一taskIdentifier从字典中取值，这个唯一标识是在创建task的时候NSURLSessionTask为其设置的，不需要手动设置，保证唯一性</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    delegate = <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为task设置关联的delegate</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//task和delegate都不能为空</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line">    <span class="comment">//上锁，向字典中添加key-value对</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点方法，为dataTask创建一个关联的AFURLSessionManagerTaskDelegate对象</span></span><br><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建AFURLSessionManagerTaskDelegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    <span class="comment">//设置相关属性</span></span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置task的taskDescription，注意和taskIdentifier区分</span></span><br><span class="line"><span class="comment">    taskDescription是开发者自行设置的</span></span><br><span class="line"><span class="comment">    taskIdentifier是NSURLSessionTask设置的，保证每一个task的id不同</span></span><br><span class="line"><span class="comment">    这里设置的taskDescription就是AFURLSessionManager的地址</span></span><br><span class="line"><span class="comment">    所以同一个manager创建的task的description都是一致的</span></span><br><span class="line"><span class="comment">    设置这个值的目的就是为了区分task是否是当前manger创建的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    <span class="comment">//调用上面的方法将task-delegate键值对添加进字典中</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line">    <span class="comment">//设置回调块</span></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，创建上传任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中</span></span><br><span class="line">- (<span class="keyword">void</span>)addDelegateForUploadTask:(<span class="built_in">NSURLSessionUploadTask</span> *)uploadTask</span><br><span class="line">                        progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">               completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    uploadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:uploadTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，创建下载文件任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中</span></span><br><span class="line">- (<span class="keyword">void</span>)addDelegateForDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">                          progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                       destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                 completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    需要注意下，AFURLSessionManagerTaskDelegate中下载文件完成后会调用delegate.downloadTaskDidFinishDownloading回调块</span></span><br><span class="line"><span class="comment">    来获取下载文件要移动到的目录URL</span></span><br><span class="line"><span class="comment">    所以这里就是创建这个回调块，直接返回参数中的destination回调块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (destination) &#123;</span><br><span class="line">        delegate.downloadTaskDidFinishDownloading = ^<span class="built_in">NSURL</span> * (<span class="built_in">NSURLSession</span> * __unused session, <span class="built_in">NSURLSessionDownloadTask</span> *task, <span class="built_in">NSURL</span> *location) &#123;</span><br><span class="line">            <span class="keyword">return</span> destination(location, task.response);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    downloadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line"></span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从字典中删除task对应的delegate的key-value对</span></span><br><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是对AFURLSessionManagerTaskDelegate的创建、添加进字典、删除、获取的操作，这样就实现了每一个NSURLSessionTask对应一个AFURLSessionManagerTaskDelegate对象，可能读者会有疑问，AFURLSessionManager既然已经实现了代理的方法，为什么不直接使用它来处理代理方法，为什么要创建一个类来专门处理，继续看完源码可能你就会明白了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据keyPath获取不同类型任务的集合</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tasksForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    __block <span class="built_in">NSArray</span> *tasks = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//创建一个信号量，值是0</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个方法是异步的，所以为了同步返回结果，需要使用锁，信号量值设置为0或者1时就可以当锁来使用了</span></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(dataTasks))]) &#123;</span><br><span class="line">            tasks = dataTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(uploadTasks))]) &#123;</span><br><span class="line">            tasks = uploadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(downloadTasks))]) &#123;</span><br><span class="line">            tasks = downloadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(tasks))]) &#123;</span><br><span class="line">            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:<span class="string">@"@unionOfArrays.self"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal通知信号量，信号量值加1</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//等待信号量，直到值大于0，等待时间是forever</span></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是tasks、dataTasks、uploadTasks、downloadTasks属性的getter，都是调用上述方法来获取对应类型的任务集合</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)dataTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)uploadTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)downloadTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//设置session无效，根据参数判断是否需要取消正在执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionCancelingTasks:(<span class="built_in">BOOL</span>)cancelPendingTasks &#123;  </span><br><span class="line">    <span class="comment">//调用NSURLSession对应的方法来设置session无效，同时打破引用循环</span></span><br><span class="line">    <span class="keyword">if</span> (cancelPendingTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//responseSerializer的setter</span></span><br><span class="line">- (<span class="keyword">void</span>)setResponseSerializer:(<span class="keyword">id</span> &lt;AFURLResponseSerialization&gt;)responseSerializer &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(responseSerializer);</span><br><span class="line"></span><br><span class="line">    _responseSerializer = responseSerializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//添加通知，taskDidResume、taskDidSuspend方法前面讲过了</span></span><br><span class="line">- (<span class="keyword">void</span>)addNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除通知</span></span><br><span class="line">- (<span class="keyword">void</span>)removeNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法是一些getter和setter，很简单，不再赘述。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并返回NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:completionHandler];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并返回NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了解决iOS8一下的一个bug，调用一个串行队列来创建dataTask</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        <span class="comment">//使用session来创建一个NSURLSessionDataTask对象</span></span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//为这个task创建一个AFURLSessionManagerTaskDelegate并关联加入字典中</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//创建一个NSURLSessionUploadTask对象</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                                         progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromFile:fileURL];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uploadTask may be nil on iOS7 because uploadTaskWithRequest:fromFile: may return nil despite being documented as nonnull (https://devforums.apple.com/message/926113#926113)</span></span><br><span class="line">    <span class="comment">//解决iOS7的一个bug按照配置的尝试次数创建上传任务，默认尝试3次</span></span><br><span class="line">    <span class="keyword">if</span> (!uploadTask &amp;&amp; <span class="keyword">self</span>.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; <span class="keyword">self</span>.session.configuration.identifier) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> attempts = <span class="number">0</span>; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123;</span><br><span class="line">            uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromFile:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建关联的delegate并添加到字典中</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromData:(<span class="built_in">NSData</span> *)bodyData</span><br><span class="line">                                         progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromData:bodyData];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                 progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                        completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithStreamedRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//创建下载任务，同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                             progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                          destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                    completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        downloadTask = [<span class="keyword">self</span>.session downloadTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建下载任务，同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData</span><br><span class="line">                                                progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                             destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                       completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        downloadTask = [<span class="keyword">self</span>.session downloadTaskWithResumeData:resumeData];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法就是AFURLSessionManager为我们提供的获取NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask的方法，上面这些方法主要目的就是传入进度或完成回调块，然后构造一个AFURLSessionManagerTaskDeleagte对象并关联，这样就不需要开发者自行实现和管理代理方法做相关数据处理，只需要在回调块中做处理即可。</p><p>接下来源码中是一系列回调块的setter方法，就不列下来了，读者可以自己看看。接下来就讲解重点的各种代理的回调方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//session无效后的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果回调块存在就执行回调块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送对应通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到服务端的challenge，例如https需要验证证书等</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有对应回调块就执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//处理https</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个方法是NSURLSessionDelegate的方法，关于验证HTTPS的部分代码可以当做模板代码来写，具体内容不是本文讲解范畴，读者可自行查阅。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要执行重定向的代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">        newRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//套路就是执行用户自定义的回调块，执行完成回调块</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        redirectRequest = <span class="keyword">self</span>.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同前面一样，处理https链接</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理需要一个新的流</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line"> needNewBodyStream:(<span class="keyword">void</span> (^)(<span class="built_in">NSInputStream</span> *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用用户自定义的回调块来获取，或者copy一个</span></span><br><span class="line">    <span class="built_in">NSInputStream</span> *inputStream = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = <span class="keyword">self</span>.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">NSCopying</span>)]) </span>&#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上传任务的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取上传的总大小，如果数据不正确就从http首部中获取</span></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">if</span>(totalUnitCount == <span class="built_in">NSURLSessionTransferSizeUnknown</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *contentLength = [task.originalRequest valueForHTTPHeaderField:<span class="string">@"Content-Length"</span>];</span><br><span class="line">        <span class="keyword">if</span>(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取task关联的AFURLSessionManagerTaskDelegate对象</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line">    <span class="comment">//如果代理对象存在，就调用代理对象的这个方法</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果用户自定义回调块存在，执行回调块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidSendBodyData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务完成的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//同样的套路，获取关联的代理对象，手动调用代理对象的这个方法，执行用户自定义的回调块</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是NSURLSessionTaskDelegate的回调方法，通过上面的代码可以发现AFURLSessionManagerTaskDelegate的作用了，AFURLSessionManager的代理方法中会根据task获取到对应的delegate，如果需要提前处理一些数据就先处理，处理完成后手动触发delegate中的对应方法，然后具体的数据处理就交由AFURLSessionManagerTaskDelegate来处理。继续看其他代理方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务端响应的代理回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用用户自定义回调块，执行完成回调块</span></span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:dataTask];</span><br><span class="line">        [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取代理，然后调用代理的这个方法，有自定义回调块就执行</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = <span class="keyword">self</span>.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是NSURLSessionDataDelegate的代理方法，同样的，如果AFURLSessionManagerTaskDelegate能响应的关于数据处理的方法都会通过task找到对应delegate后调用其对应的方法，然后执行用户自定义的回调块，如果代理不能响应的方法就由AFURLSessionManager自行处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载任务下载文件完成后的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取对应的代理对象</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//如果downloadTaskDidFinishDownloading回调块存在就执行它来获取一个保存文件的URL路径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *fileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="comment">//如果这个路径存在就通过NSFileManager来移动，移动失败发送通知</span></span><br><span class="line">        <span class="keyword">if</span> (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过task获取delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//如果delegate存在就调用其该方法</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果回调块存在就执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidWriteData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上套路</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidResume) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在为止，AFURLSessionManager所有源码都看完了，代码封装了NSURLSession并提供了简洁的创建NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask对象的方法，使用人员可以不需要考虑具体的数据处理过程，最简单的可以只通过回调块来获取网络请求的各种信息。在具体实现上，AFURLSessionManager通过定义AFURLSessionManagerTaskDelegate来做具体task的数据处理，而AFURLSessionManager只关注于通用部分的实现，并提供各种方法和回调块用于处理task，使得代码结构更清晰，AFURLSessionManager代理方法结构也更简单。</p><p>AFURLSessionManager个人总结</p><ol><li>AFURLSessionManagerTaskDelegate 是为了对应每一个task，单独定义一个类，解耦合，代码逻辑更清晰</li><li>mutableData 在请求完成之后置位 nil，节省内存</li><li>dispatch_semaphore的使用，信号量线程同步</li><li>method swizzing巧妙监听 task 的 suspend 和 resume</li><li>NSLock 安全加锁，避免字典中假如的 delegate 和 task不对应</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://nixzhang5.github.io/categories/iOS/"/>
    
    
      <category term="AFNetWorking原理" scheme="https://nixzhang5.github.io/tags/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Github Blog With Hexo</title>
    <link href="https://nixzhang5.github.io/hello-world.html"/>
    <id>https://nixzhang5.github.io/hello-world.html</id>
    <published>2019-06-21T07:40:42.265Z</published>
    <updated>2019-06-24T10:16:01.754Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://nixzhang5.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://nixzhang5.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
