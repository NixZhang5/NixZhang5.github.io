<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinping&#39;s Blog</title>
  
  <subtitle>因为有了危机感，所以才会义无反顾。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-27T02:16:48.499Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张新平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>App签名原理</title>
    <link href="http://yoursite.com/2019/06/26/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/26/App签名原理/</id>
    <published>2019-06-26T03:29:11.000Z</published>
    <updated>2019-06-27T02:16:48.499Z</updated>
    
    <content type="html"><![CDATA[<p>App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。</p><a id="more"></a><p>苹果签名需求：</p><ul><li>为了保证系统的安全性，所有iPhone上安装的应用必须是经过苹果授权的</li><li>安装包不需要上传到App Store也能被安装 （开发调试 企业灰度）</li><li>防止证书权限滥用：设备限制、指定APP、iCloud/PUSH/后台运行等附加权限控制</li></ul><h3 id="下载App签名"><a href="#下载App签名" class="headerlink" title="下载App签名"></a>下载App签名</h3><p>签名原理：</p><ol><li>App上传到App Store时，苹果公司拿到App的HASH(MD5,SHA等)值，然后用私钥进行加密(签名)，这时候只有手机上的公钥才可以解密；</li><li>手机下载应用安装App时，先用公钥解密(验证签名)，拿到HASH值，然后将此HASH值，与要安装的App的HASH值进行校验，如果App有被修改过，则校验失败。这样就可以有效的保证每个App都是经过苹果公司官方认证的。</li></ol><h3 id="双层签名"><a href="#双层签名" class="headerlink" title="双层签名"></a>双层签名</h3><p>真机调试，企业包上面的签名方式就不适合了。这时候需要双层签名：</p><ol><li>在Mac系统中生成一对非对称加密算法的公私钥M（keychain 里的 <code>从证书颁发机构请求证书</code>，保存的CertificateSigningRequest就包含公钥M，私钥保存在本地）。</li><li>苹果自己有固定的一对公私钥：私钥A在苹果后台，公钥A在每个iOS系统的手机中。</li><li>申请证书，把CertificateSigningRequest.certSigningRequest文件（包含公钥M，以及一些开发者信息）发送给苹果后台，用苹果后台的私钥A对公钥M签名，得到一份包含公钥M以及其签名结果的数据就是证书。<ul><li>生成的证书下载下来，keychain会把这两个证书关联起来，因为公私钥是对应的。这个私钥只有这台电脑有，团队开发需要把这个私钥导出.p12给其他Mac.</li></ul></li><li>配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件（包含设备IDs,AppID,Entitlements(权力文件包含是否可调试，推送，后台运行等信息)）。</li><li>XCode 会通过第3步下载回来的证书（存着公钥），在本地找到对应的私钥（第1步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。<ul><li>打包过程用私钥M对App的HASH值进行加密(签名)，这时的APP内部实际包含了APP的签名(私钥M加密App的HASH值)、第3步生成的证书文件(包含公钥M和公钥M的HASH值)、Provision Profile(描述文件)，App可执行文件以及其他信息</li></ul></li><li>解密：<ol><li>iPhone手机拿到证书文件(包含公钥M和公钥M的HASH值)，因为手机里有公钥A，所以能解密证书文件，得到公钥M和公钥M的HASH值，先验证公钥M生成的HASH值(MD5,SHA等)是不是和证书文件里的公钥M的HASH值一致，确保证书没有被修改；</li><li>验证一致后，就可以用公钥M来解密第2步的APP的签名，同样道理可以验证App是否被修改过。 因为在开发阶段App会经常修改，所以App就算是修改过，也能安装。第4步主要是验证证书是不是苹果认证的，只要证书对就可以安装运行。</li></ol></li></ol><p>加密解密：</p><ul><li>mac电脑：私钥M和公钥M(电脑生成)</li><li>苹果服务器：私钥A</li><li>iPhone手机：公钥A</li></ul><p>.ipa包含的信息：</p><ol><li>资源文件，例如图片、html、等等。</li><li>_CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。</li><li>可执行文件。此文件跟资源文件一样需要签名。</li><li>一个mobileprovision文件.打包的时候使用的，从MC上生成的。</li><li>Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件。</li></ol><h3 id="签名原理图："><a href="#签名原理图：" class="headerlink" title="签名原理图："></a>签名原理图：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//yoursite.com/2019/06/26/App签名原理/sign.png" alt="sign" title>                </div>                <div class="image-caption">sign</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Encryption" scheme="http://yoursite.com/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>加密</title>
    <link href="http://yoursite.com/2019/06/26/%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2019/06/26/加密/</id>
    <published>2019-06-26T02:27:44.000Z</published>
    <updated>2019-06-26T03:25:10.730Z</updated>
    
    <content type="html"><![CDATA[<p>加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。</p><a id="more"></a><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。</p><ul><li>优点<br>简单快捷，密钥较短，且破译困难。</li><li>缺点<br>如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通的两个用户之间怎么确定密钥也需要考虑，这其中就会有密钥泄露的风险，以及存在更换密钥的需求。</li></ul><p>对称加密通常有 AES, DES, IDEA, 3DES 加密算法。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。</p><ul><li>缺点<br>加解密比对称加密耗时.</li><li>优点<br>比对称加密安全.</li></ul><p>但是非对称加密也是存在漏洞，因为公钥是公开的，如果有 C 冒充 B 的身份利用 A 的公钥给 A 发消息，这样就乱套了，所以接下来就采用<code>非对称加密+摘要算法+数字签名的机制</code>来确保传输安全。</p><p>常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h3 id="Hash算法（摘要算法）"><a href="#Hash算法（摘要算法）" class="headerlink" title="Hash算法（摘要算法）"></a>Hash算法（摘要算法）</h3><p>Hash算法的特点是单向不可还原，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。只要源数据不同，算法得到的摘要必定不同。</p><p>常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。</p><p>数字签名是 A将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要一起发送给B；B接收到后解密，得到这个摘要 a 和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要 b，比较 a 与 b 就可得知在传输过程中是否被更改过。</p><p>因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。</p><h3 id="完整的非对称加密过程"><a href="#完整的非对称加密过程" class="headerlink" title="完整的非对称加密过程"></a>完整的非对称加密过程</h3><p>假如现在 你向支付宝 转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为：</p><ol><li>首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息，</li><li>你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等；</li><li>你 对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）；</li><li>你 用自己的私钥对信息摘要进行加密得到 你 的数字签名，并将其附在数字信息上；</li><li>你 随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）；</li><li>你用 支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝；</li><li>支付宝收到 你 传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到 你随机产生的加密密钥；</li><li>支付宝 然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃；</li><li>支付宝 用你 的公钥对 你的的数字签名进行解密，得到信息摘要；</li><li>支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要；</li><li>支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。</li><li>确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。在这后面的流程就不属于本次非对称加密的范畴，算支付宝个人的自我流程，也就是循环以上过程。</li></ol><h3 id="iOS常用的加密方式"><a href="#iOS常用的加密方式" class="headerlink" title="iOS常用的加密方式"></a>iOS常用的加密方式</h3><p>Base64加密、MD5加密、AES加密、RSA加密</p><h4 id="Base64加密"><a href="#Base64加密" class="headerlink" title="Base64加密"></a>Base64加密</h4><p>Base64编码的思想是：采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组，以3个字节为一组，按顺序排列24位数据，再把这24位数据分成4组，即每组6位；再在每组的的最高位前补两个0凑足一个字节，这样就把一个3字节为一组的数据重新编码成了4个字节；当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节，这时在最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。例如：将对ABC进行Base64编码首先取ABC对应的ASCII码值，A : 65、B : 66、C : 67，再取二进制值A : 01000001、B : 01000010、C : 01000011，然后把这三个字节的二进制码接起来010000010100001001000011，再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值00010000、00010100、00001001、00000011；再把这4个字节数据转化成10进制数得16、20、19、3；最后根据Base64给出的64个基本字符表，查出对应的ASCII码字符Q、U、J、D，这里的值实际就是数据在字符表中的索引。解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。注：Base64字符表，包括大写A-Z小写a-z数字0-9和+以及/。<br>Base64加密原则：6bit（原8bit）一个字节，不足的位数用0补齐，两个0用一个=表示。<br>Base64加密特点：</p><ul><li>数据加密之后，数据量会变大，变大1/3左右。</li><li>可进行反向解密。</li><li>编码后有个非常显著的特点，末尾有个=号。</li></ul><p>其实Base64不算是加密，只是一种编码格式。</p><p>在iOS中Base64加解密使用方法介绍（本例使用系统API，仅支持iOS7及以后的系统版本）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************Base64.m类实现文件内容****************************/</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)base64EncodedStringWithData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否传入需要加密数据参数</span></span><br><span class="line">    <span class="keyword">if</span> ((data == <span class="literal">nil</span>) || (data == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![data isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断设备系统是否满足条件</span></span><br><span class="line">    <span class="keyword">if</span> ([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] doubleValue] &lt;= <span class="number">6.9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用系统的API进行Base64加密操作</span></span><br><span class="line">    <span class="built_in">NSDataBase64EncodingOptions</span> options;</span><br><span class="line">    options = <span class="built_in">NSDataBase64EncodingEndLineWithLineFeed</span>;</span><br><span class="line">    <span class="keyword">return</span> [data base64EncodedStringWithOptions:options];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)base64DecodeDataWithString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否传入需要加密数据参数</span></span><br><span class="line">    <span class="keyword">if</span> ((string == <span class="literal">nil</span>) || (string == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![string isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断设备系统是否满足条件</span></span><br><span class="line">    <span class="keyword">if</span> ([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] doubleValue] &lt;= <span class="number">6.9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用系统的API进行Base64解密操作</span></span><br><span class="line">    <span class="built_in">NSDataBase64DecodingOptions</span> options;</span><br><span class="line">    options = <span class="built_in">NSDataBase64DecodingIgnoreUnknownCharacters</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSData</span> alloc] initWithBase64EncodedString:string options:options];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Base64文件进行Base64加密和解密</span></span><br><span class="line"><span class="comment">/*********************************使用Base64类*********************************/</span></span><br><span class="line"><span class="comment">//使用Base64执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSString</span> *encodeString = [Base64 base64EncodedStringWithData:data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeString : %@"</span>, encodeString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Base64执行解密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *decodeString = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSData</span> *decodeData = [Base64 base64DecodeDataWithString:encodeString];</span><br><span class="line">decodeString = [[<span class="built_in">NSString</span> alloc] initWithData:decodeData</span><br><span class="line">                                     encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"decodeString : %@"</span>, decodeString);</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br></pre></td></tr></table></figure><h4 id="MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）"><a href="#MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）" class="headerlink" title="MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）"></a>MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）</h4><p>MD5的全称是Message-DigestAlgorithm 5，Message-Digest泛指字节串(Message)的Hash变换，就是把一个任意长度的字节串变换成一定长的大整数。请注意我使用了字节串而不是字符串这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的字节串变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被”篡改”。举个例子，你将一段话写在一个叫readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的”抵赖”，这就是所谓的数字签名应用。MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的，用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并”不知道”用户的密码是什么。MD5加密大体都应用在：验证数据或文件一致性、数字签名、安全访问认证等等。大概可比喻为：人的指纹来理解。<br>注：MD5加密是不可逆的，也就是说，MD5加密后是不能解密的，所谓的解密只是用大数据的”试用”，来测出结果的。<br>MD5特点:</p><ul><li>压缩性 : 任意长度的数据,算出的MD5值长度都是固定的。</li><li>容易计算 : 从原数据计算出MD5值很容易。</li><li>抗修改性 : 对原数据进行任何改动，哪怕只修改一个字节，所得到的MD5值都有很大区别。</li><li>弱抗碰撞 : 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li><li>强抗碰撞 : 想找到两个不同数据，使他们具有相同的MD5值，是非常困难的。</li></ul><p>在iOS中MD5加密和验签使用方法介绍</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************MD5.m类实现文件内容****************************/</span></span><br><span class="line"><span class="comment">//对字符串数据进行MD5的签名</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)md5SignWithString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *object = [string UTF8String];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> result[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(object,(CC_LONG)strlen(object),result);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *hash = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">        [hash appendFormat:<span class="string">@"%02X"</span>, result[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [hash lowercaseString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对二进制数据进行MD5的签名</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)md5SignWithData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    Byte byte[CC_MD5_DIGEST_LENGTH];    <span class="comment">//定义一个字节数组来接收结果</span></span><br><span class="line">    CC_MD5((<span class="keyword">const</span> <span class="keyword">void</span>*)([data bytes]), (CC_LONG)[data length], byte);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:byte length:CC_MD5_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用MD5文件进行MD5加密和验签</span></span><br><span class="line"><span class="comment">/*********************************使用MD5类*********************************/</span></span><br><span class="line"><span class="comment">//使用MD5执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *string2 = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *encodeString2 = [MD5 md5SignWithString:string2];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeString2 : %@"</span>, encodeString2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//MD5为不可逆的操作，使用MD5执行验签操作</span></span><br><span class="line"><span class="built_in">NSString</span> *verifyString2 = [MD5 md5SignWithString:string2];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"verifyString2 : %@"</span>, verifyString2);</span><br><span class="line"><span class="keyword">if</span> ([verifyString2 isEqualToString:encodeString2]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"md5 verify sign success"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"md5 verify sign failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br></pre></td></tr></table></figure><h4 id="AES加密（对称加密的一种）"><a href="#AES加密（对称加密的一种）" class="headerlink" title="AES加密（对称加密的一种）"></a>AES加密（对称加密的一种）</h4><p>高级加密标准Advanced Encryption Standard简称：AES，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。它是一种对称加密算法，这个标准也替代原先的DES标准，已经被多方分析且广为全世界所使用。AES设计有三个密钥长度:128、192、256位，相对而言，AES的128密钥比DES的56密钥强1021倍。AES算法主要包括三个方面：轮变化、圈数和密钥扩展。总体来说，AES作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活，在软件及硬件上都能快速地加解密且只需要很少的存储资源等优点。</p><p>AES加解密特点：</p><ul><li>AES强安全性、高性能、高效率、易用和灵活。</li><li>在软件及硬件上都能快速地加解密且只需要很少的存储资源。</li></ul><p>AES加密需要的参数：</p><ul><li><strong>密钥长度（Key Size）</strong><br>AES算法下，key的长度有三种：128、192和256 bits。由于历史原因，JDK默认只支持不大于128 bits的密钥，而128 bits的key已能够满足商用安全需求。因此本例先使用AES-128。（Java使用大于128 bits的key方法在文末提及）</li><li><strong>加密模式（Cipher Mode）</strong><br>AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。本例统一使用CBC模式。</li><li><strong>填充方式（Padding）</strong><br>由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）<br>在iOS SDK中提供了PKCS7Padding，而JDK则提供了PKCS5Padding。原则上PKCS5Padding限制了填充的Block Size为8 bytes，而Java实际上当块大于该值时，其PKCS5Padding与PKCS7Padding是相等的：每需要填充χ个字节，填充的值就是χ。</li><li><strong>初始向量（Initialization Vector）</strong><br>使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等（AES的Block Size为128 bits），而两个平台的API文档均指明当不传入初始向量时，系统将默认使用一个全0的初始向量。<br>有了上述的基础之后，可以开始分别在两个平台进行实现了。</li></ul><p>在iOS中AES加解密的实现介绍</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要导入：#import &lt;CommonCrypto/CommonCrypto.h&gt;库才能使用</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  AES128 + ECB + PKCS7</span></span><br><span class="line"><span class="comment"> *  @param data 要加密的原始数据</span></span><br><span class="line"><span class="comment"> *  @param key  加密 key</span></span><br><span class="line"><span class="comment"> *  @return  加密后数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)encryptData:(<span class="built_in">NSData</span> *)data key:(<span class="built_in">NSData</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断解密的流数据是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((data == <span class="literal">nil</span>) || (data == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![data isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([data length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断解密的Key是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((key == <span class="literal">nil</span>) || (key == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![key isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([key length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup key</span></span><br><span class="line">    <span class="built_in">NSData</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> cKey[kCCKeySizeAES128];</span><br><span class="line">    bzero(cKey, <span class="keyword">sizeof</span>(cKey));</span><br><span class="line">    [key getBytes:cKey length:kCCKeySizeAES128];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup output buffer</span></span><br><span class="line">    size_t bufferSize = [data length] + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do encrypt</span></span><br><span class="line">    size_t encryptedSize = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES128,</span><br><span class="line">                                          kCCOptionECBMode|kCCOptionPKCS7Padding,</span><br><span class="line">                                          cKey,</span><br><span class="line">                                          kCCKeySizeAES128,</span><br><span class="line">                                          <span class="literal">nil</span>,</span><br><span class="line">                                          [data bytes],</span><br><span class="line">                                          [data length],</span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize,</span><br><span class="line">                                          &amp;encryptedSize);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        result = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:encryptedSize];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  AES128 + ECB + PKCS7</span></span><br><span class="line"><span class="comment"> *  @param data 要解密的原始数据</span></span><br><span class="line"><span class="comment"> *  @param key  解密 key</span></span><br><span class="line"><span class="comment"> *  @return  解密后数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)decryptData:(<span class="built_in">NSData</span> *)data key:(<span class="built_in">NSData</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断解密的流数据是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((data == <span class="literal">nil</span>) || (data == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![data isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([data length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断解密的Key是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((key == <span class="literal">nil</span>) || (key == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![key isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([key length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup key</span></span><br><span class="line">    <span class="built_in">NSData</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> cKey[kCCKeySizeAES128];</span><br><span class="line">    bzero(cKey, <span class="keyword">sizeof</span>(cKey));</span><br><span class="line">    [key getBytes:cKey length:kCCKeySizeAES128];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup output buffer</span></span><br><span class="line">    size_t bufferSize = [data length] + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do decrypt</span></span><br><span class="line">    size_t decryptedSize = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES128,</span><br><span class="line">                                          kCCOptionECBMode|kCCOptionPKCS7Padding,</span><br><span class="line">                                          cKey,</span><br><span class="line">                                          kCCKeySizeAES128,</span><br><span class="line">                                          <span class="literal">nil</span>,</span><br><span class="line">                                          [data bytes],</span><br><span class="line">                                          [data length],</span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize,</span><br><span class="line">                                          &amp;decryptedSize);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        result = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:decryptedSize];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在iOS中AES加解密使用方法介绍</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用AES执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *aesKey = <span class="string">@"a1b2c3d4e5f6g7h8"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string3 = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *keyData3 = [aesKey dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *sourceData3 = [string3 dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *encodeData3 = [AESEncrypt encryptData:sourceData3 key:keyData3];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeData3 : %@"</span>, encodeData3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用AES执行解密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *decodeString3 = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSData</span> *decodeData3 = [AESEncrypt decryptData:encodeData3</span><br><span class="line">                                          key:keyData3];</span><br><span class="line">decodeString3 = [[<span class="built_in">NSString</span> alloc] initWithData:decodeData3</span><br><span class="line">                                      encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"decodeString3 : %@"</span>, decodeString3);</span><br></pre></td></tr></table></figure><h4 id="RSA加密（非对称加密的一种）"><a href="#RSA加密（非对称加密的一种）" class="headerlink" title="RSA加密（非对称加密的一种）"></a>RSA加密（非对称加密的一种）</h4><p>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要，对方收到信息后，用不同的密钥解密并可核对信息摘要。RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作，RSA是被研究得最广泛的公钥算法。RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。RSA加密大体都应用在：本地数据加密、网络传输数据加密、方法体和方法名高级混淆以及程序结构混排加密。例如：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取。</p><p>RSA的算法涉及三个参数，n、e1、e2。其中，n是两个大质数p、q的积，n的二进制表示时所占用的位数，就是所谓的密钥长度。e1和e2是一对相关的值，e1可以任意取，但要求e1与(p-1)(q-1)互质；再选择e2，要求(e2e1)mod((p-1)*(q-1))=1。(n，e1)，(n，e2)就是密钥对。其中(n，e1)为公钥，(n，e2)为私钥；RSA加解密的算法完全相同，公钥加密体制中，一般用公钥加密，私钥解密。假设A为明文，B为密文，则：A=B^e2 mod n；B=A^e1 mod n；e1和e2可以互换使用，即私钥加密，公钥解密，公式：A=B^e1 mod n；B=A^e2 mod n;</p><p>RSA加解密特点：</p><ul><li>RSA密钥管理的方便，计算量很大速度相对比较慢。</li><li>RSA安全性很高，能够抵抗到目前为止已知的绝大多数密码攻击。<br>在线生成RSA密钥对的网址：在线生成非对称加密公钥私钥对等，RSA密钥格式请使用PKCS#8格式。PKCS#1与PKCS#8的区别还待后续查阅资料，再进行补充记录。</li></ul><p>在iOS中RSA加解密的实现介绍（支持密钥文件&lt;.pem&gt;和字符串密钥）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************RSAEncrypt.m类实现文件内容****************************/</span></span><br><span class="line"><span class="meta">#pragma mark - Class Utils Method</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isEmptyKeyRef:(<span class="keyword">id</span>)object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object == [<span class="built_in">NSNull</span> null]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private Method</span></span><br><span class="line">+ (SecKeyRef)getPrivateKeyRefWithFilePath:(<span class="built_in">NSString</span> *)filePath keyPassword:(<span class="built_in">NSString</span> *)keyPassword</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取私钥证书文件的内容</span></span><br><span class="line">    <span class="built_in">NSData</span> *certificateData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">    <span class="keyword">if</span> ((certificateData == <span class="literal">nil</span>) || (certificateData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![certificateData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([certificateData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拼接密码参数到字典中</span></span><br><span class="line">    <span class="built_in">NSString</span> *passwordKey = (__bridge <span class="keyword">id</span>)kSecImportExportPassphrase;</span><br><span class="line">    <span class="built_in">NSString</span> *passwordValue = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,keyPassword];</span><br><span class="line">    <span class="keyword">if</span> ((keyPassword == <span class="literal">nil</span>) || (keyPassword == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        passwordValue = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![keyPassword isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        passwordValue = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPassword length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        passwordValue = <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *optionInfo = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [optionInfo setObject:passwordValue forKey:passwordKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取私钥对象</span></span><br><span class="line">    SecKeyRef privateKeyRef = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFArrayRef</span> items = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CFDataRef</span> pkcs12Data = (__bridge <span class="built_in">CFDataRef</span>)certificateData;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> options = (__bridge <span class="built_in">CFDictionaryRef</span>)optionInfo;</span><br><span class="line">    OSStatus securityStatus = SecPKCS12Import(pkcs12Data, options, &amp;items);</span><br><span class="line">    <span class="keyword">if</span> (securityStatus == noErr &amp;&amp; <span class="built_in">CFArrayGetCount</span>(items) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SecIdentityRef identity;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *secpkey = kSecImportItemIdentity;</span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> identityDict = <span class="built_in">CFArrayGetValueAtIndex</span>(items, <span class="number">0</span>);</span><br><span class="line">        identity = (SecIdentityRef)<span class="built_in">CFDictionaryGetValue</span>(identityDict,secpkey);</span><br><span class="line">        securityStatus = SecIdentityCopyPrivateKey(identity, &amp;privateKeyRef);</span><br><span class="line">        <span class="keyword">if</span> (securityStatus != noErr)</span><br><span class="line">        &#123;</span><br><span class="line">            privateKeyRef = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(items);</span><br><span class="line">    <span class="keyword">return</span> privateKeyRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SecKeyRef)privateKeyRefWithPrivateKey:(<span class="built_in">NSString</span> *)privateKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((privateKey == <span class="literal">nil</span>) || (privateKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析私钥对象内容</span></span><br><span class="line">    <span class="built_in">NSString</span> *pKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,privateKey];</span><br><span class="line">    <span class="built_in">NSRange</span> sposition = [pKey rangeOfString:<span class="string">@"-----BEGIN RSA PRIVATE KEY-----"</span>];</span><br><span class="line">    <span class="built_in">NSRange</span> eposition = [pKey rangeOfString:<span class="string">@"-----END RSA PRIVATE KEY-----"</span>];</span><br><span class="line">    <span class="keyword">if</span> (sposition.location != <span class="built_in">NSNotFound</span> &amp;&amp; eposition.location != <span class="built_in">NSNotFound</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> endposition = eposition.location;</span><br><span class="line">        <span class="built_in">NSUInteger</span> startposition = sposition.location + sposition.length;</span><br><span class="line">        <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(startposition, endposition-startposition);</span><br><span class="line">        pKey = [pKey substringWithRange:range];</span><br><span class="line">    &#125;</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\r"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\n"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\t"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@" "</span>  withString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//This will be base64 encoded, decode it.</span></span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [Base64 base64DecodeDataWithString:pKey];</span><br><span class="line">    keyData = [<span class="keyword">self</span> stripPrivateKeyHeader:keyData];</span><br><span class="line">    <span class="keyword">if</span> ((keyData == <span class="literal">nil</span>) || (keyData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![keyData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a tag to read/write keychain storage</span></span><br><span class="line">    <span class="built_in">NSString</span> *tag = <span class="string">@"RSAUtil_PrivKey"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *bytes = [tag UTF8String];</span><br><span class="line">    <span class="built_in">NSData</span> *tagData = [<span class="built_in">NSData</span> dataWithBytes:bytes length:[tag length]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Delete any old lingering key with the same tag</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attributes = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecClassKey</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecClass];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    [attributes setObject:tagData</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrApplicationTag];</span><br><span class="line">    SecItemDelete((__bridge <span class="built_in">CFDictionaryRef</span>)attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add persistent version of the key to system keychain</span></span><br><span class="line">    [attributes setObject:keyData forKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyClassPrivate</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyClass];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    </span><br><span class="line">    OSStatus status = noErr;</span><br><span class="line">    <span class="built_in">CFTypeRef</span> persistKey = <span class="literal">nil</span>;</span><br><span class="line">    status = SecItemAdd((__bridge <span class="built_in">CFDictionaryRef</span>)attributes, &amp;persistKey);</span><br><span class="line">    <span class="keyword">if</span> (persistKey != <span class="literal">nil</span>) &#123;<span class="built_in">CFRelease</span>(persistKey);&#125;</span><br><span class="line">    <span class="keyword">if</span> ((status != noErr) &amp;&amp; (status != errSecDuplicateItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnRef];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now fetch the SecKeyRef version of the key</span></span><br><span class="line">    SecKeyRef keyRef = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> query = (__bridge <span class="built_in">CFDictionaryRef</span>)attributes;</span><br><span class="line">    status = SecItemCopyMatching(query, (<span class="built_in">CFTypeRef</span> *)&amp;keyRef);</span><br><span class="line">    <span class="keyword">if</span> (status != noErr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)stripPrivateKeyHeader:(<span class="built_in">NSData</span> *)d_key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Skip ASN.1 private key header</span></span><br><span class="line">    <span class="keyword">if</span> (d_key == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = [d_key length];</span><br><span class="line">    <span class="keyword">if</span> (!len) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *c_key = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)[d_key bytes];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = <span class="number">22</span>; <span class="comment">//magic byte at offset 22</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x04</span> != c_key[idx++]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//calculate length of the key</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> c_len = c_key[idx++];</span><br><span class="line">    <span class="keyword">if</span> (!(c_len &amp; <span class="number">0x80</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        c_len = c_len &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> byteCount = c_len &amp; <span class="number">0x7f</span>;</span><br><span class="line">        <span class="keyword">if</span> (byteCount + idx &gt; len) &#123;</span><br><span class="line">            <span class="comment">//rsa length field longer than buffer</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> accum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = &amp;c_key[idx];</span><br><span class="line">        idx += byteCount;</span><br><span class="line">        <span class="keyword">while</span> (byteCount) &#123;</span><br><span class="line">            accum = (accum &lt;&lt; <span class="number">8</span>) + *ptr;</span><br><span class="line">            ptr++;</span><br><span class="line">            byteCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        c_len = accum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now make a new NSData from this buffer</span></span><br><span class="line">    <span class="keyword">return</span> [d_key subdataWithRange:<span class="built_in">NSMakeRange</span>(idx, c_len)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SecKeyRef)getPublicKeyRefWithFilePath:(<span class="built_in">NSString</span> *)filePath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取公钥证书文件的内容</span></span><br><span class="line">    <span class="built_in">NSData</span> *certificateData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">    <span class="keyword">if</span> ((certificateData == <span class="literal">nil</span>) || (certificateData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![certificateData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([certificateData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将公钥证书制作成证书对象</span></span><br><span class="line">    <span class="built_in">CFDataRef</span> data = (__bridge <span class="built_in">CFDataRef</span>)certificateData;</span><br><span class="line">    SecCertificateRef certificateRef = SecCertificateCreateWithData(<span class="literal">NULL</span>, data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取公钥对象</span></span><br><span class="line">    SecTrustRef trust = <span class="literal">NULL</span>;</span><br><span class="line">    SecKeyRef publicKey = <span class="literal">NULL</span>;</span><br><span class="line">    SecPolicyRef policies = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="keyword">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(certificateRef)]</span><br><span class="line">        &amp;&amp; ![[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(policies)])</span><br><span class="line">    &#123;</span><br><span class="line">        OSStatus status;</span><br><span class="line">        status = SecTrustCreateWithCertificates((<span class="built_in">CFTypeRef</span>)certificateRef,</span><br><span class="line">                                                policies, &amp;trust);</span><br><span class="line">        <span class="keyword">if</span> (status == noErr)</span><br><span class="line">        &#123;</span><br><span class="line">            SecTrustResultType result;</span><br><span class="line">            <span class="keyword">if</span> (SecTrustEvaluate(trust, &amp;result) == noErr)</span><br><span class="line">            &#123;</span><br><span class="line">                publicKey = SecTrustCopyPublicKey(trust);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (certificateRef != <span class="literal">NULL</span>) <span class="built_in">CFRelease</span>(certificateRef);</span><br><span class="line">    <span class="keyword">if</span> (policies != <span class="literal">NULL</span>) <span class="built_in">CFRelease</span>(policies);</span><br><span class="line">    <span class="keyword">if</span> (trust != <span class="literal">NULL</span>) <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">    <span class="keyword">return</span> publicKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SecKeyRef)publicKeyRefWithPublicKey:(<span class="built_in">NSString</span> *)publicKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKey == <span class="literal">nil</span>) || (publicKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析公钥对象内容</span></span><br><span class="line">    <span class="built_in">NSString</span> *pKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,publicKey];</span><br><span class="line">    <span class="built_in">NSRange</span> sposition = [pKey rangeOfString:<span class="string">@"-----BEGIN PUBLIC KEY-----"</span>];</span><br><span class="line">    <span class="built_in">NSRange</span> eposition = [pKey rangeOfString:<span class="string">@"-----END PUBLIC KEY-----"</span>];</span><br><span class="line">    <span class="keyword">if</span> (sposition.location != <span class="built_in">NSNotFound</span> &amp;&amp; eposition.location != <span class="built_in">NSNotFound</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> startposition = eposition.location;</span><br><span class="line">        <span class="built_in">NSUInteger</span> endposition = sposition.location + sposition.length;</span><br><span class="line">        <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(endposition, startposition-endposition);</span><br><span class="line">        pKey = [pKey substringWithRange:range];</span><br><span class="line">    &#125;</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\r"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\n"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@"\t"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    pKey = [pKey stringByReplacingOccurrencesOfString:<span class="string">@" "</span>  withString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//This will be base64 encoded, decode it.</span></span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [[<span class="keyword">self</span> <span class="keyword">class</span>] base64DecodeDataWithString:pKey];</span><br><span class="line">    keyData = [<span class="keyword">self</span> stripPublicKeyHeader:keyData];</span><br><span class="line">    <span class="keyword">if</span> ((keyData == <span class="literal">nil</span>) || (keyData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![keyData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a tag to read/write keychain storage</span></span><br><span class="line">    <span class="built_in">NSString</span> *tag = <span class="string">@"RSAUtil_PubKey"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *bytes = [tag UTF8String];</span><br><span class="line">    <span class="built_in">NSData</span> *tagData = [<span class="built_in">NSData</span> dataWithBytes:bytes length:[tag length]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Delete any old lingering key with the same tag</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attributes = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecClassKey</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecClass];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    [attributes setObject:tagData</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrApplicationTag];</span><br><span class="line">    SecItemDelete((__bridge <span class="built_in">CFDictionaryRef</span>)attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add persistent version of the key to system keychain</span></span><br><span class="line">    [attributes setObject:keyData</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyClassPublic</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyClass];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    </span><br><span class="line">    OSStatus status = noErr;</span><br><span class="line">    <span class="built_in">CFTypeRef</span> persistKey = <span class="literal">nil</span>;</span><br><span class="line">    status = SecItemAdd((__bridge <span class="built_in">CFDictionaryRef</span>)attributes, &amp;persistKey);</span><br><span class="line">    <span class="keyword">if</span> (persistKey != <span class="literal">nil</span>) <span class="built_in">CFRelease</span>(persistKey);</span><br><span class="line">    <span class="keyword">if</span> ((status != noErr) &amp;&amp; (status != errSecDuplicateItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecValueData];</span><br><span class="line">    [attributes removeObjectForKey:(__bridge <span class="keyword">id</span>)kSecReturnPersistentRef];</span><br><span class="line">    [attributes setObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>]</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecReturnRef];</span><br><span class="line">    [attributes setObject:(__bridge <span class="keyword">id</span>)kSecAttrKeyTypeRSA</span><br><span class="line">                   forKey:(__bridge <span class="keyword">id</span>)kSecAttrKeyType];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now fetch the SecKeyRef version of the key</span></span><br><span class="line">    SecKeyRef publicKeyRef = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> query = (__bridge <span class="built_in">CFDictionaryRef</span>)attributes;</span><br><span class="line">    status = SecItemCopyMatching(query, (<span class="built_in">CFTypeRef</span> *)&amp;publicKeyRef);</span><br><span class="line">    <span class="keyword">if</span> (status != noErr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> publicKeyRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)stripPublicKeyHeader:(<span class="built_in">NSData</span> *)d_key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Skip ASN.1 public key header</span></span><br><span class="line">    <span class="keyword">if</span> (d_key == <span class="literal">nil</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = [d_key length];</span><br><span class="line">    <span class="keyword">if</span> (!len) <span class="keyword">return</span>(<span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *c_key = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)[d_key bytes];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx++] != <span class="number">0x30</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx] &gt; <span class="number">0x80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx += c_key[idx] - <span class="number">0x80</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PKCS #1 rsaEncryption szOID_RSA_RSA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> seqiod[] = &#123;<span class="number">0x30</span>, <span class="number">0x0d</span>, <span class="number">0x06</span>, <span class="number">0x09</span>, <span class="number">0x2a</span>,</span><br><span class="line">        <span class="number">0x86</span>, <span class="number">0x48</span>, <span class="number">0x86</span>, <span class="number">0xf7</span>, <span class="number">0x0d</span>,</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x05</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (memcmp(&amp;c_key[idx], seqiod, <span class="number">15</span>)) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    idx += <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx++] != <span class="number">0x03</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx] &gt; <span class="number">0x80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx += c_key[idx] - <span class="number">0x80</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c_key[idx++] != <span class="string">'\0'</span>) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Now make a new NSData from this buffer</span></span><br><span class="line">    <span class="keyword">return</span> ([<span class="built_in">NSData</span> dataWithBytes:&amp;c_key[idx] length:len - idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)encryptData:(<span class="built_in">NSData</span> *)data withKeyRef:(SecKeyRef)keyRef</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> uint8_t *srcbuf = (<span class="keyword">const</span> uint8_t *)[data bytes];</span><br><span class="line">    size_t srclen = (size_t)data.length;</span><br><span class="line">    </span><br><span class="line">    size_t block_size = SecKeyGetBlockSize(keyRef) * <span class="keyword">sizeof</span>(uint8_t);</span><br><span class="line">    <span class="keyword">void</span> *outbuf = malloc(block_size);</span><br><span class="line">    size_t src_block_size = block_size - <span class="number">11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *ret = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; srclen; idx += src_block_size)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t data_len = srclen - idx;</span><br><span class="line">        <span class="keyword">if</span>(data_len &gt; src_block_size)&#123;</span><br><span class="line">            data_len = src_block_size;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size_t outlen = block_size;</span><br><span class="line">        OSStatus status = noErr;</span><br><span class="line">        status = SecKeyEncrypt(keyRef, kSecPaddingPKCS1,</span><br><span class="line">                               srcbuf + idx, data_len,</span><br><span class="line">                               outbuf, &amp;outlen);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"SecKeyEncrypt fail. Error Code: %d"</span>, (<span class="keyword">int</span>)status);</span><br><span class="line">            ret = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            [ret appendBytes:outbuf length:outlen];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(outbuf);</span><br><span class="line">    <span class="built_in">CFRelease</span>(keyRef);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)decryptData:(<span class="built_in">NSData</span> *)data withKeyRef:(SecKeyRef)keyRef</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> uint8_t *srcbuf = (<span class="keyword">const</span> uint8_t *)[data bytes];</span><br><span class="line">    size_t srclen = (size_t)data.length;</span><br><span class="line">    </span><br><span class="line">    size_t block_size = SecKeyGetBlockSize(keyRef) * <span class="keyword">sizeof</span>(uint8_t);</span><br><span class="line">    <span class="built_in">UInt8</span> *outbuf = malloc(block_size);</span><br><span class="line">    size_t src_block_size = block_size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *ret = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; srclen; idx += src_block_size)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t data_len = srclen - idx;</span><br><span class="line">        <span class="keyword">if</span>(data_len &gt; src_block_size)</span><br><span class="line">        &#123;</span><br><span class="line">            data_len = src_block_size;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size_t outlen = block_size;</span><br><span class="line">        OSStatus status = noErr;</span><br><span class="line">        status = SecKeyDecrypt(keyRef, kSecPaddingNone,</span><br><span class="line">                               srcbuf + idx, data_len,</span><br><span class="line">                               outbuf, &amp;outlen);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"SecKeyEncrypt fail. Error Code: %d"</span>, (<span class="keyword">int</span>)status);</span><br><span class="line">            ret = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> idxFirstZero = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> idxNextZero = (<span class="keyword">int</span>)outlen;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outlen; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (outbuf[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (idxFirstZero &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        idxFirstZero = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        idxNextZero = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSUInteger</span> length = idxNextZero-idxFirstZero<span class="number">-1</span>;</span><br><span class="line">            [ret appendBytes:&amp;outbuf[idxFirstZero+<span class="number">1</span>] length:length];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(outbuf);</span><br><span class="line">    <span class="built_in">CFRelease</span>(keyRef);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - RSA Key File Encrypt/Decrypt Public Method</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)encryptString:(<span class="built_in">NSString</span> *)originString publicKeyPath:(<span class="built_in">NSString</span> *)publicKeyPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断originString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((originString == <span class="literal">nil</span>) || (originString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断publicKeyPath参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKeyPath == <span class="literal">nil</span>) || (publicKeyPath == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKeyPath isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKeyPath length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取公钥对象和需要加密的字符串内容编码数据流</span></span><br><span class="line">    SecKeyRef publicKeyRef = [<span class="keyword">self</span> getPublicKeyRefWithFilePath:publicKeyPath];</span><br><span class="line">    <span class="built_in">NSData</span> *originData = [originString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(publicKeyRef)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originData == <span class="literal">nil</span>) || (originData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加密源字符串内容编码数据流的数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *resultData = <span class="literal">nil</span>;</span><br><span class="line">    resultData = [<span class="keyword">self</span> encryptData:originData withKeyRef:publicKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> <span class="keyword">class</span>] base64EncodedStringWithData:resultData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)decryptString:(<span class="built_in">NSString</span> *)encryptString privateKeyPath:(<span class="built_in">NSString</span> *)privateKeyPath privateKeyPwd:(<span class="built_in">NSString</span> *)privateKeyPwd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断encryptString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((encryptString == <span class="literal">nil</span>) || (encryptString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断publicKeyPath参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((privateKeyPath == <span class="literal">nil</span>) || (privateKeyPath == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKeyPath isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKeyPath length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断密码是否存在</span></span><br><span class="line">    <span class="built_in">NSString</span> *keyPassword = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,privateKeyPwd];</span><br><span class="line">    <span class="keyword">if</span> ((privateKeyPwd == <span class="literal">nil</span>) || (privateKeyPwd == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        keyPassword = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKeyPwd isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        keyPassword = <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKeyPwd length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        keyPassword = <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取私钥对象和需要加密的字符串内容编码数据流</span></span><br><span class="line">    <span class="built_in">NSData</span> *encryptData = <span class="literal">nil</span>, *decryptData = <span class="literal">nil</span>;</span><br><span class="line">    SecKeyRef privateKeyRef = [<span class="keyword">self</span> getPrivateKeyRefWithFilePath:privateKeyPath</span><br><span class="line">                                                     keyPassword:privateKeyPwd];</span><br><span class="line">    encryptData = [[<span class="keyword">self</span> <span class="keyword">class</span>] base64DecodeDataWithString:encryptString];</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(privateKeyRef)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((encryptData == <span class="literal">nil</span>) || (encryptData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line">    decryptData = [<span class="keyword">self</span> decryptData:encryptData withKeyRef:privateKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc] initWithData:decryptData encoding:encoding];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - RSA Key String Encrypt/Decrypt Public Method</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)encryptData:(<span class="built_in">NSData</span> *)originData publicKey:(<span class="built_in">NSString</span> *)publicKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断originData参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((originData == <span class="literal">nil</span>) || (originData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断publicKeyPath参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKey == <span class="literal">nil</span>) || (publicKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取需要加密的字符串内容编码数据流</span></span><br><span class="line">    SecKeyRef publicKeyRef = [<span class="keyword">self</span> publicKeyRefWithPublicKey:publicKey];</span><br><span class="line">    <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(publicKeyRef)])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> encryptData:originData withKeyRef:publicKeyRef];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)encryptString:(<span class="built_in">NSString</span> *)originString publicKey:(<span class="built_in">NSString</span> *)publicKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断publicKey参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((publicKey == <span class="literal">nil</span>) || (publicKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![publicKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([publicKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断originString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((originString == <span class="literal">nil</span>) || (originString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取需要加密的字符串内容编码数据流</span></span><br><span class="line">    <span class="built_in">NSData</span> *originData = <span class="literal">nil</span>, *encryptData = <span class="literal">nil</span>;</span><br><span class="line">    SecKeyRef publicKeyRef = [<span class="keyword">self</span> publicKeyRefWithPublicKey:publicKey];</span><br><span class="line">    originData = [originString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(publicKeyRef)])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((originData == <span class="literal">nil</span>) || (originData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![originData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([originData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    encryptData = [<span class="keyword">self</span> encryptData:originData withKeyRef:publicKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> <span class="keyword">class</span>] base64EncodedStringWithData:encryptData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)decryptString:(<span class="built_in">NSString</span> *)encryptString privateKey:(<span class="built_in">NSString</span> *)privateKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断publicKey参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((privateKey == <span class="literal">nil</span>) || (privateKey == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![privateKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([privateKey length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断originString参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> ((encryptString == <span class="literal">nil</span>) || (encryptString == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptString length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取私钥对象和需要加密的字符串内容编码数据流</span></span><br><span class="line">    SecKeyRef privateKeyRef;</span><br><span class="line">    <span class="built_in">NSData</span> *encryptData = <span class="literal">nil</span>, *decryptData = <span class="literal">nil</span>;</span><br><span class="line">    privateKeyRef = [[<span class="keyword">self</span> <span class="keyword">class</span>] privateKeyRefWithPrivateKey:privateKey];</span><br><span class="line">    encryptData = [[<span class="keyword">self</span> <span class="keyword">class</span>] base64DecodeDataWithString:encryptString];</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] isEmptyKeyRef:(__bridge <span class="keyword">id</span>)(privateKeyRef)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((encryptData == <span class="literal">nil</span>) || (encryptData == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![encryptData isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([encryptData length] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line">    decryptData = [<span class="keyword">self</span> decryptData:encryptData withKeyRef:privateKeyRef];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc] initWithData:decryptData encoding:encoding];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br></pre></td></tr></table></figure><p>在iOS中RSA加解密使用方法介绍（RSA密钥格式请使用PKCS#8格式）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RSA执行加密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *string4 = <span class="string">@"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *encodeString4 = [RSAEncrypt encryptString:string4</span><br><span class="line">                                          publicKey:mPublicKey];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"encodeString4 : %@"</span>, encodeString4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RSA执行解密操作</span></span><br><span class="line"><span class="built_in">NSString</span> *decodeString4 = [RSAEncrypt decryptString:encodeString4</span><br><span class="line">                                         privateKey:mPrivateKey];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"decodeString4 : %@"</span>, decodeString4);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Encryption" scheme="http://yoursite.com/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking原理(二) AFSecurityPolicy</title>
    <link href="http://yoursite.com/2019/06/25/AFNetWorking%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/06/25/AFNetWorking原理二/</id>
    <published>2019-06-25T03:31:07.000Z</published>
    <updated>2019-06-25T10:49:12.251Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。</p><a id="more"></a><p>AFSecurityPolicy 的校验选项 AFSSLPinningMode 有三种：</p><ol><li>AFSSLPinningModeNone 在与服务器建立安全连接时，并不会使用应用中已有的证书（也可能本就没有）对服务器传递的信息进行校验，此为默认选项</li><li>AFSSLPinningModePublicKey 使用应用中已有的公钥对服务器传递的信息进行校验</li><li>AFSSLPinningModeCertificate 使用应用中已有的数字证书对服务器传递的信息进行校验</li></ol><h3 id="HTPPS"><a href="#HTPPS" class="headerlink" title="HTPPS"></a>HTPPS</h3><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。</p><p>HTTPS连接建立 非对称加密、对称加密：<br>客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有（各个受信任的证书机构）根证书，用这些根证书对<strong>服务端返回的证书</strong>进行验证，经验证如果证书（服务端返回的证书）是可信任的，就生成一个pre-master  secret，用这个证书（服务端返回的证书）的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master  secret，客户端也同样根据这种算法从pre-master secret生成master secret（非对称加密），随后双方的通信都用这个master  secret对传输数据进行加密解密（对称加密）。</p><p>非对称加密： d(c(x))=x</p><h3 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h3><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p>HTTPS和HTTP的区别主要为以下四点：</p><ol><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL(Secure Sockets Layer安全套接层),及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p><p>SSL (Secure Socket Layer)为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。</p><p>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>SSL协议可分为两层：</p><ol><li>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</li><li>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ol><p>SSL协议提供的服务主要有哪些</p><ul><li>认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>加密数据以防止数据中途被窃取</li><li>维护数据的完整性，确保数据在传输过程中不被改变。</li></ul><p>SSL协议的工作流程</p><ul><li><p>服务器认证阶段：<br>客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；<br>服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；<br>客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；<br>服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p></li><li><p>用户认证阶段：<br>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p></li></ul><p>从SSL 协议所提供的服务及其工作流程可以看出，SSL协议运行的基础是商家对消费者信息保密的承诺，这就有利于商家而不利于消费者。在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。但随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的单一认证问题就越来越突出。虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务器双方的身份验证，但是SSL协议仍存在一些问题，比如，只能提供交易中客户与服务器间的双方认证，在涉及多方的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。在这种情况下，Visa和MasterCard两大信用卡公组织制定了SET协议，为网上信用卡支付提供了全球性的标准。</p><h3 id="SSL协议加密方式"><a href="#SSL协议加密方式" class="headerlink" title="SSL协议加密方式"></a>SSL协议加密方式</h3><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><ol><li><p>对称加密<br>速度高，可加密内容较大，用来加密会话过程中的消息</p></li><li><p>公钥加密<br>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p></li></ol><h3 id="SSL证书包含的信息"><a href="#SSL证书包含的信息" class="headerlink" title="SSL证书包含的信息"></a>SSL证书包含的信息</h3><ul><li><p>证书版本号，不同版本的证书格式不同</p></li><li><p>Serial Number　序列号，同一身份验证机构签发的证书序列号唯一</p></li><li><p>Algorithm Identifier 　签名算法，包括必要的参数Issuer 身份验证机构的标识信息</p></li><li><p>Period of Validity 　有效期</p></li><li><p>Subject　证书持有人的标识信息</p></li><li><p>Subject’s Public Key　证书持有人的公钥</p></li><li><p>Signature　身份验证机构对证书的签名</p></li><li><p>证书的格式　 认证中心所发放的证书均遵循X.509 V3 标准，其基本格式如下：</p></li><li><p>证书版本号（Certificate Format Version）<br>含义：用来指定证书格式采用的X.509 版本号。</p></li><li><p>证书序列号（Certificate Serial Number）<br>含义：用来指定证书的唯一序列号，以标识CA 发出的所有公钥证书。</p></li><li><p>签名（Signature）算法标识（Algorithm Identifier）<br>含义：用来指定 CA 签发证书所用的签名算法。</p></li><li><p>签发此证书的 CA 名称（Issuer ）<br>含义：用来指定签发证书的 CA 的X.500 唯一名称（DN，Distinguished Name）。</p></li><li><p>证书有效期（Validity Period）起始日期（notBefore） 终止日期（notAfter）<br>含义：用来指定证书起始日期和终止日期。</p></li><li><p>用户名称（Subject）<br>含义：用来指定证书用户的X.500 唯一名称（DN，Distinguished Name）。</p></li><li><p>用户公钥信息（Subject Public Key Information）算法（algorithm） 算法标识（Algorithm　Identifier）用户公钥（subject　Public　Key）<br>含义：用来标识公钥使用的算法，并包含公钥本身。</p></li><li><p>证书扩充部分（扩展域）（Extensions）<br>含义：用来指定额外信息。</p></li><li><p>X.509 V3 证书的扩充部分（扩展域）及实现方法如下：</p></li><li><p>CA 的公钥标识（Authority　Key　Identifier）</p></li><li><p>公钥标识（SET 未使用）（Key　Identifier）</p></li><li><p>签发证书者证书的签发者的甄别名（Certificate　Issuer）</p></li><li><p>签发证书者证书的序列号（Certificate Serial Number）</p></li><li><p>X.509 V3 证书的扩充部分（扩展域）及实现CA 的公钥标识（Authority　Key　Identifier）</p></li><li><p>公钥标识（SET 未使用）（Key　Identifier）</p></li><li><p>签发证书者证书的签发者的甄别名（Certificat签发证书者证书的序列号（Certificate Serial Number）<br>含义：CA 签名证书所用的密钥对的唯一标识用户的公钥标识（Subject　Key　Identifier）<br>含义：用来标识与证书中公钥相关的特定密钥进行解密。</p></li><li><p>证书中的公钥用途（Key　Usage）<br>含义：用来指定公钥用途。</p></li><li><p>用户的私钥有效期（Private　Key　Usage　Period）起始日期（Note　Before） 终止日期（Note　After）<br>含义：用来指定用户签名私钥的起始日期和终止日期。</p></li><li><p>CA 承认的证书政策列表（Certificate Policies）<br>含义：用来指定用户证书所适用的政策，证书政策可由对象标识符表示。</p></li><li><p>用户的代用名（Substitutional　Name）<br>含义：用来指定用户的代用名。</p></li><li><p>CA 的代用名（Issuer　Alt　Name）<br>含义：用来指定 CA 的代用名。</p></li><li><p>基本制约（Basic　Constraints）<br>含义：用来表明证书用户是最终用户还是CA。 在SET 系统中有一些私有扩充部分（扩展域）Hashed　Root　Key 含义：只在根证书中使用，用于证书更新时进行回溯。</p></li><li><p>证书类型（Certificate　Type）<br>含义：用来区别不同的实体。该项是必选的。</p></li><li><p>商户数据（Merchant　Data）<br>含义：包含支付网关需要的所有商户信息。</p></li><li><p>持卡人证书需求（Card　Cert　Required）<br>含义：显示支付网关是否支持与没有证书的持卡人进行交易。</p></li><li><p>SET 扩展（SETExtensions）<br>含义：列出支付网关支持的支付命令的 SET 信息扩展。</p></li><li><p>CRL 数据定义版本（Version）<br>含义：显示 CRL 的版本号。</p></li><li><p>CRL 的签发者（Issuer）<br>含义：指明签发 CRL 的CA 的甄别名。</p></li></ul><p>CRL 发布时间（this　Update）预计下一个 CRL 更新时间（Next　Update）撤销证书信息目录（Revoked　Certificates）CRL 扩展（CRL　Extension）CA 的公钥标识（Authority　Key　Identifier）CRL 号（CRL　Number）</p><p>SSL证书种类：<br>CFCA，GlobalSign，VeriSign ，Geotrust ，Thawte。</p><ul><li>域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站；</li><li>企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高；</li><li>增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。</li></ul><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p>为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：</p><ol><li>客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</li><li>服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</li><li>客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</li><li>用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</li><li>如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。</li><li>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</li><li>服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</li><li>客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</li><li>服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</li><li>SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</li></ol><h3 id="HTTPS的认证过程"><a href="#HTTPS的认证过程" class="headerlink" title="HTTPS的认证过程"></a>HTTPS的认证过程</h3><h4 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h4><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ol><li>证书是否过期</li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ol></li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</li><li>服务器将选择好的加密方案通过明文方式返回给客户端</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li></ol><h4 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h4><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ol><li>证书是否过期</li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ol></li><li>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li></ol><h3 id="AFSecurityPolicy和认证"><a href="#AFSecurityPolicy和认证" class="headerlink" title="AFSecurityPolicy和认证"></a>AFSecurityPolicy和认证</h3><h4 id="认证过程和原理"><a href="#认证过程和原理" class="headerlink" title="认证过程和原理"></a>认证过程和原理</h4><p>AFN是靠着AFSecurityPolicy这个类保证数据安全的，调用下面方法用来验证是否信任服务器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]</span><br></pre></td></tr></table></figure><p>看一下AFN中的接口</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    @typedef SecTrustRef</span></span><br><span class="line"><span class="comment">    @abstract CFType used for performing X.509 certificate trust evaluations.</span></span><br><span class="line"><span class="comment">    // 执行X.509证书信任评估，其实就是一个容器，装了服务器端需要验证的证书的基本信息、</span></span><br><span class="line"><span class="comment">    公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书，</span></span><br><span class="line"><span class="comment">    这个客户端的证书，可以用来和服务端的证书去匹配验证的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_TYPE</span>(<span class="keyword">id</span>) __SecTrust *SecTrustRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not the specified server trust should be accepted, based on the security policy.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> This method should be used when responding to an authentication challenge from a server.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust The X.509 certificate trust of the server.</span></span><br><span class="line"><span class="comment"> @param domain The domain of serverTrust. If `nil`, the domain will not be validated. // 服务器域名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return Whether or not to trust the server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)domain;</span><br></pre></td></tr></table></figure><p>根据安全策略是否接受指定的服务器信任。 响应来自服务器的身份验证质询时应使用此方法。</p><p>大家还记得这个代理方法吗？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//挑战处理类型为 默认</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeUseCredential：使用指定的证书</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span></span><br><span class="line">        <span class="comment">// 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                <span class="comment">// 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书）</span></span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="comment">// 确定挑战的方式</span></span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    <span class="comment">//证书挑战  设计policy,none，则跑到这里</span></span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//取消挑战</span></span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认挑战方式</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成挑战</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是如何进行接受挑战的</p><ul><li>首先指定了HTTPS为默认的认证方式。</li><li>判断有没有自定义Block:sessionDidReceiveAuthenticationChallenge，有的话，使用我们自定义Block,生成一个认证方式，并且可以给credential赋值，即我们需要接受认证的证书。然后直接调用completionHandler，去根据这两个参数，执行系统的认证。</li><li>如果没有自定义Block，我们判断如果服务端的认证方法要求是NSURLAuthenticationMethodServerTrust，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现）</li><li>接着我们就执行了AFSecurityPolicy相关的上面的方法- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain，关于这个方法，AF默认的处理是，如果这行返回NO、说明AF内部认证失败，则取消HTTPS认证，即取消请求。返回YES则进入if块，用服务器返回的一个serverTrust去生成了一个认证证书。（注：这个serverTrust是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。最后调用completionHandler传递认证方式和要认证的证书，去做系统根证书验证。也可以这么理解：这里securityPolicy存在的作用就是，使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。如果通不过，则直接越过系统的验证，取消HTTPS的网络请求。否则，继续去走系统根证书的验证。</li></ul><h4 id="AFSecurityPolicy实例化"><a href="#AFSecurityPolicy实例化" class="headerlink" title="AFSecurityPolicy实例化"></a>AFSecurityPolicy实例化</h4><p>先看一下该类的实例化</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个很重要的属性就是SSLPinningMode，先看一下这个枚举</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,    <span class="comment">//不验证</span></span><br><span class="line">    AFSSLPinningModePublicKey,  <span class="comment">//只验证公钥</span></span><br><span class="line">    AFSSLPinningModeCertificate,  <span class="comment">// 验证证书</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面我们看一下类AFSecurityPolicy的几个属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The criteria by which server trust should be evaluated against the pinned SSL certificates. Defaults to `AFSSLPinningModeNone`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 验证模式 这个枚举值上面讲述过</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The certificates used to evaluate server trust according to the SSL pinning mode. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  By default, this property is set to any (`.cer`) certificates included in the target compiling AFNetworking. Note that if you are using AFNetworking as embedded framework, no certificates will be pinned by default. Use `certificatesInBundle` to load certificates from your target, and then create a new policy by calling `policyWithPinningMode:withPinnedCertificates`.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> Note that if pinning is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 可以去匹配服务端证书验证的证书</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *pinnedCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not to trust servers with an invalid or expired SSL certificates. Defaults to `NO`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 是否支持非法的证书（例如自签名证书）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowInvalidCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not to validate the domain name in the certificate's CN field. Defaults to `YES`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 是否去验证证书域名是否匹配</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> validatesDomainName;</span><br></pre></td></tr></table></figure><h3 id="AFNetWorking-HTTPS请求示例"><a href="#AFNetWorking-HTTPS请求示例" class="headerlink" title="AFNetWorking HTTPS请求示例"></a>AFNetWorking HTTPS请求示例</h3><h4 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h4><p>我们手动指定securityPolicy认证属性。通过12306证书来实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自建证书认证</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)buttion1:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://kyfw.12306.cn/otn/leftTicket/init"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">   <span class="comment">// [request setValue:@"text/html" forHTTPHeaderField:@"Accept"];</span></span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">    <span class="comment">//指定安全策略</span></span><br><span class="line">    manager.securityPolicy = [<span class="keyword">self</span> ticketSecurityPolicy];</span><br><span class="line">    <span class="comment">//指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型</span></span><br><span class="line">    AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"text/html"</span>];</span><br><span class="line">    manager.responseSerializer = responseSerializer;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>],error);</span><br><span class="line">    &#125;];</span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 12306的认证证书，他的认证证书是自签名的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 返回指定的认证策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(AFSecurityPolicy*)ticketSecurityPolicy &#123;</span><br><span class="line">    <span class="comment">// /先导入证书</span></span><br><span class="line">    <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"12306"</span> ofType:<span class="string">@"cer"</span>];<span class="comment">//证书的路径</span></span><br><span class="line">    <span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</span><br><span class="line">    <span class="built_in">NSSet</span> *set = [<span class="built_in">NSSet</span> setWithObject:certData];</span><br><span class="line"></span><br><span class="line">    AFSecurityPolicy *securityPolicy;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:set];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书</span></span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line">    <span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line">    <span class="comment">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line">    <span class="comment">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line">    <span class="comment">//如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">    securityPolicy.validatesDomainName = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SSL信任证书"><a href="#SSL信任证书" class="headerlink" title="SSL信任证书"></a>SSL信任证书</h4><p>我们手动指定securityPolicy认证属性。通过百度证书来实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//认证证书认证</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)button2:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    <span class="comment">//[request setValue:@"text/html" forHTTPHeaderField:@"Accept"];</span></span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">    <span class="comment">//指定安全策略</span></span><br><span class="line">    manager.securityPolicy = [<span class="keyword">self</span> baiduSecurityPolicy];</span><br><span class="line">    <span class="comment">//指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型</span></span><br><span class="line">    AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"text/html"</span>];</span><br><span class="line">    manager.responseSerializer = responseSerializer;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>],error);</span><br><span class="line">    &#125;];</span><br><span class="line">    [dataTask resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">百度的的认证证书，他的认证证书是花钱买的，也就是不是自签名的证书。这种证书，如果我们要手动指定，pinmode只能是`AFSSLPinningModeNone`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 返回指定的认证策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(AFSecurityPolicy*)baiduSecurityPolicy &#123;</span><br><span class="line">    <span class="comment">// /先导入证书</span></span><br><span class="line">    <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"baidu"</span> ofType:<span class="string">@"cer"</span>];<span class="comment">//证书的路径</span></span><br><span class="line">    <span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</span><br><span class="line">    <span class="built_in">NSSet</span> *set = [<span class="built_in">NSSet</span> setWithObject:certData];</span><br><span class="line"></span><br><span class="line">    AFSecurityPolicy *securityPolicy;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//这里只能用AFSSLPinningModeNone才能成功，而且我系统的证书列表里面已经有百度的证书了</span></span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone withPinnedCertificates:set];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书</span></span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line">    <span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line">    <span class="comment">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line">    <span class="comment">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line">    <span class="comment">//如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">    securityPolicy.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SSL证书AFN默认处理"><a href="#SSL证书AFN默认处理" class="headerlink" title="SSL证书AFN默认处理"></a>SSL证书AFN默认处理</h4><p>这里我们不做任何额外的处理，直接使用AFN的默认证书处理机制。通过AFURLSessionManager的securityPolicy默认实现。它会和存在系统中的做对比来验证证书。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统证书认证</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)button3:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.apple.com/"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">    <span class="comment">//指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型</span></span><br><span class="line">    AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"text/html"</span>];</span><br><span class="line">    manager.responseSerializer = responseSerializer;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>],error);</span><br><span class="line">    &#125;];</span><br><span class="line">    [dataTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AFSecurityPolicy源码解析"><a href="#AFSecurityPolicy源码解析" class="headerlink" title="AFSecurityPolicy源码解析"></a>AFSecurityPolicy源码解析</h3><p>AFSecurityPolicy分三种验证模式</p><ol><li>AFSSLPinningModeNone:<br>这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。</li><li>AFSSLPinningModeCertificate:<br>这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。这里还没弄明白第一步的验证是怎么进行的，代码上跟去系统信任机构列表里验证一样调用了SecTrustEvaluate，只是这里的列表换成了客户端保存的那些证书列表。若要验证这个，是否应该把服务端证书的颁发机构根证书也放到客户端里？</li><li>AFSSLPinningModePublicKey:<br>这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</li></ol><p><strong>SecTrustRef</strong><br>这是一个需要验证的信任对象,包含待验证的证书和支持的验证方法等。</p><p><strong>SecTrustResultType</strong><br>表示验证结果。其中 kSecTrustResultProceed表示serverTrust验证成功，且该验证得到了用户认可(例如在弹出的是否信任的alert框中选择always trust)。 kSecTrustResultUnspecified表示 serverTrust验证成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书。 两者取其一就可以认为对serverTrust验证成功。</p><p><strong>SecTrustEvaluate</strong><br>证书校验函数,在函数的内部递归地从叶节点证书到根证书验证。需要验证证书本身的合法性（验证签名完整性，验证证书有效期等);验证证书颁发者的合法性（查找颁发者的证书并检查其合法性，这个过程是递归的).而递归的终止条件是证书验证过程中遇到了锚点证书(锚点证书:嵌入到操作系统中的根证书,这个根证书是权威证书颁发机构颁发的自签名证书)。</p><p>AFSecurityPolicy的源码细节如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 证书的验证类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> - AFSSLPinningModeNone: 不使用`pinned certificates`来验证证书</span></span><br><span class="line"><span class="comment"> - AFSSLPinningModePublicKey: 使用`pinned certificates`来验证证书的公钥</span></span><br><span class="line"><span class="comment"> - AFSSLPinningModeCertificate: 使用`pinned certificates`来验证整个证书</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获取指定证书的公钥</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param certificate 证书数据</span></span><br><span class="line"><span class="comment"> @return 公钥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFPublicKeyForCertificate(<span class="built_in">NSData</span> *certificate) &#123;</span><br><span class="line">    <span class="keyword">id</span> allowedPublicKey = <span class="literal">nil</span>;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecPolicyRef policy = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustRef allowedTrust = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    <span class="comment">//获取证书对象</span></span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != <span class="literal">NULL</span>, _<span class="keyword">out</span>);</span><br><span class="line">    <span class="comment">//获取X.509的认证策略</span></span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="comment">//获取allowedTrust对象的值</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _<span class="keyword">out</span>);</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">    <span class="comment">//根据allowedTrust获取对应的公钥</span></span><br><span class="line">    allowedPublicKey = (__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"><span class="comment">//C++的gumpto跳转，当前面的操作出错以后，直接跳入_out执行</span></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">if</span> (allowedTrust) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedTrust);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (policy) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(policy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allowedCertificate) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedCertificate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回公钥</span></span><br><span class="line">    <span class="keyword">return</span> allowedPublicKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在指定的证书和认证策略下，验证SecTrustRef对象是否是受信任的、合法的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust SecTrustRef对象</span></span><br><span class="line"><span class="comment"> @return 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    <span class="comment">//获取serverTrust的认证结果，调用`SecTrustEvaluate`表示通过系统的证书来比较认证</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据`serverTrust`获取认证的证书链</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust serverTrust对象</span></span><br><span class="line"><span class="comment"> @return 认证证书链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//获取认证链的总层次</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">//获取每一级认证链，把获取的证书数据存入数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回证书链数组</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获取serverTrust对象的认证链的公钥数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust serverTrust对象</span></span><br><span class="line"><span class="comment"> @return 公钥数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//X.509标准的安全策略</span></span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="comment">//获取证书链的证书数量</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line"></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        <span class="built_in">CFArrayRef</span> certificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)someCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        <span class="comment">//通过一个证书、认证策略新建一个SecTrustRef对象</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        <span class="comment">//验证SecTrustRef对象是否成功</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">        <span class="comment">//把SecTrustRef对应的公钥加入数组中</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _<span class="keyword">out</span>:</span><br><span class="line">        <span class="keyword">if</span> (trust) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (certificates) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(certificates);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(policy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFSecurityPolicy</span>()</span></span><br><span class="line"><span class="comment">//认证策略</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"><span class="comment">//公钥集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span> *pinnedPublicKeys;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFSecurityPolicy</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 从MainBundle中获取所有证书</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param bundle 返回包含在bundle中的证书集合。如果AFNetworking使用的是静态库，我们必须通过这个方法来加载证书。并且通过`policyWithPinningMode:withPinnedCertificates`方法来指定认证类型。</span></span><br><span class="line"><span class="comment"> @return 返回bundle里面的证书</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)certificatesInBundle:(<span class="built_in">NSBundle</span> *)bundle &#123;</span><br><span class="line">    <span class="comment">//获取项目里的所有.cer证书</span></span><br><span class="line">    <span class="built_in">NSArray</span> *paths = [bundle pathsForResourcesOfType:<span class="string">@"cer"</span> inDirectory:<span class="string">@"."</span>];</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *certificates = [<span class="built_in">NSMutableSet</span> setWithCapacity:[paths count]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *path <span class="keyword">in</span> paths) &#123;</span><br><span class="line">        <span class="comment">//获取证书对应的NSData，并且加入集合中</span></span><br><span class="line">        <span class="built_in">NSData</span> *certificateData = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        [certificates addObject:certificateData];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回证书集合</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithSet:certificates];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回当前类所在bundle所在的证书集合</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 证书集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)defaultPinnedCertificates &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSSet</span> *_defaultPinnedCertificates = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">//获取当前类所在bundle</span></span><br><span class="line">        <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</span><br><span class="line">        _defaultPinnedCertificates = [<span class="keyword">self</span> certificatesInBundle:bundle];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _defaultPinnedCertificates;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回默认的安全认证策略,在这里是验证系统的证书。这个策略不允许非法证书、验证主机名、不验证证书内容和公钥</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 返回认证策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据指定的认证策略和默认的证书列表初始化一个`AFSecurityPolicy`对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param pinningMode 认证策略</span></span><br><span class="line"><span class="comment"> @return `AFSecurityPolicy`对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:[<span class="keyword">self</span> defaultPinnedCertificates]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 通过制定的认证策略`pinningMode`和证书集合`pinnedCertificates`来初始化一个`AFSecurityPolicy`对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param pinningMode 认证模型</span></span><br><span class="line"><span class="comment"> @param pinnedCertificates 证书集合</span></span><br><span class="line"><span class="comment"> @return AFSecurityPolicy对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = pinningMode;</span><br><span class="line">    <span class="comment">//设置`_pinnedCertificates`和`pinnedPublicKeys`属性，分别对应证书集合和公钥集合</span></span><br><span class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class="line">    <span class="comment">//返回初始化成功的`AFSecurityPolicy`</span></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认是要认证主机名称</span></span><br><span class="line">    <span class="keyword">self</span>.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过指定的证书结合获取到对应的公钥集合。然后赋值给`pinnedPublicKeys`属性</span></span><br><span class="line"><span class="comment"> @param pinnedCertificates 证书集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="comment">//迭代每一个证书</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="comment">//获取证书对应的公钥</span></span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对应的属性</span></span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 为serverTrust对象指定认证策略，如果domain不为nil,则包括对主机名的认证。这个方法必须在接受到`authentication challenge`返回的时候调用。</span></span><br><span class="line"><span class="comment"> SecTrustRef可以理解为桥接证书与认证策略的对象，他关联指定的证书与认证策略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param serverTrust 服务器的X.509标准的证书数据</span></span><br><span class="line"><span class="comment"> @param domain 认证服务器的主机名。如果是nil,则不会对主机名进行认证。</span></span><br><span class="line"><span class="comment"> @return serverTrust是否通过认证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></span><br><span class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></span><br><span class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></span><br><span class="line">        <span class="comment">//  there is nothing to evaluate against.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  From Apple Docs:</span></span><br><span class="line">        <span class="comment">//          "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></span><br><span class="line">        <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors."</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        <span class="comment">//使用需要认证主机名的认证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//使用默认的认证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给serverTrust对象指定认证策略</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据证书验证策略、数字签名认证策略、其他认证策略来处理不同情况</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:<span class="comment">//不验证公钥和证书</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;<span class="comment">//验证整个证书</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            <span class="comment">//根据指定证书获取，获取对应的证书对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把证书与serverTrust关联起来</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA)</span></span><br><span class="line">            <span class="comment">//获取serverTrust证书链。直到根证书。</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            <span class="comment">//如果`pinnedCertificates`包含`serverTrust`对象对应的证书链的根证书。则返回true</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;<span class="comment">//只验证证书里面的数字签名</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//根据serverTrust对象和SecPolicyCreateBasicX509认证策略，获取对应的公钥集合</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="comment">//把获取的公钥和系统获取的默认公钥比较，如果相等，则通过认证</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSKeyValueObserving</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingPinnedPublicKeys &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"pinnedCertificates"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSSecureCoding</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)supportsSecureCoding &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.SSLPinningMode = [[decoder decodeObjectOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(SSLPinningMode))] unsignedIntegerValue];</span><br><span class="line">    <span class="keyword">self</span>.allowInvalidCertificates = [decoder decodeBoolForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowInvalidCertificates))];</span><br><span class="line">    <span class="keyword">self</span>.validatesDomainName = [decoder decodeBoolForKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(validatesDomainName))];</span><br><span class="line">    <span class="keyword">self</span>.pinnedCertificates = [decoder decodeObjectOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(pinnedCertificates))];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</span><br><span class="line">    [coder encodeObject:[<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="keyword">self</span>.SSLPinningMode] forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(SSLPinningMode))];</span><br><span class="line">    [coder encodeBool:<span class="keyword">self</span>.allowInvalidCertificates forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowInvalidCertificates))];</span><br><span class="line">    [coder encodeBool:<span class="keyword">self</span>.validatesDomainName forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(validatesDomainName))];</span><br><span class="line">    [coder encodeObject:<span class="keyword">self</span>.pinnedCertificates forKey:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(pinnedCertificates))];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - NSCopying</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = <span class="keyword">self</span>.SSLPinningMode;</span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="keyword">self</span>.allowInvalidCertificates;</span><br><span class="line">    securityPolicy.validatesDomainName = <span class="keyword">self</span>.validatesDomainName;</span><br><span class="line">    securityPolicy.pinnedCertificates = [<span class="keyword">self</span>.pinnedCertificates copyWithZone:zone];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="AFNetWorking原理" scheme="http://yoursite.com/tags/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    
      <category term="Encryption" scheme="http://yoursite.com/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking原理(一) AFURLSessionManager解读</title>
    <link href="http://yoursite.com/2019/06/21/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/21/AFNetWorking原理/</id>
    <published>2019-06-21T07:48:30.000Z</published>
    <updated>2019-06-25T03:19:09.896Z</updated>
    
    <content type="html"><![CDATA[<p>NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。</p><a id="more"></a><h3 id="AFNetworking由5个模块组成"><a href="#AFNetworking由5个模块组成" class="headerlink" title="AFNetworking由5个模块组成"></a>AFNetworking由5个模块组成</h3><ol><li>NSURLSession：网络通信模块（核心模块）<ol><li>AFURLSessionManager 对NSURLSession的封装</li><li>AFHTTPSessionManager 是继承于 AFURLSessionmanager</li></ol></li><li>Security：网络通讯安全策略模块<ol><li>AFSecurityPolicy</li></ol></li><li>Reachability：网络状态监听模块<ol><li>AFNetworkReachabilityManager</li></ol></li><li>Seriaalization：网络通信信息序列化、反序列化模块<ol><li>AFHTTPRequestSerializer</li><li>AFURLResponseSerialization</li></ol></li><li>UIKit：对于iOS UIKit的扩展库</li></ol><h3 id="网络请求类-AFURLSessionManager"><a href="#网络请求类-AFURLSessionManager" class="headerlink" title="网络请求类 AFURLSessionManager"></a>网络请求类 AFURLSessionManager</h3><h4 id="声明-h文件"><a href="#声明-h文件" class="headerlink" title="声明.h文件"></a>声明.h文件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFURLSessionManager类实现了NSURLSession相关的众多协议，用于帮助我们进行数据的处理</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManager</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionDelegate</span>, <span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLSessionDownloadDelegate</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSURLSession 作为一个实例变量，AFN发起的网络请求都是通过该session创建的task实现的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSURLSession delegate方法执行队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应序列化 不能为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全策略，用于https等需要验证的地方</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !TARGET_OS_WATCH（生成的代码将在Apple Watch操作系统下运行）</span></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Monitoring Network Reachability</span></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监测网络连通性，使用AFNetworkReachabilityManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFNetworkReachabilityManager *reachabilityManager;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///----------------------------</span></span><br><span class="line"><span class="comment">/// @name Getting Session Tasks</span></span><br><span class="line"><span class="comment">///----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的data upload download task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionTask</span> *&gt; *tasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的data task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDataTask</span> *&gt; *dataTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的upload task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionUploadTask</span> *&gt; *uploadTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session管理的download task的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDownloadTask</span> *&gt; *downloadTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------------</span></span><br><span class="line"><span class="comment">/// @name Managing Callback Queues</span></span><br><span class="line"><span class="comment">///-------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成网络请求后执行回调块的队列，如果为nil则使用主队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> completionQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成网络请求后回调块的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) dispatch_group_t completionGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"><span class="comment">/// @name Working Around System Bugs</span></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// background类型的session是否尝试重新创建上传任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> attemptsToRecreateUploadTasksForBackgroundSessions;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------</span></span><br><span class="line"><span class="comment">/// @name Initialization</span></span><br><span class="line"><span class="comment">///---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数，根据指定NSURLSessionConfiguration创建session</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)configuration <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session无效，cancelPendingTasks标识是否取消session中正在执行的任务</span></span><br><span class="line"><span class="comment">// 内部还是调用NSURLSession的invalidate方法</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionCancelingTasks:(<span class="built_in">BOOL</span>)cancelPendingTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------</span></span><br><span class="line"><span class="comment">/// @name Running Data Tasks</span></span><br><span class="line"><span class="comment">///-------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的request创建一个NSURLSessionDataTask任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler DEPRECATED_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的request创建一个NSURLSessionDataTask任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------------</span></span><br><span class="line"><span class="comment">/// @name Running Upload Tasks</span></span><br><span class="line"><span class="comment">///---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定request fileURL等参数构造一个NSURLSessionUploadTask任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span>  * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定request和data等参数构造一个上传任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)bodyData</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个具有特定数据流的NSURLSessionUploadTask请求，上传的body使用的是request.HTTPBodyStream</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                 progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                        completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------</span></span><br><span class="line"><span class="comment">/// @name Running Download Tasks</span></span><br><span class="line"><span class="comment">///-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造下载任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                             progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                          destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                    completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造下载任务 断点续传</span></span><br><span class="line"><span class="comment">根据未下载完成的数据，创建一个NSURLSessionDownloadTask对象。</span></span><br><span class="line"><span class="comment">resumeData：未完成的下载数据</span></span><br><span class="line"><span class="comment">destination：决定下载文件的存放路径的block。block中有两个参数，目标路径和服务器的响应。同时返回文件下载的URL</span></span><br><span class="line"><span class="comment">completionHandler：当任务完成后completionHandler的block会被调用</span></span><br><span class="line"><span class="comment">progress：下载进度block。每当下载进度更新时就会执行这个block</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData</span><br><span class="line">                                                progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                             destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                       completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"><span class="comment">/// @name Getting Progress for Tasks</span></span><br><span class="line"><span class="comment">///---------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据NSURLSessionTask获取对应的任务完成进度NSProgress</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSProgress</span> *)uploadProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据NSURLSessionTask获取对应下载任务的进度NSProgress</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSProgress</span> *)downloadProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Session Delegate Callbacks</span></span><br><span class="line"><span class="comment">///-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session无效时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session收到challenge时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Task Delegate Callbacks</span></span><br><span class="line"><span class="comment">///--------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session需要新的流时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskNeedNewBodyStreamBlock:(<span class="keyword">nullable</span> <span class="built_in">NSInputStream</span> * (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置session的任务需要执行重定向时执行的回调块</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskWillPerformHTTPRedirectionBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> * _Nullable (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURLRequest</span> *request))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Block用于当一个session的task接收到证书验证时调用。实际上依赖由NSURLSessionTaskDelegate 的 URLSession:task:didReceiveChallenge:completionHandler:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Block每隔一段时间调用用来跟踪上传进度，实际上依赖由NSURLSessionTaskDelegate的 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidSendBodyDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个当task完成时调用的Block</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidCompleteBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSError</span> * _Nullable error))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-------------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Data Task Delegate Callbacks</span></span><br><span class="line"><span class="comment">///-------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个当DataTask请求接收到响应时调用的block。交由NSURLSessionDataDelegate的URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidReceiveResponseBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionResponseDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLResponse</span> *response))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当一个dataTask转变成downloadTak时调用的block，交由</span></span><br><span class="line"><span class="built_in">NSURLSessionDataDelegate</span> 的 URLSession:dataTask:didBecomeDownloadTask:.方法处理</span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidBecomeDownloadTaskBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当一个dataTask接受到数据时就调用的block，交由</span></span><br><span class="line"><span class="built_in">NSURLSessionDataDelegate</span> 的 URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理</span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidReceiveDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSData</span> *data))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当一个dataTask对请求结果的缓冲时的block。交由NSURLSessionDataDelegate 的 URLSession:dataTask:willCacheResponse:completionHandler:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskWillCacheResponseBlock:(<span class="keyword">nullable</span> <span class="built_in">NSCachedURLResponse</span> * (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSCachedURLResponse</span> *proposedResponse))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当session中所有消息都被发送时，调用的block。交由NSURLSessionDataDelegate的URLSessionDidFinishEventsForBackgroundURLSession：方法实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setDidFinishEventsForBackgroundURLSessionBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session))block AF_API_UNAVAILABLE(macos);</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------------</span></span><br><span class="line"><span class="comment">/// @name Setting Download Task Delegate Callbacks</span></span><br><span class="line"><span class="comment">///-----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个当下载任务完成一个下载时调用的block。最终交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didFinishDownloadingToURL:.方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidFinishDownloadingBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * _Nullable  (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, <span class="built_in">NSURL</span> *location))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每次追踪下载进度时调用的block，最终交由NSURLSessionDownloadDelegate的URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite：方法处理</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidWriteDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个block，当任务重新下载时调用。交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:.方式</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidResumeBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///--------------------</span></span><br><span class="line"><span class="comment">/// @name Notifications</span></span><br><span class="line"><span class="comment">///--------------------</span></span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidResumeNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidSuspendNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDidInvalidateNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDownloadTaskDidFailToMoveFileNotification;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseDataKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteSerializedResponseKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseSerializerKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteAssetPathKey;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteErrorKey;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><p>通过头文件可以发现，AFURLSessionManager是封装了NSURLSession并实现了其相关的所有协议，提供了一系列方法用于构造各种网络请求任务，并提供回调块进行处理，还提供了一系列设置代理方法执行时的执行回调块的方法，这样，我们也可以监听整个网络请求的过程，当然也可以忽略这些代理方法执行情况，提供了各种通知，通过头文件可以看出，主要目的还是为了封装NSURLSession从而提供更加便捷的方法来实现网络请求。</p><h4 id="实现-m文件"><a href="#实现-m文件" class="headerlink" title="实现.m文件"></a>实现.m文件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef NSFoundationVersionNumber_iOS_8_0</span></span><br><span class="line"><span class="meta">#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C静态函数，GCD只执行一次，用于创建一个串行队列来执行各种网络请求任务的创建工作</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.creation"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C静态函数，用于执行创建网络请求任务的block</span></span><br><span class="line"><span class="comment">主要目的是为了解决ios8以下存在的一个block和task不匹配的bug</span></span><br><span class="line"><span class="comment">上面那个队列也是为了解决这个bug才创建的</span></span><br><span class="line"><span class="comment">具体可查看</span></span><br><span class="line"><span class="comment">Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span></span><br><span class="line"><span class="comment">Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSFoundationVersionNumber</span> &lt; <span class="built_in">NSFoundationVersionNumber_With_Fixed_5871104061079552_bug</span>) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C静态函数，创建一个并发队列，用于在网络请求任务完成后处理数据的，并发队列实现多线程处理多个请求完成后的数据处理</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">"com.alamofire.networking.session.manager.processing"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C静态函数创建一个dispatch的组</span></span><br><span class="line"><span class="comment">//但在接下来的源码中并没有使用这个组来实现notify等功能，仅仅是将block和组关联了，不太清楚具体用意</span></span><br><span class="line"><span class="comment">//有明白的读者还请不吝赐教</span></span><br><span class="line"><span class="keyword">static</span> dispatch_group_t url_session_manager_completion_group() &#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_group_t af_url_session_manager_completion_group;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_completion_group = dispatch_group_create();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_completion_group;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一系列通知名称的定义</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidResumeNotification = <span class="string">@"com.alamofire.networking.task.resume"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteNotification = <span class="string">@"com.alamofire.networking.task.complete"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidSuspendNotification = <span class="string">@"com.alamofire.networking.task.suspend"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDidInvalidateNotification = <span class="string">@"com.alamofire.networking.session.invalidate"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionDownloadTaskDidFailToMoveFileNotification = <span class="string">@"com.alamofire.networking.session.download.file-manager-error"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteSerializedResponseKey = <span class="string">@"com.alamofire.networking.task.complete.serializedresponse"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseSerializerKey = <span class="string">@"com.alamofire.networking.task.complete.responseserializer"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteResponseDataKey = <span class="string">@"com.alamofire.networking.complete.finish.responsedata"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteErrorKey = <span class="string">@"com.alamofire.networking.task.complete.error"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTaskDidCompleteAssetPathKey = <span class="string">@"com.alamofire.networking.task.complete.assetpath"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要使用的NSLock锁的名称</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFURLSessionManagerLockName = <span class="string">@"com.alamofire.networking.session.manager.lock"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//background session重试创建上传任务次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> <span class="keyword">const</span> AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>对于url_session_manager_create_task_safely这个有什么用？其实这个是被当做是一个在ios8以下，NSURLSessionDataTask出现的一个Bug。问题产生的原因就是当队列是并发的，这是当两个任务同时在不同的线程上创建任务的时候taskIdentifier可能是一样的。<br>大致的意思就是当我们同时创建两个任务，返回了重复的taskIdentifier，这样的话第一个被创建的completionHandler就会被清空，被第二个任务的completionHandler给替换，如果第一个数据是早于第二个数据返回的，那么第一个数据返回之后就会去调用第二个任务的completionHandler。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDidBecomeInvalidBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * __autoreleasing *credential);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLRequest</span> * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURLRequest</span> *request);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * __autoreleasing *credential);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(<span class="built_in">NSURLSession</span> *session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInputStream</span> * (^AFURLSessionTaskNeedNewBodyStreamBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskDidSendBodyDataBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskDidCompleteBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSError</span> *error);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURLSessionResponseDisposition</span> (^AFURLSessionDataTaskDidReceiveResponseBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLResponse</span> *response);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDataTaskDidReceiveDataBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSData</span> *data);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSCachedURLResponse</span> * (^AFURLSessionDataTaskWillCacheResponseBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSCachedURLResponse</span> *proposedResponse);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSURL</span> * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, <span class="built_in">NSURL</span> *location);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDownloadTaskDidWriteDataBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionDownloadTaskDidResumeBlock)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskProgressBlock)(<span class="built_in">NSProgress</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^AFURLSessionTaskCompletionHandler)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error);</span><br></pre></td></tr></table></figure><p>定义一些回调的block</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个类AFURLSessionManagerTaskDelegate并实现了NSURLSessionTask的相关协议</span></span><br><span class="line"><span class="comment">//这个类是用于处理NSURLSessionTask相关代理方法的</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManagerTaskDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化构造函数，需要传入一个关联的task</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">//weak修饰的manager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) AFURLSessionManager *manager;</span><br><span class="line"><span class="comment">//可变data用于存储获取到的网络数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableData</span> *mutableData;</span><br><span class="line"><span class="comment">//上传进度NSProgress</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSProgress</span> *uploadProgress;</span><br><span class="line"><span class="comment">//下载进度NSProgress</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSProgress</span> *downloadProgress;</span><br><span class="line"><span class="comment">//下载文件的NSURL</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *downloadFileURL;</span><br><span class="line"><span class="comment">//下载完成的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="comment">//上传进度的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskProgressBlock uploadProgressBlock;</span><br><span class="line"><span class="comment">//下载进度的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskProgressBlock downloadProgressBlock;</span><br><span class="line"><span class="comment">//网络请求完成的回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskCompletionHandler completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFURLSessionManagerTaskDelegate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _mutableData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    _uploadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    _downloadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历两个上传和下载NSProgress设置一些属性</span></span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSProgress</span> *progress <span class="keyword">in</span> @[ _uploadProgress, _downloadProgress ])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化progress</span></span><br><span class="line">        progress.totalUnitCount = <span class="built_in">NSURLSessionTransferSizeUnknown</span>;</span><br><span class="line">        progress.cancellable = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//设置取消进度的回调块，执行task的cancel方法</span></span><br><span class="line">        progress.cancellationHandler = ^&#123;</span><br><span class="line">            [weakTask cancel];</span><br><span class="line">        &#125;;</span><br><span class="line">        progress.pausable = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//设置暂停进度的回调块，执行task的suspend方法</span></span><br><span class="line">        progress.pausingHandler = ^&#123;</span><br><span class="line">            [weakTask suspend];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置重新开始的回调块，执行task的resume方法</span></span><br><span class="line">        <span class="keyword">if</span> ([progress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">            progress.resumingHandler = ^&#123;</span><br><span class="line">                [weakTask resume];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//progress添加kvo，监听progress的进度fractionCompleted</span></span><br><span class="line">        [progress addObserver:<span class="keyword">self</span></span><br><span class="line">                   forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                      options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      context:<span class="literal">NULL</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">//删除KVO</span></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress removeObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress removeObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSProgress Tracking</span></span><br><span class="line"><span class="comment">//KVO回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="comment">//上次或下载进度有改变时，执行上传或下载进度回调块</span></span><br><span class="line">   <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionTaskDelegate</span></span><br><span class="line"><span class="comment">//代理方法，网络请求完成或出错</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//manager用weak修饰，这里strong一下防止manager被释放</span></span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//为userInfo字典设置响应序列化</span></span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line">    <span class="comment">//赋值mutableData到data中，并释放mutableData</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果downloadFileURL存在，即是下载任务就设置下载完成后的文件存储url到字典中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="comment">//否则就设置对应的NSData数据到字典中</span></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果网络请求有错误</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">//设置error信息到字典中</span></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个三目运算符需要解释一下，在其他语言中这么写很可能就是语法错误</span></span><br><span class="line"><span class="comment">        这里的意思就是如果manager.completionGroup存在就使用它</span></span><br><span class="line"><span class="comment">        不存在就使用url_session_manager_completion_group函数返回的group</span></span><br><span class="line"><span class="comment">        后面的三目运算符同理</span></span><br><span class="line"><span class="comment">        所以如果自己不设置manager的completionGroup或completionQueue就会使用默认提供的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//执行对应的completionHandler回调块</span></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在主队列即主线程中发送通知</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果网络任务成功完成，异步在并发队列中执行数据处理</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="comment">//序列化响应数据</span></span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line">            <span class="comment">//如果是下载任务设置响应数据为文件的url</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果响应对象序列化成功或是文件url就设置相关字典key-value</span></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果序列化出错，设置相关字典值</span></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同理，在dispatch组中和特定队列执行回调块</span></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//主线程发送通知</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionDataDelegate</span></span><br><span class="line"><span class="comment">//回调方法，收到数据</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置下载进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class="line">    <span class="comment">//添加数据到mutableData</span></span><br><span class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传任务的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123;</span><br><span class="line">    <span class="comment">//设置上传进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.completedUnitCount = task.countOfBytesSent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLSessionDownloadDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务的回调方法</span></span><br><span class="line"><span class="comment">//由于NSURLSession的downloadTask直接将文件下载到磁盘沙盒中，所以不需要mutableData自行接收数据</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</span><br><span class="line">    <span class="comment">//设置下载进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = totalBytesExpectedToWrite;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = totalBytesWritten;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复下载任务的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes&#123;</span><br><span class="line">    <span class="comment">//设置下载进度的相关属性</span></span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = expectedTotalBytes;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = fileOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务下载文件完成后的回调方法</span></span><br><span class="line"><span class="comment">//location就是文件下载到磁盘沙盒目录的NSURL</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置downloadFileURL为nil</span></span><br><span class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果有下载完成的回调块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="comment">//执行该回调块，这个回调块返回一个下载的文件保存的路径URL</span></span><br><span class="line">        <span class="comment">//默认保存在沙盒tmp文件中，可能会被删除，需要持久化时要自己设置一个目录存储</span></span><br><span class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="comment">//如果需要移动文件的路径使用NSFileManaegr移动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError]) &#123;</span><br><span class="line">                <span class="comment">//文件移动发生错误发送通知</span></span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AFURLSessionManagerTaskDelegate的源码，主要就是关联一个NSURLSessionTask并实现了相关任务的代理方法用于数据的获取、上传文件和下载文件。需要注意的是NSURLSessionTask的delegate属性是只读的，只能在使用session创建task的函数中传入代理对象，而且通过源码也没有发现相关代理的设置，所以AFURLSessionManagerTaskDelegate类实现相关代理是为了其他类手动调用相关方法，AFURLSessionManager也实现了这些代理，所以具体的调用是由AFURLSessionManger手动触发的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNSURLSessionTaskDidResumeNotification  = <span class="string">@"com.alamofire.networking.nsurlsessiontask.resume"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNSURLSessionTaskDidSuspendNotification = <span class="string">@"com.alamofire.networking.nsurlsessiontask.suspend"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_AFURLSessionTaskSwizzling</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_AFURLSessionTaskSwizzling</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     WARNING: Trouble Ahead</span></span><br><span class="line"><span class="comment">     https://github.com/AFNetworking/AFNetworking/pull/2702</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky.</span></span><br><span class="line"><span class="comment">         Many Unit Tests have been built to validate as much of this behavior has possible.</span></span><br><span class="line"><span class="comment">         Here is what we know:</span></span><br><span class="line"><span class="comment">            - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn't actually the type of class you will get back.</span></span><br><span class="line"><span class="comment">            - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there.</span></span><br><span class="line"><span class="comment">            - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`.</span></span><br><span class="line"><span class="comment">            - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`.</span></span><br><span class="line"><span class="comment">            - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled.</span></span><br><span class="line"><span class="comment">            - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled.</span></span><br><span class="line"><span class="comment">            - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there.</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">         Some Assumptions:</span></span><br><span class="line"><span class="comment">            - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we'd need to handle it.</span></span><br><span class="line"><span class="comment">            - No background task classes override `resume` or `suspend`</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         The current solution:</span></span><br><span class="line"><span class="comment">            1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task.</span></span><br><span class="line"><span class="comment">            2) Grab a pointer to the original implementation of `af_resume`</span></span><br><span class="line"><span class="comment">            3) Check to see if the current class has an implementation of resume. If so, continue to step 4.</span></span><br><span class="line"><span class="comment">            4) Grab the super class of the current class.</span></span><br><span class="line"><span class="comment">            5) Grab a pointer for the current class to the current implementation of `resume`.</span></span><br><span class="line"><span class="comment">            6) Grab a pointer for the super class to the current implementation of `resume`.</span></span><br><span class="line"><span class="comment">            7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods</span></span><br><span class="line"><span class="comment">            8) Set the current class to the super class, and repeat steps 3-8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#pragma GCC diagnostic push</span></span><br><span class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wnonnull"</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionTaskState</span>)state &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"State method should never be called in the actual dummy class"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSURLSessionTaskStateCanceling</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里用到了method-swizzling的技术，交换了 resume 和 suspend方法的实现，因为iOS7和iOS8中NSURLSessionTask的父类不同，需要做一些处理（发送task暂停、继续通知）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManager</span> ()</span></span><br><span class="line"><span class="comment">//管理的session运行模式，默认情况下使用默认运行模式，defaultConfiguration</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NSOperation队列，代理方法执行的队列</span></span><br><span class="line"><span class="comment">.h文件里是readonly，所以这里定义一个readwrite用于赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"><span class="comment">//管理的session，readwrite</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="comment">//可变字典，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class="line"><span class="comment">//只读属性，通过getter返回数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *taskDescriptionForSessionTasks;</span><br><span class="line"><span class="comment">//NSLock锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> *lock;</span><br><span class="line"><span class="comment">//下面是一系列回调块</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>延展里面定义了一些属性和响应的回调block。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFURLSessionManager</span></span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有指定session运行模式就使用默认的</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line">    <span class="comment">//创建代理方法执行的队列，最大并发数为1，即串行队列</span></span><br><span class="line">    <span class="comment">//感觉这里设置为1是为了让回调一个个执行</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建session，注意代理对象是self</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line">    <span class="comment">//创建响应序列化器</span></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    <span class="comment">//设置默认安全策略</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="comment">//获取网络可达性manager</span></span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取session中的任务，并调用相关方法关联AFURLSessionManagerTaskDelegate</span></span><br><span class="line"><span class="comment">    不太明白这里为什么要这么做，刚创建的session应该没有任何任务在执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构方法，移除所有通知监听</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法里面有一个有一个不明白的点，创建完session之后就去获取它正在执行的任务，刚创建完session为何会有任务呢？<br>这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//taskDescriptionForSessionTasks属性的getter，返回地址的字符串形式数据，可以保证这个字符串是唯一的</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)taskDescriptionForSessionTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通知的回调方法，接下来的代码会添加相关通知</span></span><br><span class="line">- (<span class="keyword">void</span>)taskDidResume:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//发送通知的时候会将task添加进通知中</span></span><br><span class="line">    <span class="built_in">NSURLSessionTask</span> *task = notification.object;</span><br><span class="line">    <span class="comment">//判断这个任务是否是当前manager管理的，如果是就发送相关通知</span></span><br><span class="line">    <span class="comment">//task的taskDescription属性在下文的源码中会设置</span></span><br><span class="line">    <span class="keyword">if</span> ([task respondsToSelector:<span class="keyword">@selector</span>(taskDescription)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([task.taskDescription isEqualToString:<span class="keyword">self</span>.taskDescriptionForSessionTasks]) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">- (<span class="keyword">void</span>)taskDidSuspend:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionTask</span> *task = notification.object;</span><br><span class="line">    <span class="keyword">if</span> ([task respondsToSelector:<span class="keyword">@selector</span>(taskDescription)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([task.taskDescription isEqualToString:<span class="keyword">self</span>.taskDescriptionForSessionTasks]) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是通知的回调方法，用于通知resume和suspend事件。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据task获取相关联的AFURLSessionManagerTaskDelegate对象</span></span><br><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="comment">//task不能为空</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="comment">//上锁，通过task的唯一taskIdentifier从字典中取值，这个唯一标识是在创建task的时候NSURLSessionTask为其设置的，不需要手动设置，保证唯一性</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    delegate = <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为task设置关联的delegate</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//task和delegate都不能为空</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line">    <span class="comment">//上锁，向字典中添加key-value对</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点方法，为dataTask创建一个关联的AFURLSessionManagerTaskDelegate对象</span></span><br><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建AFURLSessionManagerTaskDelegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    <span class="comment">//设置相关属性</span></span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置task的taskDescription，注意和taskIdentifier区分</span></span><br><span class="line"><span class="comment">    taskDescription是开发者自行设置的</span></span><br><span class="line"><span class="comment">    taskIdentifier是NSURLSessionTask设置的，保证每一个task的id不同</span></span><br><span class="line"><span class="comment">    这里设置的taskDescription就是AFURLSessionManager的地址</span></span><br><span class="line"><span class="comment">    所以同一个manager创建的task的description都是一致的</span></span><br><span class="line"><span class="comment">    设置这个值的目的就是为了区分task是否是当前manger创建的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    <span class="comment">//调用上面的方法将task-delegate键值对添加进字典中</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line">    <span class="comment">//设置回调块</span></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，创建上传任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中</span></span><br><span class="line">- (<span class="keyword">void</span>)addDelegateForUploadTask:(<span class="built_in">NSURLSessionUploadTask</span> *)uploadTask</span><br><span class="line">                        progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">               completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    uploadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:uploadTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，创建下载文件任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中</span></span><br><span class="line">- (<span class="keyword">void</span>)addDelegateForDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">                          progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                       destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                 completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    需要注意下，AFURLSessionManagerTaskDelegate中下载文件完成后会调用delegate.downloadTaskDidFinishDownloading回调块</span></span><br><span class="line"><span class="comment">    来获取下载文件要移动到的目录URL</span></span><br><span class="line"><span class="comment">    所以这里就是创建这个回调块，直接返回参数中的destination回调块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (destination) &#123;</span><br><span class="line">        delegate.downloadTaskDidFinishDownloading = ^<span class="built_in">NSURL</span> * (<span class="built_in">NSURLSession</span> * __unused session, <span class="built_in">NSURLSessionDownloadTask</span> *task, <span class="built_in">NSURL</span> *location) &#123;</span><br><span class="line">            <span class="keyword">return</span> destination(location, task.response);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    downloadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line"></span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从字典中删除task对应的delegate的key-value对</span></span><br><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是对AFURLSessionManagerTaskDelegate的创建、添加进字典、删除、获取的操作，这样就实现了每一个NSURLSessionTask对应一个AFURLSessionManagerTaskDelegate对象，可能读者会有疑问，AFURLSessionManager既然已经实现了代理的方法，为什么不直接使用它来处理代理方法，为什么要创建一个类来专门处理，继续看完源码可能你就会明白了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据keyPath获取不同类型任务的集合</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tasksForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    __block <span class="built_in">NSArray</span> *tasks = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//创建一个信号量，值是0</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个方法是异步的，所以为了同步返回结果，需要使用锁，信号量值设置为0或者1时就可以当锁来使用了</span></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(dataTasks))]) &#123;</span><br><span class="line">            tasks = dataTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(uploadTasks))]) &#123;</span><br><span class="line">            tasks = uploadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(downloadTasks))]) &#123;</span><br><span class="line">            tasks = downloadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(tasks))]) &#123;</span><br><span class="line">            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:<span class="string">@"@unionOfArrays.self"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal通知信号量，信号量值加1</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//等待信号量，直到值大于0，等待时间是forever</span></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是tasks、dataTasks、uploadTasks、downloadTasks属性的getter，都是调用上述方法来获取对应类型的任务集合</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)dataTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)uploadTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)downloadTasks &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tasksForKeyPath:<span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//设置session无效，根据参数判断是否需要取消正在执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionCancelingTasks:(<span class="built_in">BOOL</span>)cancelPendingTasks &#123;  </span><br><span class="line">    <span class="comment">//调用NSURLSession对应的方法来设置session无效，同时打破引用循环</span></span><br><span class="line">    <span class="keyword">if</span> (cancelPendingTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session invalidateAndCancel];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//responseSerializer的setter</span></span><br><span class="line">- (<span class="keyword">void</span>)setResponseSerializer:(<span class="keyword">id</span> &lt;AFURLResponseSerialization&gt;)responseSerializer &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(responseSerializer);</span><br><span class="line"></span><br><span class="line">    _responseSerializer = responseSerializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//添加通知，taskDidResume、taskDidSuspend方法前面讲过了</span></span><br><span class="line">- (<span class="keyword">void</span>)addNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除通知</span></span><br><span class="line">- (<span class="keyword">void</span>)removeNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法是一些getter和setter，很简单，不再赘述。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并返回NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                            completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithRequest:request uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:completionHandler];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并返回NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了解决iOS8一下的一个bug，调用一个串行队列来创建dataTask</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        <span class="comment">//使用session来创建一个NSURLSessionDataTask对象</span></span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//为这个task创建一个AFURLSessionManagerTaskDelegate并关联加入字典中</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//创建一个NSURLSessionUploadTask对象</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                                         progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromFile:fileURL];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uploadTask may be nil on iOS7 because uploadTaskWithRequest:fromFile: may return nil despite being documented as nonnull (https://devforums.apple.com/message/926113#926113)</span></span><br><span class="line">    <span class="comment">//解决iOS7的一个bug按照配置的尝试次数创建上传任务，默认尝试3次</span></span><br><span class="line">    <span class="keyword">if</span> (!uploadTask &amp;&amp; <span class="keyword">self</span>.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; <span class="keyword">self</span>.session.configuration.identifier) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> attempts = <span class="number">0</span>; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123;</span><br><span class="line">            uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromFile:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建关联的delegate并添加到字典中</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromData:(<span class="built_in">NSData</span> *)bodyData</span><br><span class="line">                                         progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromData:bodyData];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                 progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                        completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithStreamedRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="comment">//创建下载任务，同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                             progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                          destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                    completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        downloadTask = [<span class="keyword">self</span>.session downloadTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建下载任务，同上</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData</span><br><span class="line">                                                progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                             destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                       completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        downloadTask = [<span class="keyword">self</span>.session downloadTaskWithResumeData:resumeData];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法就是AFURLSessionManager为我们提供的获取NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask的方法，上面这些方法主要目的就是传入进度或完成回调块，然后构造一个AFURLSessionManagerTaskDeleagte对象并关联，这样就不需要开发者自行实现和管理代理方法做相关数据处理，只需要在回调块中做处理即可。</p><p>接下来源码中是一系列回调块的setter方法，就不列下来了，读者可以自己看看。接下来就讲解重点的各种代理的回调方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//session无效后的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果回调块存在就执行回调块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送对应通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到服务端的challenge，例如https需要验证证书等</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有对应回调块就执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//处理https</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个方法是NSURLSessionDelegate的方法，关于验证HTTPS的部分代码可以当做模板代码来写，具体内容不是本文讲解范畴，读者可自行查阅。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要执行重定向的代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">        newRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//套路就是执行用户自定义的回调块，执行完成回调块</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        redirectRequest = <span class="keyword">self</span>.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同前面一样，处理https链接</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理需要一个新的流</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line"> needNewBodyStream:(<span class="keyword">void</span> (^)(<span class="built_in">NSInputStream</span> *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用用户自定义的回调块来获取，或者copy一个</span></span><br><span class="line">    <span class="built_in">NSInputStream</span> *inputStream = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = <span class="keyword">self</span>.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">NSCopying</span>)]) </span>&#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上传任务的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取上传的总大小，如果数据不正确就从http首部中获取</span></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">if</span>(totalUnitCount == <span class="built_in">NSURLSessionTransferSizeUnknown</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *contentLength = [task.originalRequest valueForHTTPHeaderField:<span class="string">@"Content-Length"</span>];</span><br><span class="line">        <span class="keyword">if</span>(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取task关联的AFURLSessionManagerTaskDelegate对象</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line">    <span class="comment">//如果代理对象存在，就调用代理对象的这个方法</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果用户自定义回调块存在，执行回调块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidSendBodyData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务完成的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//同样的套路，获取关联的代理对象，手动调用代理对象的这个方法，执行用户自定义的回调块</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是NSURLSessionTaskDelegate的回调方法，通过上面的代码可以发现AFURLSessionManagerTaskDelegate的作用了，AFURLSessionManager的代理方法中会根据task获取到对应的delegate，如果需要提前处理一些数据就先处理，处理完成后手动触发delegate中的对应方法，然后具体的数据处理就交由AFURLSessionManagerTaskDelegate来处理。继续看其他代理方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务端响应的代理回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用用户自定义回调块，执行完成回调块</span></span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:dataTask];</span><br><span class="line">        [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取代理，然后调用代理的这个方法，有自定义回调块就执行</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = <span class="keyword">self</span>.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是NSURLSessionDataDelegate的代理方法，同样的，如果AFURLSessionManagerTaskDelegate能响应的关于数据处理的方法都会通过task找到对应delegate后调用其对应的方法，然后执行用户自定义的回调块，如果代理不能响应的方法就由AFURLSessionManager自行处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载任务下载文件完成后的回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取对应的代理对象</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//如果downloadTaskDidFinishDownloading回调块存在就执行它来获取一个保存文件的URL路径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *fileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="comment">//如果这个路径存在就通过NSFileManager来移动，移动失败发送通知</span></span><br><span class="line">        <span class="keyword">if</span> (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过task获取delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//如果delegate存在就调用其该方法</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果回调块存在就执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidWriteData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同上套路</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidResume) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在为止，AFURLSessionManager所有源码都看完了，代码封装了NSURLSession并提供了简洁的创建NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask对象的方法，使用人员可以不需要考虑具体的数据处理过程，最简单的可以只通过回调块来获取网络请求的各种信息。在具体实现上，AFURLSessionManager通过定义AFURLSessionManagerTaskDelegate来做具体task的数据处理，而AFURLSessionManager只关注于通用部分的实现，并提供各种方法和回调块用于处理task，使得代码结构更清晰，AFURLSessionManager代理方法结构也更简单。</p><p>AFURLSessionManager个人总结</p><ol><li>AFURLSessionManagerTaskDelegate 是为了对应每一个task，单独定义一个类，解耦合，代码逻辑更清晰</li><li>mutableData 在请求完成之后置位 nil，节省内存</li><li>dispatch_semaphore的使用，信号量线程同步</li><li>method swizzing巧妙监听 task 的 suspend 和 resume</li><li>NSLock 安全加锁，避免字典中假如的 delegate 和 task不对应</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="AFNetWorking原理" scheme="http://yoursite.com/tags/AFNetWorking%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Github Blog With Hexo</title>
    <link href="http://yoursite.com/2019/06/21/hello-world/"/>
    <id>http://yoursite.com/2019/06/21/hello-world/</id>
    <published>2019-06-21T07:40:42.265Z</published>
    <updated>2019-06-24T10:16:01.754Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
