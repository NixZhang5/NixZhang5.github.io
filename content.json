{"meta":{"title":"Xinping's Blog","subtitle":"因为有了危机感，所以才会义无反顾。","description":"积累 记录 传播 共进","author":"张新平","url":"https://nixzhang5.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-06-24T10:03:14.000Z","updated":"2019-06-24T10:25:07.974Z","comments":true,"path":"categories/index.html","permalink":"https://nixzhang5.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-24T10:08:50.000Z","updated":"2019-06-24T10:25:34.397Z","comments":true,"path":"tags/index.html","permalink":"https://nixzhang5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WKWebView和UIWebView对比","slug":"WKWebView和UIWebView","date":"2019-07-01T03:51:54.000Z","updated":"2019-07-01T10:52:12.776Z","comments":true,"path":"WKWebView和UIWebView.html","link":"","permalink":"https://nixzhang5.github.io/WKWebView和UIWebView.html","excerpt":"WKWebView和UIWebViewUIWebView自iOS2就有，WKWebView从iOS8才有，毫无疑问WKWebView将逐步取代笨重的UIWebView。通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度也有提升，但是并不像内存那样提升那么多。","text":"WKWebView和UIWebViewUIWebView自iOS2就有，WKWebView从iOS8才有，毫无疑问WKWebView将逐步取代笨重的UIWebView。通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度也有提升，但是并不像内存那样提升那么多。 WKWebView的优势： 性能和稳定性的大幅提高 内存占用的减少，大概是UIWebView的1/4 - 1/3 更多的支持HTML5的特性 允许JavaScript的Nitro的库加载并使用（移动设备的 Safari 使用 Nitro 引擎，但是 UIWebView 不包括 JIT 编译，所以不支持，体验会慢一些） 官方宣称的高达60fps的滚动刷新率以及内置手势 Safari相同的JavaScript引擎 将UIWebViewDelegate与UIWebView拆分成了14类与3个协议(官方文档说明)，JS交互方便 另外用的比较多的，增加加载进度属性：estimatedProgress WKWebView的缺点： 不自带cookie 获取cookie 不支持自定义NSURLProtocol，否则无法发送POST参数 UIWebView OC和JS相互调用OC调用JS代码 1- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)string; JS调用OC代码在代理方法里面拦截实现 1234让Native 代码拦截， - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest:)request navigationType:(UIWebViewNavigationType)navigationType; WKWebView OC和JS相互调用OC调用JSWKWebView 本身提供一个方法进行处理JS代码 1- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^_Nullable)(_Nullable id,NSError * _Nullable error))completionHandler; JS调用OCJS端调用操作 1window.webkit.messageHandlers.&lt;方法名&gt;.postMessage(&lt;数据&gt;) 在OC中的处理方法 1- (void)addScriptMessageHandler:(id&lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name; 使用方法 1234567//设置addScriptMessageHandler与name.并且设置&lt;WKScriptMessageHandler&gt;协议与协议方法[[_webView configuration].userContentController addScriptMessageHandler:self name:@\"方法名\"];//WKScriptMessageHandler协议方法- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; //code&#125; 这里会导致内存泄露，因为这里userContentController持有了self，然后 userContentController 又被configuration持有，最终被webview持有，然后webview是self的一个私有变量，所以self也持有self。 解决办法： 在viewWillAppear和viewWillDisappear注册和移除 将传入的vc实例参数通过一个过度类来实现，此时vc的dealloc方法会调用在销毁方法里边释放掉注册的方法 Cookie问题cookie（是存储在客户端的，本质是个字符串）:cookie是随着数据请求，传来传去的，也就是每个request，response，都携带有cookiecookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失 WKWebView Cookie存储业界普遍认为 WKWebView 拥有自己的私有存储，不会将 Cookie 存入到标准的 Cookie 容器 NSHTTPCookieStorage 中。 实践发现 WKWebView 实例其实也会将 Cookie 存储于 NSHTTPCookieStorage 中，但存储时机有延迟，在iOS 8上，当页面跳转的时候，当前页面的 Cookie 会写入 NSHTTPCookieStorage 中，而在 iOS 10 上，JS 执行 document.cookie 或服务器 set-cookie 注入的 Cookie 会很快同步到 NSHTTPCookieStorage 中。 WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。 比如，NSHTTPCookieStorage 中存储了一个 Cookie: 1name=Nicholas;value=test;domain=y.qq.com;expires=Sat, 02 May 2019 23:38:25 GMT； 通过 UIWebView 发起请求，则请求头会自动带上 cookie: Nicholas=test；而通过 WKWebView发起请求，请求头不会自动带上 cookie: Nicholas=test。 WKProcessPool通过让所有 WKWebView 共享同一个 WKProcessPool 实例，可以实现多个 WKWebView 之间共享 Cookie（session Cookie and persistent Cookie）数据。不过 WKWebView WKProcessPool 实例在 app 杀进程重启后会被重置，导致 WKProcessPool 中的 Cookie、session Cookie 数据丢失，目前也无法实现 WKProcessPool 实例本地化保存。 Workaround由于许多 H5 业务都依赖于 Cookie 作登录态校验，而 WKWebView 上请求不会自动携带 Cookie, 目前的主要解决方案是： a、WKWebView loadRequest 前，在 request header 中设置 Cookie, 解决首个请求 Cookie 带不上的问题； 12345WKWebView * webView = [WKWebView new]; NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://h5.qzone.qq.com/mqzone/index\"]]; [request addValue:@\"skey=skeyValue\" forHTTPHeaderField:@\"Cookie\"]; [webView loadRequest:request]; b、通过 document.cookie 设置 Cookie 解决后续页面(同域)Ajax、iframe 请求的 Cookie 问题；注意：document.cookie()无法跨域设置 cookie 1234WKUserContentController* userContentController = [WKUserContentController new]; WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource: @\"document.cookie = 'skey=skeyValue';\" injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; [userContentController addUserScript:cookieScript]; 这种方案无法解决302请求的 Cookie 问题，比如，第一个请求是 www.a.com, 我们通过在 request header 里带上 Cookie 解决该请求的 Cookie 问题，接着页面302跳转到 www.b.com, 这个时候 www.b.com 这个请求就可能因为没有携带 cookie 而无法访问。当然，由于每一次页面跳转前都会调用回调函数： 1- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler; 可以在该回调函数里拦截302请求，copy request，在 request header 中带上 cookie 并重新 loadRequest。不过这种方法依然解决不了页面 iframe 跨域请求的 Cookie 问题，毕竟-[WKWebView loadRequest:]只适合加载 mainFrame 请求。 白屏问题WKWebView 自诩拥有更快的加载速度，更低的内存占用，但实际上 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行。初次适配 WKWebView 的时候，我们也惊讶于打开 WKWebView 后，App 进程内存消耗反而大幅下降，但是仔细观察会发现，Other Process 的内存占用会增加。在一些用 webGL 渲染的复杂页面，使用 WKWebView 总体的内存占用（App Process Memory + Other Process Memory）不见得比 UIWebView 少很多。 在 UIWebView 上当内存占用太大的时候，App Process 会 crash；而在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。 这个时候 WKWebView.URL 会变为 nil, 简单的 reload 刷新操作已经失效，对于一些长驻的H5页面影响比较大。 解决方案： 借助 WKNavigtionDelegateiOS 9以后 WKNavigtionDelegate 新增了一个回调函数：1- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)); 当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行[webView reload](这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。 检测 webView.title 是否为空并不是所有H5页面白屏的时候都会调用上面的回调函数，比如，最近遇到在一个高内存消耗的H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，WebContent Process 被系统挂起），但上面的回调函数并没有被调用。在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空, 因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。 NSURLProtocol问题WKWebView 在独立于 app 进程之外的进程中执行网络请求，请求数据不经过主进程，因此，在 WKWebView 上直接使用 NSURLProtocol 无法拦截请求。苹果开源的 webKit2 源码暴露了私有API： 1+ [WKBrowsingContextController registerSchemeForCustomProtocol:] 通过注册 http(s) scheme 后 WKWebView 将可以使用 NSURLProtocol 拦截 http(s) 请求： 1234567Class cls = NSClassFromString(@\"WKBrowsingContextController”); SEL sel = NSSelectorFromString(@\"registerSchemeForCustomProtocol:\"); if ([(id)cls respondsToSelector:sel]) &#123; // 注册http(s) scheme, 把 http和https请求交给 NSURLProtocol处理 [(id)cls performSelector:sel withObject:@\"http\"]; [(id)cls performSelector:sel withObject:@\"https\"]; &#125; 但是这种方案目前存在两个严重缺陷： post 请求 body 数据被清空由于 WKWebView 在独立进程里执行网络请求。一旦注册 http(s) scheme 后，网络请求将从 Network Process 发送到 App Process，这样 NSURLProtocol 才能拦截网络请求。在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了。 因此，如果通过 registerSchemeForCustomProtocol 注册了 http(s) scheme, 那么由 WKWebView 发起的所有 http(s)请求都会通过 IPC 传给主进程 NSURLProtocol 处理，导致 post 请求 body 被清空； 对ATS支持不足测试发现一旦打开ATS开关：Allow Arbitrary Loads 选项设置为NO，同时通过 registerSchemeForCustomProtocol 注册了 http(s) scheme，WKWebView 发起的所有 http 网络请求将被阻塞（即便将Allow Arbitrary Loads in Web Content 选项设置为YES）； WKWebView 可以注册 customScheme, 比如 dynamic://, 因此希望使用离线功能又不使用 post 方式的请求可以通过 customScheme 发起请求，比如 dynamic://www.dynamicalbumlocalimage.com/, 然后在 app 进程 NSURLProtocol 拦截这个请求并加载离线数据。不足：使用 post 方式的请求该方案依然不适用，同时需要 H5 侧修改请求 scheme 以及 CSP 规则； loadRequest 问题在 WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失： 1234//同样是由于进程间通信性能问题，HTTPBody字段被丢弃[request setHTTPMethod:@\"POST\"];[request setHTTPBody:[@\"bodyData\" dataUsingEncoding:NSUTF8StringEncoding]];[wkwebview loadRequest: request]; workaround:假如想通过-[WKWebView loadRequest:]加载 post 请求 request1: http://h5.qzone.qq.com/mqzone/index, 可以通过以下步骤实现： 替换请求 scheme，生成新的 post 请求 request2: post://h5.qzone.qq.com/mqzone/index, 同时将 request1 的 body 字段复制到 request2 的 header 中（WebKit 不会丢弃 header 字段）; 通过-[WKWebView loadRequest:]加载新的 post 请求 request2; 通过 +[WKBrowsingContextController registerSchemeForCustomProtocol:]注册 scheme: post://; 注册 NSURLProtocol 拦截请求post://h5.qzone.qq.com/mqzone/index ,替换请求 scheme, 生成新的请求 request3: http://h5.qzone.qq.com/mqzone/index, 将 request2 header的body 字段复制到 request3 的 body 中，并使用 NSURLConnection 加载 request3，最后通过 NSURLProtocolClient 将加载结果返回 WKWebView; 样式问题在 WKWebView 适配过程中，我们发现部分H5页面元素位置向下偏移或被拉伸变形，追踪后发现主要是H5页面高度值异常导致： a. 空间H5页面有透明导航、透明导航下拉刷新、全屏等需求，因此之前 webView 整个是从（0, 0）开始布局，通过调整webView.scrollView.contentInset 来适配特殊导航栏需求。而在 WKWebView 上对 contentInset 的调整会反馈到webView.scrollView.contentSize.height的变化上，比如设置 webView.scrollView.contentInset.top = a，那么contentSize.height的值会增加a,导致H5页面长度增加，页面元素位置向下偏移； 解决方案是：调整WKWebView布局方式，避免调整webView.scrollView.contentInset。实际上，即便在 UIWebView 上也不建议直接调整webView.scrollView.contentInset的值，这确实会带来一些奇怪的问题。如果某些特殊情况下非得调整 contentInset 不可的话，可以通过下面方式让H5页面恢复正常显示： 12345/**设置contentInset值后通过调整webView.frame让页面恢复正常显示 *参考：http://km.oa.com/articles/show/277372 */ webView.scrollView.contentInset = UIEdgeInsetsMake(a, 0, 0, 0); webView.frame = CGRectMake(webView.frame.origin.x, webView.frame.origin.y, webView.frame.size.width, webView.frame.size.height - a); b. 在接入 now 直播的时候，我们发现在 iOS 9 上 WKWebView 会出现页面被拉伸变形的情况，最后发现是window.innerHeight值不准确导致（在WKWebView上返回了一个非常大的值），而H5同学通过获取window.innerHeight来设置页面高度，导致页面整体被拉伸。通过查阅相关资料发现，这个bug只在 iOS 9 的几个系统版本上出现，苹果后来fix了这个bug。我们最后的解决方案是：延迟调用window.innerHeight 1setTimeout(function()&#123;height = window.innerHeight&#125;,0); 或者 12Use shrink-to-fit meta-tag &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1, shrink-to-fit=no\"&gt; 截屏问题空间玩吧H5小游戏有截屏分享的功能，WKWebView 下通过 -[CALayer renderInContext:]实现截屏的方式失效，需要通过以下方式实现截屏功能： 123456789@implementation UIView (ImageSnapshot) - (UIImage*)imageSnapshot &#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size,YES,self.contentScaleFactor); [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES]; UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; &#125; @end 然而这种方式依然解决不了 webGL 页面的截屏问题，webKit2 源码里的截屏私有API，也没有找到合适的解决方案，同时发现 Safari 以及 Chrome 这两个全量切换到 WKWebView 的浏览器也存在同样的问题：对webGL 页面的截屏结果不是空白就是纯黑图片。无奈之下，我们只能约定一个JS接口，让游戏开发商实现该接口，具体是通过 canvas getImageData()方法取得图片数据后返回 base64 格式的数据，客户端在需要截图的时候，调用这个JS接口获取 base64 String 并转换成 UIImage。 crash问题WKWebView 放量后，外网新增了一些 crash, 其中一类 crash 的主要堆栈如下： 12345... 28 UIKit 0x0000000190513360 UIApplicationMain + 208 29 Qzone 0x0000000101380570 main (main.m:181) 30 libdyld.dylib 0x00000001895205b8 _dyld_process_info_notify_release + 36 Completion handler passed to -[QZWebController webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:] was not called 主要是JS调用window.alert()函数引起的，从 crash 堆栈可以看出是 WKWebView 回调函数: 1+ (void) presentAlertOnController:(nonnull UIViewController*)parentController title:(nullable NSString*)title message:(nullable NSString *)message handler:(nonnull void (^)())completionHandler; completionHandler 没有被调用导致的。在适配 WKWebView 的时候，我们需要自己实现该回调函数，window.alert()才能调起 alert 框，我们最初的实现是这样的： 123456- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@\"\" message:message preferredStyle:UIAlertControllerStyleAlert]; [alertController addAction:[UIAlertAction actionWithTitle:@\"确认\" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123; completionHandler(); &#125;]]; [self presentViewController:alertController animated:YES completion:^&#123;&#125;]; &#125; 如果 WKWebView 退出的时候，JS刚好执行了window.alert(), alert 框可能弹不出来，completionHandler 最后没有被执行，导致 crash；另一种情况是在 WKWebView 一打开，JS就执行window.alert()，这个时候由于 WKWebView 所在的 UIViewController 出现（push或present）的动画尚未结束，alert 框可能弹不出来，completionHandler 最后没有被执行，导致 crash。我们最终的实现大致是这样的： 12345678910111213- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123; if (/*UIViewController of WKWebView has finish push or present animation*/) &#123; completionHandler(); return; &#125; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@\"\" message:message preferredStyle:UIAlertControllerStyleAlert]; [alertController addAction:[UIAlertAction actionWithTitle:@\"确认\" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123; completionHandler(); &#125;]]; if (/*UIViewController of WKWebView is visible*/) [self presentViewController:alertController animated:YES completion:^&#123;&#125;]; else completionHandler(); &#125; 确保上面两种情况下 completionHandler 都能被执行，消除了 WKWebView 下弹 alert 框的 crash，WKWebView 下弹 confirm 框的 crash 的原因与解决方式与 alert 类似。 另一个 crash 发生在 WKWebView 退出前调用： 1-[WKWebView evaluateJavaScript: completionHandler:] 执行JS代码的情况下。WKWebView 退出并被释放后导致completionHandler变成野指针，而此时 javaScript Core 还在执行JS代码，待 javaScript Core 执行完毕后会调用completionHandler()，导致 crash。这个 crash 只发生在 iOS 8 系统上，参考Apple Open Source，在iOS9及以后系统苹果已经修复了这个bug，主要是对completionHandler block做了copy；对于iOS 8系统，可以通过在 completionHandler 里 retain WKWebView 防止 completionHandler 被过早释放。我们最后用 methodSwizzle hook 了这个系统方法： 1234567891011121314151617+ (void) load &#123; [self jr_swizzleMethod:NSSelectorFromString(@\"evaluateJavaScript:completionHandler:\") withMethod:@selector(altEvaluateJavaScript:completionHandler:) error:nil]; &#125; /* * fix: WKWebView crashes on deallocation if it has pending JavaScript evaluation */ - (void)altEvaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *))completionHandler &#123; id strongSelf = self; [self altEvaluateJavaScript:javaScriptString completionHandler:^(id r, NSError *e) &#123; [strongSelf title]; if (completionHandler) &#123; completionHandler(r, e); &#125; &#125;]; &#125; 其他问题视频自动播放WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。 goBack API问题WKWebView 上调用 -[WKWebView goBack], 回退到上一个页面后不会触发window.onload()函数、不会执行JS。 页面滚动速率WKWebView 需要通过scrollView delegate调整滚动速率： 123- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123; scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;&#125; 优化初始化优化WKWebView初始化耗时长（启动浏览器内核），初始化之后才去加载。 优化方案： 全局WebView，打开app，创建一个全局的webView隐藏起来备用 额外的内存开销 页面跳转需要清空上一个页面的痕迹，更容易内存泄露 客户端代理数据请求，初始化webView的同时进行网络请求数据，同步进行 建立连接/服务器处理在页面请求的数据返回之前，主要有以下过程耗费时间。 DNS connection 服务器处理 优化方案： DNS采用和客户端API相同的域名DNS会在系统级别进行缓存，对于WebView的地址，如果使用的域名与native的API相同，则可以直接使用缓存的DNS而不用再发起请求图片。 以美团为例，美团的客户端请求域名主要位于api.meituan.com，然而内嵌的WebView主要位于 i.meituan.com。 当我们初次打开App时： 客户端首次打开都会请求api.meituan.com，其DNS将会被系统缓存。 然而当打开WebView的时候，由于请求了不同的域名，需要重新获取i.meituan.com的IP。 根据上面的统计，至少10%的用户打开WebView时耗费了60ms在DNS上面，如果WebView的域名与App的API域名统一，则可以让WebView的DNS时间全部达到1.3ms的量级。 静态资源同理，最好与客户端的资源域名保持一致。 同步渲染采用chunk编码同步渲染时如果后端请求时间过长，可以考虑采用chunk编码，将数据放在最后，并优先将静态内容flush。对于传统的后端渲染页面，往往都是使用的【浏览器】–&gt; 【Web API】 –&gt; 【业务 API】的加载模式，其中后端时间就指的是Web API的处理时间了。在这里Web API一般有两个作用： 确定静态资源的版本。 根据用户的请求，去业务API获取数据。 而一般确定静态资源的版本往往是直接读取代码版本，基本无耗时；而主要的后端时间都花费在了业务API请求上面。 那么怎么优化利用这段时间呢？ 在HTTP协议中，我们可以在header中设置 transfer-encoding:chunked 使得页面可以分块输出。如果合理设计页面，让head部分都是确定的静态资源版本相关内容，而body部分是业务数据相关内容，那么我们可以在用户请求的时候，首先将Web API可以确定的部分先输出给浏览器，然后等API完全获取后，再将API数据传输给浏览器。 分chunk输出和一起输出的区别： 如果采用普通方式输出页面，则页面会在服务器请求完所有API并处理完成后开始传输。浏览器要在后端所有API都加载完成后才能开始解析。 如果采用chunk-encoding: chunked，并优先将页面的静态部分输出；然后处理API请求，并最终返回页面，可以让后端的API请求和前端的资源加载同时进行。 两者的总共后端时间并没有区别，但是可以提升首字节速度，从而让前端加载资源和后端加载API不互相阻塞。 页面框架渲染页面在解析到足够多的节点，且所有CSS都加载完成后进行首屏渲染。在此之前，页面保持白屏；在页面完全下载并解析完成之前，页面处于不完整展示状态。 1234567891011.....&lt;link href=\"//ms0.meituan.net/css/eve.9d9eee71.css\" rel=\"stylesheet\" onload=\"MT.pageData.eveTime=Date.now()\"/&gt;&lt;script&gt;window.fk = function (callback) &#123;require(['util/native/risk.js'], function (risk) &#123; risk.getFk(callback);&#125;);&#125;&lt;/script&gt;&lt;/head&gt;.... 通常情况下，上面代码的link部分和script部分如果单独出现，都不会阻塞页面的解析： CSS不会阻止页面继续向下继续。 内联的JS很快执行完成，然后继续解析文档。 然而，当这两部分同时出现的时候，问题就来了。 CSS加载阻塞了下面的一段内联JS的执行，而被阻塞的内联JS则阻塞了HTML的解析。 通常情况下，CSS不会阻塞HTML的解析，但如果CSS后面有JS，则会阻塞JS的执行直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。 优化：在页面框架加载这一部分，能够优化的点参照雅虎14条就够了；但注意不要犯错，一个小小的内联JS放错位置也会让性能下降很多。 CSS的加载会在HTML解析到CSS的标签时开始，所以CSS的标签要尽量靠前。 但是，CSS链接下面不能有任何的JS标签（包括很简单的内联JS），否则会阻塞HTML的解析。 如果必须要在头部增加内联脚本，一定要放在CSS标签之前。 JS加载经过测试可以得出以下结论： 偏重的框架，例如React，仅仅初始化的时间就会达到50ms ~ 350ms，这在对性能敏感的业务中时比较不利的。 在App的启动周期内，统一域名下的代码会被缓存编辑和初始化结果，重复调用性能较好。 所以，在移动浏览器上，JS的解析和执行时间并不是不可忽略的。 在低端安卓机上，（框架的初始化+异步数据请求+业务代码执行）会远高于几KB网络请求时间；高性能的Web网站需要仔细斟酌前端渲染带来的性能问题。 优化： 高性能要求页面还是需要后端渲染。 React还是太重了，面向用户写系统需要谨慎考虑。 JS代码的编译和执行会有缓存，同App中网页尽量统一框架。 WebView性能优化总结一个加载网页的过程中，native、网络、后端处理、CPU都会参与，各自都有必要的工作和依赖关系；让他们相互并行处理而不是相互阻塞才可以让网页加载更快： WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。 后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。 脚本执行慢，就让脚本在最后运行，不阻塞页面解析。 同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。 WebView初始化慢，就随时初始化好一个WebView待用。 DNS和链接慢，想办法复用客户端使用的域名和链接。 脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"WebView","slug":"WebView","permalink":"https://nixzhang5.github.io/tags/WebView/"}]},{"title":"AFNetWorking原理五 AFNetworkReachabilityManager","slug":"AFNetWorking原理五","date":"2019-06-30T02:25:55.000Z","updated":"2019-07-01T03:37:15.700Z","comments":true,"path":"AFNetWorking原理五.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorking原理五.html","excerpt":"AFNetworkReachabilityManager类是对接入网络类型的监听。","text":"AFNetworkReachabilityManager类是对接入网络类型的监听。 AFNetworkReachabilityManager使用AFNetworkReachabilityManager对网络的监测使用如下: 123456789101112131415161718192021 AFNetworkReachabilityManager *networkReachManager = [AFNetworkReachabilityManager sharedManager];[networkReachManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; switch (status) &#123; case AFNetworkReachabilityStatusReachableViaWWAN: NSLog(@\"蜂窝网络\"); break; case AFNetworkReachabilityStatusReachableViaWiFi: NSLog(@\"WIFI\"); break; case AFNetworkReachabilityStatusNotReachable: NSLog(@\"没有网络\"); break; case AFNetworkReachabilityStatusUnknown: NSLog(@\"未知\"); break; default: break; &#125;&#125;];// 开始监测网络[networkReachManager startMonitoring]; 当网络状态发生变化时就会执行block, 将网络状态AFNetworkReachabilityStatus返回给我们。 AFNetworkReachabilityManager.h文件1234567891011121314/** 网络类型 - AFNetworkReachabilityStatusUnknown: 未知网络 - AFNetworkReachabilityStatusNotReachable: 网络不可达, 无网络 - AFNetworkReachabilityStatusReachableViaWWAN: 手机网络 - AFNetworkReachabilityStatusReachableViaWiFi: WiFi */typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123; AFNetworkReachabilityStatusUnknown = -1, AFNetworkReachabilityStatusNotReachable = 0, AFNetworkReachabilityStatusReachableViaWWAN = 1, AFNetworkReachabilityStatusReachableViaWiFi = 2,&#125;; 四种网络状态类型。 12345678910111213141516171819/** 当前网络状态 */@property (readonly, nonatomic, assign) AFNetworkReachabilityStatus networkReachabilityStatus;/** 网络是否可用 */@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable;/** 当前连接是否是WWAN */@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN;/** 当前连接是否是WiFi */@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi; 在.h文件中对外提供了4个只读属性, 并且给出了对应的getter方法. 12345678910111213141516171819202122232425262728293031323334/** 单例初始化，调用的manager方法*/+ (instancetype)sharedManager;/** 通过默认的socket地址初始化，返回一个manager对象，sin_family表示协议族，AF_INET表示TCP/IP协议族的地址。 */+ (instancetype)manager;/** 这种方法就是可以根据特定的域来初始化。 */+ (instancetype)managerForDomain:(NSString *)domain;/** manager方法里面又调用了此方法，通过传入一个socket地址来初始化 */+ (instancetype)managerForAddress:(const void *)address;/** managerForAddress、managerForDomain方法里面，都调用了这个初始化方法，因为该方法的后缀里面有NS_DESIGNATED_INITIALIZER，所以最终都会调到它，这里就是做了初始化的工作，将起始的网络状态定为Unknown。 */- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER;/** * 不可用的初始化方法 */+ (instancetype)new NS_UNAVAILABLE;/** * 不可用的初始化方法 */- (instancetype)init NS_UNAVAILABLE; 1234567891011121314151617181920/** 开始监听 */- (void)startMonitoring;/** 结束监听 */- (void)stopMonitoring;/** 返回一个网络状态的字符串 */- (NSString *)localizedNetworkReachabilityStatusString;/** 网络状态改变的回调 监听网络状态的改变有两种方法:1.是实现这个block 2.是监听通知 */- (void)setReachabilityStatusChangeBlock:(nullable void (^)(AFNetworkReachabilityStatus status))block; 12345678910111213/** 网络状态改变时 发送的通知 在userInfo下有以AFNetworkingReachabilityNotificationStatusItem为key的一个NSNumber类型的值, 这个值对应着AFNetworkReachabilityStatus枚举, 反应网络状态 FOUNDATION_EXPORT主要用于定义常量 */FOUNDATION_EXPORT NSString * const AFNetworkingReachabilityDidChangeNotification;FOUNDATION_EXPORT NSString * const AFNetworkingReachabilityNotificationStatusItem;/** Returns a localized string representation of an `AFNetworkReachabilityStatus` value.这个是定义的一个C语言函数, 返回本地化的status字符串 */FOUNDATION_EXPORT NSString * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status); 定义了两个通知的名称, 当网络状态改变时发出的通知, 接收的通知中会有一个userInfo, 可根据key为AFNetworkingReachabilityNotificationStatusItem取出通知的内容. AFNetworkReachabilityManager.m文件12345678910111213141516171819202122// 一个静态字符串, 网络状态发生变化时发出的通知 对应.hNSString * const AFNetworkingReachabilityDidChangeNotification = @\"com.alamofire.networking.reachability.change\";// 网络状态发生变化时发出通知, 携带的数据NSString * const AFNetworkingReachabilityNotificationStatusItem = @\"AFNetworkingReachabilityNotificationStatusItem\";// 定义block类型, 当网络状态改变时调用的blocktypedef void (^AFNetworkReachabilityStatusBlock)(AFNetworkReachabilityStatus status);// 将枚举类型转换成字符串(这是对在.h中声明的实现)NSString * AFStringFromNetworkReachabilityStatus(AFNetworkReachabilityStatus status) &#123; switch (status) &#123; case AFNetworkReachabilityStatusNotReachable: return NSLocalizedStringFromTable(@\"Not Reachable\", @\"AFNetworking\", nil); case AFNetworkReachabilityStatusReachableViaWWAN: return NSLocalizedStringFromTable(@\"Reachable via WWAN\", @\"AFNetworking\", nil); case AFNetworkReachabilityStatusReachableViaWiFi: return NSLocalizedStringFromTable(@\"Reachable via WiFi\", @\"AFNetworking\", nil); case AFNetworkReachabilityStatusUnknown: default: return NSLocalizedStringFromTable(@\"Unknown\", @\"AFNetworking\", nil); &#125;&#125; 12345678910111213141516171819202122static AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) &#123; BOOL isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != 0); BOOL needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != 0); BOOL canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0)); BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == 0); BOOL isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction)); AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown; if (isNetworkReachable == NO) &#123; status = AFNetworkReachabilityStatusNotReachable; &#125;#if TARGET_OS_IPHONE else if ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != 0) &#123; status = AFNetworkReachabilityStatusReachableViaWWAN; &#125;#endif else &#123; status = AFNetworkReachabilityStatusReachableViaWiFi; &#125; return status;&#125; 根据SCNetworkReachabilityFlags这个网络标记转换成AFN中的网络状态static修饰全局, 只能在当前文件使用： 函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，在编译期就会初始化，也就是说这个静态变量值要么为nil，要么在编译期就可以确定其值，生命周期和程序相同，其内存只被分配一次并存储到全局变量区，因此其值在下次调用时仍维持上次的值； 在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问； 在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内； 在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。 修饰局部变量： 延长局部变量的生命周期,程序结束才会销毁。 局部变量只会生成一份内存,只会初始化一次。 改变局部变量的作用域。 修饰全局变量： 只能在本文件中访问,修改全局变量的作用域,生命周期不会改 避免重复定义全局变量 优点： 节省内存。静态变量只存储一处，但供所有对象使用。 它的值是可以更新的。 可提高时间效率。只要某个对象对静态变量更新一次，所有的对象都能访问更新后的值 注意： 静态方法只能调用静态方法和静态变量 如果.m文件和方法体里面定义了同名的static 变量，那么方法体里面的实例变量和全局的static变量不会冲突，在方法体内部访问的static变量和全局的static变量是不同的。 1234567891011static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123; AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags); dispatch_async(dispatch_get_main_queue(), ^&#123; if (block) &#123; block(status); &#125; NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter]; NSDictionary *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;; [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo]; &#125;);&#125; 监听网络状态的改变有两种, 一种是实现setReachabilityStatusChangeBlock:中的block, 另一种是监听通知AFNetworkingReachabilityDidChangeNotification, 此方法将监听网络状态改变的两种方式封装到一个函数中, 在主队列中异步执行。 1234// 这个函数直接调用AFPostReachabilityStatusChange函数static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) &#123; AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);&#125; 123456789static const void * AFNetworkReachabilityRetainCallback(const void *info) &#123; return Block_copy(info);&#125;static void AFNetworkReachabilityReleaseCallback(const void *info) &#123; if (info) &#123; Block_release(info); &#125;&#125; void *表示“任意类型的指针” 或 表示“该指针与一地址值相关，但是不清楚在此地址上的对象的类型”。 为什么不用void表示任意类型的数据呢？大家都知道，C/C++是静态类型的语言，定义变量就会分配内存，然而，不同类型的变量所占内存不同，如果定义一个任意类型的变量，如何为其分配内存呢？所以，C、C++中没有任意类型的变量。但是，所有指针类型的变量，无论是int、char、string、Student等等，他们的内存空间都是相同的，所以可以定义“任意类型的指针”。 void * 指针只支持几种有限的操作： 与另一个指针进行比较 向函数传递void * 指针或从函数返回void * 指针 给另一个void *指针赋值 不允许使用void * 指针操作它所指向的对象，例如，不允许对void * 指针进行解引用不允许对void * 指针进行算术操作 block其实也是对象, 我们可以对其进行retain、copy操作, 在block做为属性的时候我们通常用copy去修饰block, 将block拷贝到堆内存中。这两个block用于创建SCNetworkReachabilityContext结构体。 123456// SCNetworkReachabilityRef 网络连接引用@property (readonly, nonatomic, assign) SCNetworkReachabilityRef networkReachability;// 网络状态, 枚举类型@property (readwrite, nonatomic, assign) AFNetworkReachabilityStatus networkReachabilityStatus;// 网络状态切换block@property (readwrite, nonatomic, copy) AFNetworkReachabilityStatusBlock networkReachabilityStatusBlock; 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)startMonitoring &#123; [self stopMonitoring]; // 句柄 if (!self.networkReachability) &#123; return; &#125; // 收到callback调用后，将status通过networkReachabilityStatusBlock回调出去 __weak __typeof(self)weakSelf = self; AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; strongSelf.networkReachabilityStatus = status; if (strongSelf.networkReachabilityStatusBlock) &#123; strongSelf.networkReachabilityStatusBlock(status); &#125; &#125;; /** typedef struct &#123; CFIndex version; void * __nullable info;// void * 相当于oc中的id类型, 可以指向任何类型的参数 const void * __nonnull (* __nullable retain)(const void *info);// 接收一个函数, 目的是对info做retain操作 void (* __nullable release)(const void *info);// 接收一个函数, 目的是对info做release操作 CFStringRef __nonnull (* __nullable copyDescription)(const void *info);// 接收一个函数, 根据info获取description字符串 &#125; SCNetworkReachabilityContext; context是一个结构体 */ SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;; // 根据上下文设置回调 SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context); // 加入线程池中 mainRunLoop commonModes SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes); // 获取当前的网络状态，调用callback dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123; SCNetworkReachabilityFlags flags; if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123; AFPostReachabilityStatusChange(flags, callback); &#125; &#125;);&#125; 这个是主要讲解的方法, AFNetworkReachabilityManager监测网络状态的核心就在此方法.SCNetworkReachabilityContext是一个结构体(个人理解为结构体主要用于存储数据), void * __nullable info是指向需要执行的block的指针, 包含了用户指定的数据和用于SCNetworkReachabilitySetCallback方法的回调函数.SCNetworkReachabilitySetCallback设置回调, 可以看我的另一篇文章有简要介绍.SCNetworkReachabilityScheduleWithRunLoop将networkReachability网络连接引用加入到运行循环中. 个人理解为加入运行循环以后会一直监测networkReachability网络状态, 如果网络状态有变化就会调用AFNetworkReachabilityCallback.在异步线程中发送一次网络状态, 调用SCNetworkReachabilityGetFlags获取网络状态, AFPostReachabilityStatusChange发送网路状态. 1234567- (void)stopMonitoring &#123; if (!self.networkReachability) &#123; return; &#125; SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);&#125; 从指定的运行循环和模式中移除网络连接引用的调度. 也就是说不再监听networkReachability的网络状态. 123456789#pragma mark - NSKeyValueObserving+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; if ([key isEqualToString:@\"reachable\"] || [key isEqualToString:@\"reachableViaWWAN\"] || [key isEqualToString:@\"reachableViaWiFi\"]) &#123; return [NSSet setWithObject:@\"networkReachabilityStatus\"]; &#125; return [super keyPathsForValuesAffectingValueForKey:key];&#125; 键值依赖, 返回一个键集合, 这些属性的值会影响指定的key的值, 当集合中键的值发生变化时, 就会触发指定key的监听通知.当networkReachabilityStatus的值发生变化时, 就会触发指定的key的键值监听方法。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"https://nixzhang5.github.io/tags/AFNetWorking原理/"}]},{"title":"AFNetWorking原理四 AFURLResponseSerialization","slug":"AFNetWorking原理四","date":"2019-06-28T06:06:40.000Z","updated":"2019-06-28T09:03:10.316Z","comments":true,"path":"AFNetWorking原理四.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorking原理四.html","excerpt":"AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。","text":"AFNetWorking中对接收响应的过程进行序列化，这涉及到AFURLResponseSerialization模块。将请求返回的数据解析成对应的格式。而这个模块使用在AFURLSessionManager也就是核心类中。 模块结构AFURLResponseSerialization协议，通过协议来处理返回值，代码结构清晰、易于扩展 1234567@protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;// 对返回的数据进行解析，解析response为对应的数据类型（JSON、XML、plist、Image）,AFHTTPResponseSerializer的子类会重写这个方法，根据不同的需要解析成不同的结果，如AFJSONResponseSerializer会将数据解析成为JSON数据- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response data:(nullable NSData *)data error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;@end 父类 AFHTTPResponseSerializer遵循AFURLResponseSerialization协议 子类 所有子类都遵循AFURLResponseSerialization协议 AFJSONResponseSerializer JSON响应 AFXMLParserResponseSerializer XMLParse响应 AFXMLDocumentResponseSerializer XMLDocument响应 AFPropertyListResponseSerializer PropertyList响应 AFImageResponseSerializer Image响应 AFCompoundResponseSerializer 符合响应 AFHTTPResponseSerializer对返回数据进行解析的父类 123456789101112131415161718192021222324252627@interface AFHTTPResponseSerializer : NSObject &lt;AFURLResponseSerialization&gt;- (instancetype)init;+ (instancetype)serializer;///-----------------------------------------/// @name Configuring Response Serialization///-----------------------------------------/** 设置接收的状态码，不在接受范围内的状态码会在验证时返回错误 */@property (nonatomic, copy, nullable) NSIndexSet *acceptableStatusCodes;/** 设置接收的contentTypes，不在范围内的contentType会在验证时返回错误 */@property (nonatomic, copy, nullable) NSSet &lt;NSString *&gt; *acceptableContentTypes;/** 验证服务器返回的数据，这个会使用到NSIndexSet *acceptableStatusCodes，NSIndexSet *acceptableStatusCodes这两个属性 */- (BOOL)validateResponse:(nullable NSHTTPURLResponse *)response data:(nullable NSData *)data error:(NSError * _Nullable __autoreleasing *)error;@end 初始化成功的状态码默认值 200 ~ 299 类别 原因 1XX 信息性状态码 接收的请求正在处理 2XX 成功状态码 请求正常处理完毕 3XX 重定向状态码 需要进行附加操作以完成请求 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器错误状态码 服务器处理请求出错 123456789101112131415+ (instancetype)serializer &#123; return [[self alloc] init];&#125;- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)]; self.acceptableContentTypes = nil; return self;&#125; 验证响应和数据的有效性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//验证响应和数据的有效性（验证MIMEType和status code）。子类可添加其他特定域的检查。 - (BOOL)validateResponse:(NSHTTPURLResponse *)response data:(NSData *)data error:(NSError * __autoreleasing *)error&#123; BOOL responseIsValid = YES;//response是否合法 NSError *validationError = nil; //response是否存在和类型判断，如果response为空或者不是NSHTTPURLResponse类型，responseIsValid=YES! if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123; //根据在初始化方法中初始化的属性 acceptableContentTypes 和 acceptableStatusCodes 来判断当前响应是否有效 //1.response的内容类型不对（MIMEType） if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp; !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123; //数据解析失败 if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123; //NSLocalizedDescriptionKey是NSError头文件中预定义的键，标识错误的本地化描述.可以通过NSError的localizedDescription方法获得对应的值信息 //NSURLErrorFailingURLErrorKey相应的值是包含导致加载失败的URL的NSURL。 此键仅存在于NSURLErrorDomain中。 //生成错误信息字典。会返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中 NSMutableDictionary *mutableUserInfo = [@&#123; NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@\"Request failed: unacceptable content-type: %@\", @\"AFNetworking\", nil), [response MIMEType]], NSURLErrorFailingURLErrorKey:[response URL], AFNetworkingOperationFailingURLResponseErrorKey: response, &#125; mutableCopy]; if (data) &#123; mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data; &#125; //+errorWithDomain: code: userInfo:创建和初始化NSError对象 //NSErrorDomain错误域 - 这可以是预定义的NSError域之一，也可以是描述自定义域的任意字符串。 域名不能为空。 //收到的内容数据具有未知内容编码（解析数据出错）。NSURLErrorCannotDecodeContentData = -1016，NSError错误码 //出现错误时通过AFErrorWithUnderlyingError函数生成本地格式化的错误 validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError); &#125; responseIsValid = NO; &#125; //2.状态码无效 if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123; //-localizedStringForStatusCode:根据状态码获取本地化文本内容 NSMutableDictionary *mutableUserInfo = [@&#123; NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@\"Request failed: %@ (%ld)\", @\"AFNetworking\", nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode], NSURLErrorFailingURLErrorKey:[response URL], AFNetworkingOperationFailingURLResponseErrorKey: response, &#125; mutableCopy]; if (data) &#123; mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data; &#125; //收到从服务器来的错误数据 NSURLErrorBadServerResponse = -1011,NSError错误码 validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError); responseIsValid = NO; &#125; &#125; if (error &amp;&amp; !responseIsValid) &#123; *error = validationError; &#125; return responseIsValid;&#125;/* 1.如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorCannotDecodeContentData。如果MIME type不满足，，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorBadServerResponse。 2.方法中，有可能会出现两个错误，在self.acceptableContentTypes和self.acceptableStatusCodes这两个判断中，如果都出现错误怎么办呢？ 这就用到了NSUnderlyingErrorKey 这个字段，它表示一个优先的错误，value为NSError对象。 */ 根据初始化中的属性acceptableContentTypes和acceptableStatusCodes判断响应是否有效。 content-type不对，返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中。MIME type不对，处理相似，这里不展开。 这个记录了错误信息的字典，系统提供的KEY值： NSError的Key: NSUnderlyingErrorKey 优先错误，value是NSError NSLocalizedDescriptionKey 错误描述 NSLocalizedFailureReasonErrorKey 错误的简要说明 NSLocalizedRecoverySuggestionErrorKey 修复建议 NSLocalizedRecoveryOptionErrorKey 修复选项 NSURLError NSURLErrorFailingURLErrorKey NSURLErrorFailingURLStringErrorKey NSErrorFailingURLStringKey NSURLErrorFailingURLPeeTrustErrorKey NSURLErrorBackgroundTaskCancelledReasonKey AF中自定义了AFNetworkingOperationFailingURLResponseErrorKey和AFNetworkingOperationFailingURLResponseDataErrorKey。 出现错误时通过AFErrorWithUnderlyingError函数生成本地格式化的错误。 3.1 如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为 NSURLErrorCannotDecodeContentData的自定义NSError。 3.2 如果MIME type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为 NSURLErrorBadServerResponse的自定义NSError。 如果content type和MIMEtype同时出错，这就用到了NSUnderlyingErrorKey这个字段，它表示一个优先的错误，value为NSError对象。 具体看下面这个函数： 12345678910111213141516//生成本地格式化的错误。填充错误信息，一些处理过程中产生的错误信息填充到我们需要返回给用户的自定义错误中static NSError * AFErrorWithUnderlyingError(NSError *error, NSError *underlyingError) &#123; //NSUnderlyingErrorKey表示优先错误 if (!error) &#123; return underlyingError; &#125; if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) &#123; return error; &#125; NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy]; mutableUserInfo[NSUnderlyingErrorKey] = underlyingError; return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];&#125; 在两者都出错的情况下，那么UnderlyingError就是content type error。 AFURLResponseSerialization协议的实现： 12345678//从与指定响应相关联的数据中decode得到的响应对象。 - (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; //调用验证方法，返回data [self validateResponse:(NSHTTPURLResponse *)response data:data error:error]; return data;&#125; 把验证方法调用完之后就返回data，没有其他实现了。 AFJSONResponseSerializer可接受的数据类型：application/json，text/json，text/javascript。实现协议： 12345678910111213141516171819202122232425262728293031323334353637383940- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; //验证MIMEType和status code if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123; //error为空或者 错误、优先错误匹配error code和domain（在这里是content type类型的错误） if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123; return nil; &#125; &#125; // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization. // See https://github.com/rails/rails/issues/1742 //数据是否是一个空格 BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:\" \" length:1]]; //如果数据为空或者是空格，就不json解析 if (data.length == 0 || isSpace) &#123; return nil; &#125; NSError *serializationError = nil; //json解析。NSJSON只支持解析UTF8编码的数据 id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError]; if (!responseObject) &#123; if (error) &#123; //用json解析的error去填充错误信息 *error = AFErrorWithUnderlyingError(serializationError, *error); &#125; return nil; &#125; //是否要从响应的JSON数据中删除带有“NSNull”值的键 if (self.removesKeysWithNullValues) &#123; return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions); &#125; return responseObject;&#125; 验证响应验证失败。在没有error 或者 错误中的code是NSURLErrorCannotDecodeContentData（即content type不匹配）的情况下，是不能解析数据的，就返回nil。用到的函数： 1234567891011// 检测错误或者优先错误中是否匹配code和domainstatic BOOL AFErrorOrUnderlyingErrorHasCodeInDomain(NSError *error, NSInteger code, NSString *domain) &#123; //判断错误域和传过来的域名是否一致，错误code是否一致 if ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123; return YES; &#125; else if (error.userInfo[NSUnderlyingErrorKey]) &#123;//如果NSUnderlyingErrorKey对应有值，就再进行判断 return AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[NSUnderlyingErrorKey], code, domain); &#125; return NO;&#125; 处理返回的数据中只有空格的情况如果数据为空或者只有一个空格，就不解析。 解析JSONreadingOptions属性设置json的读取选项。这里的默认值是NSJSONReadingMutableContainers 12345678typedef NS_OPTIONS(NSUInteger, NSJSONReadingOptions) &#123; //返回可变容器，NSMutableDictionary或NSMutableArray NSJSONReadingMutableContainers = (1UL &lt;&lt; 0), //返回的JSON对象中字符串的值为NSMutableString NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), //允许JSON字符串最外层既不是NSArray也不是NSDictionary，但必须是有效的JSON Fragment。例如使用这个选项可以解析 @“123” 这样的字符串。 NSJSONReadingAllowFragments = (1UL &lt;&lt; 2)&#125; NS_ENUM_AVAILABLE(10_7, 5_0); 是否要从响应的JSON数据中删除带有“NSNull”值的键用到的函数：主要通过递归的手段来实现的。1234567891011121314151617181920212223242526272829//从响应的JSON数据中删除带有“NSNull”值的键static id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) &#123; //数组 if ([JSONObject isKindOfClass:[NSArray class]]) &#123; NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]]; //遍历数组，通过递归的手段清空数组内的null for (id value in (NSArray *)JSONObject) &#123; [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)]; &#125; //按位与操作，解析类型是否NSJSONReadingMutableContainers（mutableArray或者mutabledictionary） return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray]; &#125; //字典 else if ([JSONObject isKindOfClass:[NSDictionary class]]) &#123; NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject]; for (id &lt;NSCopying&gt; key in [(NSDictionary *)JSONObject allKeys]) &#123; id value = (NSDictionary *)JSONObject[key]; if (!value || [value isEqual:[NSNull null]]) &#123; [mutableDictionary removeObjectForKey:key]; &#125; else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) &#123; mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions); &#125; &#125; return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary]; &#125; return JSONObject;&#125; AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializerAFXMLParserResponseSerializer用来解析XML数据，支持的ContentType：application/xml、text/xml。AFXMLDocumentResponseSerializer同上，但这个类只能在mac os x上使用。AFPropertyListResponseSerializer用来解析plist数据，支持的ContentType：application/x-plist。这三个子类的实现和上面JSON子类的实现差不多，就不具体展开了。 AFImageResponseSerializer用于验证和解码图像响应。 支持的ContentType：image/tiff、image/jpeg、image/gif、image/png、image/ico、image/x-icon、image/bmp、image/x-bmp、image/x-xbitmap、image/x-win-bitmap 12345678910111213141516171819202122232425262728- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; //验证MIME type和status code if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123; if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123; return nil; &#125; &#125; //图片解压。宏判断是那种设备，进行对应的图片解压处理#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH if (self.automaticallyInflatesResponseImage) &#123;//是否对响应的图片进行自动处理 return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale); &#125; else &#123; return AFImageWithDataAtScale(data, self.imageScale); &#125;#else // Ensure that the image is set to it's correct pixel width and height NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data]; NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])]; [image addRepresentation:bitimage]; return image;#endif return nil;&#125; 在这里用到了几个方法，写在了UIImage分类UIImage (AFNetworkingSafeImageLoading)里面。下面来看一下分类中的这几个方法： 把NSData安全地转换为UIImage。 123456789101112+ (UIImage *)af_safeImageWithData:(NSData *)data &#123; UIImage* image = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; imageLock = [[NSLock alloc] init]; &#125;); [imageLock lock];//上锁 image = [UIImage imageWithData:data]; [imageLock unlock];//开锁 return image;&#125; 当我们读写一个数据的时候，由于数据还可能被别人读写，这就有可能出现不安全的情况，为了解决这个问题，就使用了“锁”。如果对线程锁比较熟悉的话就容易理解了，简单说呢，就是在写数据前先上锁，那么别人就无法使用这块数据了，直到你执行完数据操作、解锁。 私有函数，按照scale对图片进行伸缩处理 12345678//返回一个按照scale收缩的图片static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) &#123; UIImage *image = [UIImage af_safeImageWithData:data]; if (image.images) &#123;//gif图不需要伸缩 return image; &#125; return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];&#125; 关于image.images：这个属性第一次接触，大致看了一下，常见的应用是用来生成一个gif效果。在gif图中表示这个Gif包含了多少张图片。 根据响应结果和scale返回一张图片.完成图像解压工作 1static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) 这个函数实现很长，用到了CoreGraphics上的一些东西，主要完成iOS、TV、Watch设备下的图像解压工作。关于图像解压的目的，我在这篇文章中读到这么一段话： AFJSONResponseSerializer使用系统内置的NSJSONSerialization解析json，NSJSON只支持解析UTF8编码的数据（还有UTF-16LE之类的，都不常用），所以要先把返回的数据转成UTF8格式。这里会尝试用HTTP返回的编码类型和自己设置的stringEncoding去把数据解码转成字符串NSString，再把NSString用UTF8编码转成NSData，再用NSJSONSerialization解析成对象返回。上述过程是NSData-&gt;NSString-&gt;NSData-&gt;NSObject，这里有个问题，如果你能确定服务端返回的是UTF8编码的json数据，那NSData-&gt;NSString-&gt;NSData这两步就是无意义的，而且这两步进行了两次编解码，很浪费性能，所以如果确定服务端返回utf8编码数据，就建议自己再写个JSONResponseSerializer，跳过这两个步骤。此外AFJSONResponseSerializer专门写了个方法去除NSNull，直接把对象里值是NSNull的键去掉，还蛮贴心，若不去掉，上层很容易忽略了这个数据类型，判断了数据是否nil没判断是否NSNull，进行了错误的调用导致core。图片解压当我们调用UIImage的方法imageWithData:方法把数据转成UIImage对象后，其实这时UIImage对象还没准备好需要渲染到屏幕的数据，现在的网络图像PNG和JPG都是压缩格式，需要把它们解压转成bitmap后才能渲染到屏幕上，如果不做任何处理，当你把UIImage赋给UIImageView，在渲染之前底层会判断到UIImage对象未解压，没有bitmap数据，这时会在主线程对图片进行解压操作，再渲染到屏幕上。这个解压操作是比较耗时的，如果任由它在主线程做，可能会导致速度慢UI卡顿的问题。AFImageResponseSerializer除了把返回数据解析成UIImage外，还会把图像数据解压，这个处理是在子线程（AFNetworking专用的一条线程，详见AFURLConnectionOperation），处理后上层使用返回的UIImage在主线程渲染时就不需要做解压这步操作，主线程减轻了负担，减少了UI卡顿问题。具体实现上在AFInflatedImageFromResponseWithDataAtScale里，创建一个画布，把UIImage画在画布上，再把这个画布保存成UIImage返回给上层。只有JPG和PNG才会尝试去做解压操作，期间如果解压失败，或者遇到CMKY颜色格式的jpg，或者图像太大(解压后的bitmap太占内存，一个像素3-4字节，搞不好内存就爆掉了)，就直接返回未解压的图像。另外在代码里看到iOS才需要这样手动解压，MacOS上已经有封装好的对象NSBitmapImageRep可以做这个事。 AFCompoundResponseSerializer这是一个对复合类型的响应进行处理的子类。 1234567891011121314151617181920212223- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; //遍历数组，只要是属于AFHTTPResponseSerializer及其子类的类型，就执行相应的响应操作。 for (id &lt;AFURLResponseSerialization&gt; serializer in self.responseSerializers) &#123; if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) &#123; continue; &#125; NSError *serializerError = nil; id responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError]; if (responseObject) &#123; if (error) &#123; *error = AFErrorWithUnderlyingError(serializerError, *error); &#125; return responseObject; &#125; &#125; //以上类型都不是，就执行默认响应操作。 return [super responseObjectForResponse:response data:data error:error];//调用父类方法&#125; responseSerializers属性，这个数组中装着多种序列化类型，比如上面讲到的JSON、XML等等。遍历数组，只要是属于AFHTTPResponseSerializer及其子类的类型，就执行相应的响应操作。如果以上类型都不是，就执行默认的响应。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"https://nixzhang5.github.io/tags/AFNetWorking原理/"}]},{"title":"AFNetWorking原理三 AFURLRequestSerialization","slug":"AFNetWorking原理三","date":"2019-06-27T03:28:59.000Z","updated":"2019-07-01T03:39:01.038Z","comments":true,"path":"AFNetWorking原理三.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorking原理三.html","excerpt":"AFURLRequestSerialization序列化网络请求参数","text":"AFURLRequestSerialization序列化网络请求参数 AFURLRequestSerialization包含了四个部分： 全局方法:AFPercentEscapedStringFromString和AFQueryStringFromParameters。 协议AFURLRequestSerialization提供了一个序列化parameters参数的方法。我们可以把参数转换为查询字符串、HTTP请求体、设置恰当的请求头等。 AFHTTPRequestSerializer继承自AFURLRequestSerialization协议。提供了查询字符串/URL格式的参数序列化、默认请求头处理。同时以提供HTTP状态码和返回数据的验证等工作。_ AFMultipartFormData协议。主要用于添加multipart/form-data请求的Content-Disposition: file; filename=#{generated filename}; name=#{name}” 和 Content-Type: #{generated mimeType}的请求体域。 类型AFJSONRequestSerializer和AFPropertyListRequestSerializer。主要针对JSON和Plist类型的序列化优化。 工具函数AFPercentEscapedStringFromString把字符串转化成符合标准的URL编码字符串，主要是通过一个字符集NSMutableCharacterSet来定义需要进行转码的字符，再通过-[NSString stringByAddingPercentEncodingWithAllowedCharacters]方法来进行转码。 1234567891011121314151617181920212223242526272829303132333435AFURLRequestSerialization.hFOUNDATION_EXPORT NSString * AFPercentEscapedStringFromString(NSString *string);AFURLRequestSerialization.mNSString * AFPercentEscapedStringFromString(NSString *string) &#123; // does not include \"?\" or \"/\" due to RFC 3986 - Section 3.4 static NSString * const kAFCharactersGeneralDelimitersToEncode = @\":#[]@\"; static NSString * const kAFCharactersSubDelimitersToEncode = @\"!$&amp;'()*+,;=\"; NSMutableCharacterSet * allowedCharacterSet = [[NSCharacterSet URLQueryAllowedCharacterSet] mutableCopy]; [allowedCharacterSet removeCharactersInString:[kAFCharactersGeneralDelimitersToEncode stringByAppendingString:kAFCharactersSubDelimitersToEncode]]; static NSUInteger const batchSize = 50; NSUInteger index = 0; NSMutableString *escaped = @\"\".mutableCopy; while (index &lt; string.length) &#123; NSUInteger length = MIN(string.length - index, batchSize); NSRange range = NSMakeRange(index, length); // To avoid breaking up character sequences such as 👴🏻👮🏽 range = [string rangeOfComposedCharacterSequencesForRange:range]; NSString *substring = [string substringWithRange:range]; NSString *encoded = [substring stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet]; [escaped appendString:encoded]; index += range.length; &#125; return escaped;&#125; AFQueryStringFromParameters把字典转化为&amp;拼接的参数，通过AFQueryStringPair类来实现的。 AFQueryStringPair来存取每一个查询属性，将查询的键值保持起来，然后通过URLEncodedStringValue方法在需要时进行拼接，并且使用了上面所述的AFPercentEscapedStringFromString方法进行了URLEncode。其中最主要的方法是AFQueryStringPairsFromKeyAndValue，它将字典的每一个键值对生成的对应的AFQueryStringPair对象，例如将machine:[iphone, mac]转换为URLEncodedStringValue值是machine[]=iphone和machine[]=mac的两个AFQueryStringPair对象。之后AFQueryStringFromParameters方法再以’&amp;’符号对它们进行拼接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788AFURLRequestSerialization.hFOUNDATION_EXPORT NSString * AFQueryStringFromParameters(NSDictionary *parameters);AFURLRequestSerialization.m@interface AFQueryStringPair : NSObject@property (readwrite, nonatomic, strong) id field;@property (readwrite, nonatomic, strong) id value;- (instancetype)initWithField:(id)field value:(id)value;- (NSString *)URLEncodedStringValue;@end@implementation AFQueryStringPair- (instancetype)initWithField:(id)field value:(id)value &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.field = field; self.value = value; return self;&#125;- (NSString *)URLEncodedStringValue &#123; if (!self.value || [self.value isEqual:[NSNull null]]) &#123; return AFPercentEscapedStringFromString([self.field description]); &#125; else &#123; return [NSString stringWithFormat:@\"%@=%@\", AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])]; &#125;&#125;@end#pragma mark -FOUNDATION_EXPORT NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary);FOUNDATION_EXPORT NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value);NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123; NSMutableArray *mutablePairs = [NSMutableArray array]; for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123; [mutablePairs addObject:[pair URLEncodedStringValue]]; &#125; return [mutablePairs componentsJoinedByString:@\"&amp;\"];&#125;NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123; return AFQueryStringPairsFromKeyAndValue(nil, dictionary);&#125;NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123; NSMutableArray *mutableQueryStringComponents = [NSMutableArray array]; NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"description\" ascending:YES selector:@selector(compare:)]; if ([value isKindOfClass:[NSDictionary class]]) &#123; NSDictionary *dictionary = value; // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123; id nestedValue = dictionary[nestedKey]; if (nestedValue) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@\"%@[%@]\", key, nestedKey] : nestedKey), nestedValue)]; &#125; &#125; &#125; else if ([value isKindOfClass:[NSArray class]]) &#123; NSArray *array = value; for (id nestedValue in array) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@\"%@[]\", key], nestedValue)]; &#125; &#125; else if ([value isKindOfClass:[NSSet class]]) &#123; NSSet *set = value; for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)]; &#125; &#125; else &#123; [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]]; &#125; return mutableQueryStringComponents;&#125; AFURLRequestSerialization先声明了一个协议AFURLRequestSerialization继承了NSSecureCoding和NSCopying来保证所有实现这个序列化协议的序列化器类都有安全编码和复制的能力。协议也定义了序列化的规范方法。（协议，有利于扩展） 1234567891011121314/** AFURLRequestSerialization协议可以被一个编码特定http请求的对象实现。 请求序列化器（Request serializer）可以编码查询语句、HTTP请求体，如果必须的话，可以自行设置合适的HTTP请求体内容（如：Agent:iOS）。 例如，一个JSON请求序列化器会把请求体Content-Type设置为application/json。*/@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;/** 返回一个使用了指定参数编码的请求的拷贝。*/- (nullable NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;@end AFHTTPRequestSerializer缓存策略1234567891011121314151617181920212223242526272829typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; /** 默认缓存策略。具体工作：如果一个NSCachedURLResponse对于请求并不存在，数据将会从源端获取。如果请求拥有一个缓存的响应，那么URL加载系统会检查这个响应来决定，如果它指定内容必须重新生效的话。假如内容必须重新生效，将建立一个连向源端的连接来查看内容是否发生变化。假如内容没有变化，那么响应就从本地缓存返回数据。如果内容变化了，那么数据将从源端获取 */ NSURLRequestUseProtocolCachePolicy = 0, /** URL应该加载源端数据，不使用本地缓存数据 */ NSURLRequestReloadIgnoringLocalCacheData = 1, /** 本地缓存数据、代理和其他中介都要忽视他们的缓存，直接加载源数据 */ NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, /** 指定已存的缓存数据应该用来响应请求，不管它的生命时长和过期时间。如果在缓存中没有已存数据来响应请求的话，数据从源端加载。 */ NSURLRequestReturnCacheDataElseLoad = 2, /** 指定已存的缓存数据用来满足请求，不管生命时长和过期时间。如果在缓存中没有已存数据来响应URL加载请求的话，不去尝试从源段加载数据，此时认为加载请求失败。这个常量指定了一个类似于离线模式的行为 */ NSURLRequestReturnCacheDataDontLoad = 3, /** 指定如果已存的缓存数据被提供它的源段确认为有效则允许使用缓存数据响应请求，否则从源段加载数据。 */ NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;; NSURLRequestReturnCacheDataDontLoad是用于离线模式的，我为了能让用户在离线下面阅读，我就设计了当没有网络的时候的策略为NSURLRequestReturnCacheDataDontLoad。 创建普通NSMutableURLRequest请求对象声明HTTP序列化器类AFHTTPRequestSerializer，实现了AFURLRequestSerialization协议，并参考了NSMutableURLRequest类声明了很多请求设置相关属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** AFHTTPRequestSerializer实现了AFURLRequestSerialization协议，为查询语句、URL表单编码参数的序列化提供一个具体的实现和默认的请求头，以及状态码和内容类型的校验。 所有的request和response都被鼓励去继承AFHTTPRequestSerializer类，以确保默认方法和属性的一致性。*/@interface AFHTTPRequestSerializer : NSObject &lt;AFURLRequestSerialization&gt;/** 字符串编码方式，默认为NSUTF8StringEncoding*/@property (nonatomic, assign) NSStringEncoding stringEncoding;/** 是否允许手机访问，默认为YES */@property (nonatomic, assign) BOOL allowsCellularAccess;/** 缓存策略。默认为NSURLRequestUseProtocolCachePolicy 参考NSMutableURLRequest -setCachePolicy:*/@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;/** 是否用cookie来处理创建的请求。默认为YES 参考NSMutableURLRequest -setHTTPShouldHandleCookies*/@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;/** 创建的请求在收到上个传输（transmission）响应之前是否继续发送数据。 默认为NO(即等待上次传输完成后再请求) 参考NSMutableURLRequest -setHTTPShouldUsePipelining:*/@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;/** 请求的网络服务类型。 这个服务类型向整个网络传输层次提供了一个关于该请求目的的提示。 （The service type is used to provide the networking layers a hint of the purpose of the request.） 默认为NSURLNetworkServiceTypeDefault 参考NSMutableURLRequest -setNetworkServiceType:*/@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;/** 请求的超时间隔，单位秒。默认为60秒 参考NSMutableURLRequest -setTimeoutInterval:*/@property (nonatomic, assign) NSTimeInterval timeoutInterval;///---------------------------------------/// @name Configuring HTTP Request Headers///---------------------------------------/** 序列请求的默认请求头。默认值包括 'Accept-Language’ 内容为 'NSLocale +preferredLanguages’ 方法获取的语音 'User-Agent’ 内容为各种bundle的标志已经系统信息 可以使用'setValue:forHTTPHeaderField:’方法添加或删除请求头*/@property (readonly, nonatomic, strong) NSDictionary &lt;NSString *, NSString *&gt; *HTTPRequestHeaders;/** 类方法创建实例对象 */+ (instancetype)serializer;/** 设置HTTPHeader */- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;/** 获取HTTPHeader field对应的信息 */- (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;/** 设置身份信息header */- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username password:(NSString *)password;/** 清除身份认证信息header */- (void)clearAuthorizationHeader;///-------------------------------------------------------/// @name Configuring Query String Parameter Serialization///-------------------------------------------------------/** 哪些HTTP请求方法会将参数编码成查询字符串（如:name=xgb&amp;gender=1）。默认为GET, HEAD和DELETE。*/@property (nonatomic, strong) NSSet &lt;NSString *&gt; *HTTPMethodsEncodingParametersInURI;/** 查询参数的转义样式.(目前只有一种) */- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style;/** 自定义参数的转义方式 */- (void)setQueryStringSerializationWithBlock:(nullable NSString * (^)(NSURLRequest *request, id parameters, NSError * __autoreleasing *error))block;///-------------------------------/// @name Creating Request Objects///-------------------------------/** 如果请求方式为GET`, `HEAD`, or `DELETE时、参数会被拼接到URL中、否则当做body处理 */- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error;@end 创建普通NSMutableURLRequest请求对象实现123456789static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123; static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))]; &#125;); return _AFHTTPRequestSerializerObservedKeyPaths;&#125; AFHTTPRequestSerializerObservedKeyPaths方法定义可以需要被观察的属性（这些属性为公开的属性，可能被用户修改），包括cachePolicy、HTTPShouldHandleCookies、HTTPShouldUsePipelining、networkServiceType和timeoutInterval。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332@interface AFHTTPRequestSerializer ()/** 保存用户修改过的属性，包括AFHTTPRequestSerializerObservedKeyPaths包含的属性。 当用户修改这些属性值时记录起来，创建Request时使用，没修改的使用默认值。*/@property (readwrite, nonatomic, strong) NSMutableSet *mutableObservedChangedKeyPaths;/** 真正存储Header的属性。 */@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableHTTPRequestHeaders;/** 用一个串行线程来统一处理Header的修改，避免多线程造成的线程安全问题。*/@property (readwrite, nonatomic, strong) dispatch_queue_t requestHeaderModificationQueue;/** 目前只有一个值 */@property (readwrite, nonatomic, assign) AFHTTPRequestQueryStringSerializationStyle queryStringSerializationStyle;/** 用于自定义查询字符串的拼接。 因为AFURLRequestSerialization协议定义的方法-requestBySerializingRequest:withParameters:error:传入的parameters是以字典的形式传入，所以需要将字典拼接成查询字符串，默认是使用AFQueryStringFromParameters方法拼接。*/@property (readwrite, nonatomic, copy) AFQueryStringSerializationBlock queryStringSerialization;@end@implementation AFHTTPRequestSerializer+ (instancetype)serializer &#123; return [[self alloc] init];&#125;/** 初始化方法主要是对一些属性初始化，以及将HTTP头部按照w3c标准进行了封装，根据AFHTTPRequestSerializerObservedKeyPaths方法对一些必要的属性使用KVO进行了监听。在这些被监听的属性的setter里面手动地发送通知，避免出现奇怪的异常*/- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.stringEncoding = NSUTF8StringEncoding; self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary]; self.requestHeaderModificationQueue = dispatch_queue_create(\"requestHeaderModificationQueue\", DISPATCH_QUEUE_CONCURRENT); // Accept-Language HTTP Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4 NSMutableArray *acceptLanguagesComponents = [NSMutableArray array]; [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; float q = 1.0f - (idx * 0.1f); [acceptLanguagesComponents addObject:[NSString stringWithFormat:@\"%@;q=%0.1g\", obj, q]]; *stop = q &lt;= 0.5f; &#125;]; [self setValue:[acceptLanguagesComponents componentsJoinedByString:@\", \"] forHTTPHeaderField:@\"Accept-Language\"]; NSString *userAgent = nil;#if TARGET_OS_IOS // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@\"%@/%@ (%@; iOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];#elif TARGET_OS_WATCH // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@\"%@/%@ (%@; watchOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[WKInterfaceDevice currentDevice] model], [[WKInterfaceDevice currentDevice] systemVersion], [[WKInterfaceDevice currentDevice] screenScale]];#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED) userAgent = [NSString stringWithFormat:@\"%@/%@ (Mac OS X %@)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]];#endif if (userAgent) &#123; if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123; NSMutableString *mutableUserAgent = [userAgent mutableCopy]; if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@\"Any-Latin; Latin-ASCII; [:^ASCII:] Remove\", false)) &#123; userAgent = mutableUserAgent; &#125; &#125; [self setValue:userAgent forHTTPHeaderField:@\"User-Agent\"]; &#125; // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@\"GET\", @\"HEAD\", @\"DELETE\", nil]; self.mutableObservedChangedKeyPaths = [NSMutableSet set]; for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123; [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext]; &#125; &#125; return self;&#125;- (void)dealloc &#123; for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123; [self removeObserver:self forKeyPath:keyPath context:AFHTTPRequestSerializerObserverContext]; &#125; &#125;&#125;#pragma mark -// Workarounds for crashing behavior using Key-Value Observing with XCTest// See https://github.com/AFNetworking/AFNetworking/issues/2523- (void)setAllowsCellularAccess:(BOOL)allowsCellularAccess &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(allowsCellularAccess))]; _allowsCellularAccess = allowsCellularAccess; [self didChangeValueForKey:NSStringFromSelector(@selector(allowsCellularAccess))];&#125;- (void)setCachePolicy:(NSURLRequestCachePolicy)cachePolicy &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(cachePolicy))]; _cachePolicy = cachePolicy; [self didChangeValueForKey:NSStringFromSelector(@selector(cachePolicy))];&#125;- (void)setHTTPShouldHandleCookies:(BOOL)HTTPShouldHandleCookies &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldHandleCookies))]; _HTTPShouldHandleCookies = HTTPShouldHandleCookies; [self didChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldHandleCookies))];&#125;- (void)setHTTPShouldUsePipelining:(BOOL)HTTPShouldUsePipelining &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldUsePipelining))]; _HTTPShouldUsePipelining = HTTPShouldUsePipelining; [self didChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldUsePipelining))];&#125;- (void)setNetworkServiceType:(NSURLRequestNetworkServiceType)networkServiceType &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(networkServiceType))]; _networkServiceType = networkServiceType; [self didChangeValueForKey:NSStringFromSelector(@selector(networkServiceType))];&#125;- (void)setTimeoutInterval:(NSTimeInterval)timeoutInterval &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(timeoutInterval))]; _timeoutInterval = timeoutInterval; [self didChangeValueForKey:NSStringFromSelector(@selector(timeoutInterval))];&#125;#pragma mark -- (NSDictionary *)HTTPRequestHeaders &#123; NSDictionary __block *value; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; value = [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders]; &#125;); return value;&#125;- (void)setValue:(NSString *)valueforHTTPHeaderField:(NSString *)field&#123; dispatch_barrier_async(self.requestHeaderModificationQueue, ^&#123; [self.mutableHTTPRequestHeaders setValue:value forKey:field]; &#125;);&#125;- (NSString *)valueForHTTPHeaderField:(NSString *)field &#123; NSString __block *value; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; value = [self.mutableHTTPRequestHeaders valueForKey:field]; &#125;); return value;&#125;//通过账号密码设置授权请求头- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username password:(NSString *)password&#123; NSData *basicAuthCredentials = [[NSString stringWithFormat:@\"%@:%@\", username, password] dataUsingEncoding:NSUTF8StringEncoding]; NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0]; [self setValue:[NSString stringWithFormat:@\"Basic %@\", base64AuthCredentials] forHTTPHeaderField:@\"Authorization\"];&#125;//清除授权用请求头- (void)clearAuthorizationHeader &#123; dispatch_barrier_async(self.requestHeaderModificationQueue, ^&#123; [self.mutableHTTPRequestHeaders removeObjectForKey:@\"Authorization\"]; &#125;);&#125;#pragma mark -//设置查询参数的编码方式- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style &#123; self.queryStringSerializationStyle = style; self.queryStringSerialization = nil;&#125;//设置查询参数自定义编码的block- (void)setQueryStringSerializationWithBlock:(NSString *(^)(NSURLRequest *, id, NSError *__autoreleasing *))block &#123; self.queryStringSerialization = block;&#125;#pragma mark -//通过请求方式、URL、参数字典生成请求- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(URLString); NSURL *url = [NSURL URLWithString:URLString]; NSParameterAssert(url); NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url]; mutableRequest.HTTPMethod = method; //如果某个关键属性被自主设置过、则用新的。不然直接用模板生成的`NSMutableURLRequest`即可 for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123; [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath]; &#125; &#125; //对req进一步设置(拼接URL、请求体、请求头) mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy]; return mutableRequest;&#125;#pragma mark - AFURLRequestSerialization- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; //设置请求头 [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; //根据参数parameters设置查询字段 NSString *query = nil; if (parameters) &#123; if (self.queryStringSerialization) &#123; NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) &#123; if (error) &#123; *error = serializationError; &#125; return nil; &#125; &#125; else &#123; switch (self.queryStringSerializationStyle) &#123; case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; &#125; &#125; &#125; // 判断参数是拼到url还是放到HTTPBody if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; if (query &amp;&amp; query.length &gt; 0) &#123; mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @\"&amp;%@\" : @\"?%@\", query]]; &#125; &#125; else &#123; // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) &#123; query = @\"\"; &#125; if (![mutableRequest valueForHTTPHeaderField:@\"Content-Type\"]) &#123; [mutableRequest setValue:@\"application/x-www-form-urlencoded\" forHTTPHeaderField:@\"Content-Type\"]; &#125; [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; &#125; return mutableRequest;&#125;#pragma mark - NSKeyValueObserving// 可以决定是否发送KVO通知+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123; if ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) &#123; return NO; &#125; return [super automaticallyNotifiesObserversForKey:key];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(__unused id)object change:(NSDictionary *)change context:(void *)context&#123; if (context == AFHTTPRequestSerializerObserverContext) &#123; if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123; //如果没有新值、则清空所属监听 [self.mutableObservedChangedKeyPaths removeObject:keyPath]; &#125; else &#123; [self.mutableObservedChangedKeyPaths addObject:keyPath]; &#125; &#125;&#125;#pragma mark - NSSecureCoding+ (BOOL)supportsSecureCoding &#123; return YES;&#125;- (instancetype)initWithCoder:(NSCoder *)decoder &#123; self = [self init]; if (!self) &#123; return nil; &#125; self.mutableHTTPRequestHeaders = [[decoder decodeObjectOfClass:[NSDictionary class] forKey:NSStringFromSelector(@selector(mutableHTTPRequestHeaders))] mutableCopy]; self.queryStringSerializationStyle = (AFHTTPRequestQueryStringSerializationStyle)[[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(queryStringSerializationStyle))] unsignedIntegerValue]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder &#123; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; [coder encodeObject:self.mutableHTTPRequestHeaders forKey:NSStringFromSelector(@selector(mutableHTTPRequestHeaders))]; &#125;); [coder encodeInteger:self.queryStringSerializationStyle forKey:NSStringFromSelector(@selector(queryStringSerializationStyle))];&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFHTTPRequestSerializer *serializer = [[[self class] allocWithZone:zone] init]; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; serializer.mutableHTTPRequestHeaders = [self.mutableHTTPRequestHeaders mutableCopyWithZone:zone]; &#125;); serializer.queryStringSerializationStyle = self.queryStringSerializationStyle; serializer.queryStringSerialization = self.queryStringSerialization; return serializer;&#125;@end 实现里面用到了 KVO 和 GCDKVO很巧妙的把几个属性值的更改统一处理，代码清晰、简洁GCD栅栏函数 AFMultipartFormData协议上传图片或者其他文件的 初始化边界 body头 body 结束边界 协议： 1234567891011121314151617181920212223242526272829- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name error:(NSError * _Nullable __autoreleasing *)error;- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType error:(NSError * _Nullable __autoreleasing *)error;- (void)appendPartWithInputStream:(nullable NSInputStream *)inputStream name:(NSString *)name fileName:(NSString *)fileName length:(int64_t)length mimeType:(NSString *)mimeType;- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType;- (void)appendPartWithFormData:(NSData *)data name:(NSString *)name;- (void)appendPartWithHeaders:(nullable NSDictionary &lt;NSString *, NSString *&gt; *)headers body:(NSData *)body;- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes delay:(NSTimeInterval)delay; Body部分： 12345678910111213141516171819202122232425262728@interface AFHTTPBodyPart : NSObject// 编码方式@property (nonatomic, assign) NSStringEncoding stringEncoding;// 头@property (nonatomic, strong) NSDictionary *headers;// 边界@property (nonatomic, copy) NSString *boundary;// 主体@property (nonatomic, strong) id body;// 主题内容长度@property (nonatomic, assign) unsigned long long bodyContentLength;// 流@property (nonatomic, strong) NSInputStream *inputStream;// 是否有初始边界@property (nonatomic, assign) BOOL hasInitialBoundary;// 是否有结束边界@property (nonatomic, assign) BOOL hasFinalBoundary;// 是否有可用字节，是否为nil@property (readonly, nonatomic, assign, getter = hasBytesAvailable) BOOL bytesAvailable;// 长度@property (readonly, nonatomic, assign) unsigned long long contentLength;// 读取数据- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length;@end AFHTTPBodyPart类属性可以看出，已经包含了四大组成部分 1234567891011121314151617181920212223typedef enum &#123; AFEncapsulationBoundaryPhase = 1, AFHeaderPhase = 2, AFBodyPhase = 3, AFFinalBoundaryPhase = 4,&#125; AFHTTPBodyPartReadPhase;@interface AFHTTPBodyPart () &lt;NSCopying&gt; &#123; // 使用枚举 包装body4大组成部分 AFHTTPBodyPartReadPhase _phase; // 输入流 NSInputStream *_inputStream; // 每个组成部分的位置 unsigned long long _phaseReadOffset;&#125;// 转移到下一个阶段- (BOOL)transitionToNextPhase;// 读取数据- (NSInteger)readData:(NSData *)data intoBuffer:(uint8_t *)buffer maxLength:(NSUInteger)length;@end 对AFHTTPBodyPart的扩展部分，可以看出曾加了三个属性、两个方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// AFHTTPBodyPart 实现部分@implementation AFHTTPBodyPart// 初始化- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; [self transitionToNextPhase]; return self;&#125;- (void)dealloc &#123; if (_inputStream) &#123; [_inputStream close]; _inputStream = nil; &#125;&#125;// body可能有好几种类型，根据不同的类型返回不同方法创建的NSInputStream 。- (NSInputStream *)inputStream &#123; if (!_inputStream) &#123; if ([self.body isKindOfClass:[NSData class]]) &#123; _inputStream = [NSInputStream inputStreamWithData:self.body]; &#125; else if ([self.body isKindOfClass:[NSURL class]]) &#123; _inputStream = [NSInputStream inputStreamWithURL:self.body]; &#125; else if ([self.body isKindOfClass:[NSInputStream class]]) &#123; _inputStream = self.body; &#125; else &#123; _inputStream = [NSInputStream inputStreamWithData:[NSData data]]; &#125; &#125; return _inputStream;&#125;// 根据header字典拼body头- (NSString *)stringForHeaders &#123; NSMutableString *headerString = [NSMutableString string]; for (NSString *field in [self.headers allKeys]) &#123; [headerString appendString:[NSString stringWithFormat:@\"%@: %@%@\", field, [self.headers valueForKey:field], kAFMultipartFormCRLF]]; &#125; [headerString appendString:kAFMultipartFormCRLF]; return [NSString stringWithString:headerString];&#125;// 获取body的大小 用到几个函数- (unsigned long long)contentLength &#123; unsigned long long length = 0; // 初始化边界 NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; length += [encapsulationBoundaryData length]; // 头 NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; length += [headersData length]; // 主体 length += _bodyContentLength; // 结束边界 NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); length += [closingBoundaryData length]; return length;&#125;// 判断是否还有数据- (BOOL)hasBytesAvailable &#123; // Allows `read:maxLength:` to be called again if `AFMultipartFormFinalBoundary` doesn't fit into the available buffer if (_phase == AFFinalBoundaryPhase) &#123; return YES; &#125; switch (self.inputStream.streamStatus) &#123; case NSStreamStatusNotOpen: case NSStreamStatusOpening: case NSStreamStatusOpen: case NSStreamStatusReading: case NSStreamStatusWriting: return YES; case NSStreamStatusAtEnd: case NSStreamStatusClosed: case NSStreamStatusError: default: return NO; &#125;&#125;// 下面这两个方法是把body数据写入到buffer中。通过观察着这两个方法，可得知，这两个方法肯定在其他的代码中的某个循环中被调用，目的是得到想要的数据格式- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; NSInteger totalNumberOfBytesRead = 0; if (_phase == AFEncapsulationBoundaryPhase) &#123; NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFHeaderPhase) &#123; NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFBodyPhase) &#123; NSInteger numberOfBytesRead = 0; numberOfBytesRead = [self.inputStream read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; if (numberOfBytesRead == -1) &#123; return -1; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if ([self.inputStream streamStatus] &gt;= NSStreamStatusAtEnd) &#123; [self transitionToNextPhase]; &#125; &#125; &#125; if (_phase == AFFinalBoundaryPhase) &#123; NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; return totalNumberOfBytesRead;&#125;- (NSInteger)readData:(NSData *)data intoBuffer:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; // 比较数据和允许的最大长度 选取比较小的那个 NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length] - ((NSUInteger)_phaseReadOffset), length)); // copy data中range的数据到buffer [data getBytes:buffer range:range]; _phaseReadOffset += range.length; if (((NSUInteger)_phaseReadOffset) &gt;= [data length]) &#123; [self transitionToNextPhase]; &#125; return (NSInteger)range.length;&#125;- (BOOL)transitionToNextPhase &#123; // 保证主线程执行代码 if (![[NSThread currentThread] isMainThread]) &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; [self transitionToNextPhase]; &#125;); return YES; &#125; switch (_phase) &#123; case AFEncapsulationBoundaryPhase: _phase = AFHeaderPhase; break; case AFHeaderPhase: // 打开流，准备接收数据 [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; [self.inputStream open]; _phase = AFBodyPhase; break; case AFBodyPhase: // 关闭流 [self.inputStream close]; _phase = AFFinalBoundaryPhase; break; case AFFinalBoundaryPhase: default: _phase = AFEncapsulationBoundaryPhase; break; &#125; // 重置offset _phaseReadOffset = 0; return YES;&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFHTTPBodyPart *bodyPart = [[[self class] allocWithZone:zone] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = self.headers; bodyPart.bodyContentLength = self.bodyContentLength; bodyPart.body = self.body; bodyPart.boundary = self.boundary; return bodyPart;&#125;@end 其实AFHTTPBodyPart就像是一个个具体的数据一样，而AFMultipartBodyStream更像是一个管道，和body相连，数据从body沿着管道流入request中去。 这层抽象的概念还是蛮重要的。再设计之初，这两个抽象类就应该各自完成各自的任务，即使body中也有stream 但那也只属于body自身的业务。 1234567891011121314151617// AFHTTPBodyPart就像是一个个具体的数据一样，而AFMultipartBodyStream更像是一个管道@interface AFMultipartBodyStream : NSInputStream &lt;NSStreamDelegate&gt;// 读取包的大小@property (nonatomic, assign) NSUInteger numberOfBytesInPacket;// 延时@property (nonatomic, assign) NSTimeInterval delay;// 输入流@property (nonatomic, strong) NSInputStream *inputStream;// 内容大小@property (readonly, nonatomic, assign) unsigned long long contentLength;// 是否为空@property (readonly, nonatomic, assign, getter = isEmpty) BOOL empty;- (instancetype)initWithStringEncoding:(NSStringEncoding)encoding;- (void)setInitialAndFinalBoundaries;- (void)appendHTTPBodyPart:(AFHTTPBodyPart *)bodyPart;@end 它是继承自NSInputStream的，数据最终是通过setHTTPBodySteam方法传递给Request的。是一个NSInputStream类型，因此AFMultipartBodyStream 继承自NSInputStream 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - NSInputStream- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; if ([self streamStatus] == NSStreamStatusClosed) &#123; return 0; &#125; NSInteger totalNumberOfBytesRead = 0; // 遍历读取数据 while ((NSUInteger)totalNumberOfBytesRead &lt; MIN(length, self.numberOfBytesInPacket)) &#123; // 如果当前读取的body不存在或者body没有可读字节 if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) &#123; // 把下一个body赋值给当前的body 如果下一个为nil 就退出循环 if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator nextObject])) &#123; break; &#125; &#125; else &#123; // 当前body存在 // 剩余可读文件的大小 NSUInteger maxLength = MIN(length, self.numberOfBytesInPacket) - (NSUInteger)totalNumberOfBytesRead; // 把当前的body的数据读入到buffer中 NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; if (numberOfBytesRead == -1) &#123; self.streamError = self.currentHTTPBodyPart.inputStream.streamError; break; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if (self.delay &gt; 0.0f) &#123; [NSThread sleepForTimeInterval:self.delay]; &#125; &#125; &#125; &#125; return totalNumberOfBytesRead;&#125; 这个方法是AFMultipartBodyStream通过body读取数据的核心方法。下面通过举一个例子来看看这个方法究竟是怎么工作的？ 假如我们上传一张图片img.png 他的大小为80000，也就是差不多80k吧。 通过AFMultipartBodyStream读取数据，会首先调用上边的方法。读取数据并不是一次性读取的，而是分批分次读取的，这这个方法中，每次读取的大小为32k，也就是32*1024 = 32768的大小。 第一次调用后self.currentHTTPBodyPart 指向我们的img.png 通过NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; 方法在body中读取了32768大小的数据保存到了缓存buffer中。 由于整个图片大小是80000 一次调用只读取了32768 还有数据没读完，一次这个方法还会再次被调用。 第二次调用这个方法，由于[self.currentHTTPBodyPart hasBytesAvailable]还有数据，所以还是会走到else的方法中，self.currentHTTPBodyPart并没有指向别的body。因此继续执行 3.的方法。 至于为什么能接着从上次的已读取的数据开始读数据，这个是body内部封装实现的，可参考本文上边关于body的介绍。 重复 3 4 5 的步骤，直到没有数据可读时，stream就会关闭流。到此我们的突变数据就以流的形式上传到服务器了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(![method isEqualToString:@\"GET\"] &amp;&amp; ![method isEqualToString:@\"HEAD\"]); NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error]; __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (parameters) &#123; for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123; NSData *data = nil; if ([pair.value isKindOfClass:[NSData class]]) &#123; data = pair.value; &#125; else if ([pair.value isEqual:[NSNull null]]) &#123; data = [NSData data]; &#125; else &#123; data = [[pair.value description] dataUsingEncoding:self.stringEncoding]; &#125; if (data) &#123; [formData appendPartWithFormData:data name:[pair.field description]]; &#125; &#125; &#125; if (block) &#123; block(formData); &#125; return [formData requestByFinalizingMultipartFormData];&#125;// setHTTPBodyStream方法 需要设置NSInputStream类型的对象- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; [self.request setHTTPBodyStream:self.bodyStream]; [self.request setValue:[NSString stringWithFormat:@\"multipart/form-data; boundary=%@\", self.boundary] forHTTPHeaderField:@\"Content-Type\"]; [self.request setValue:[NSString stringWithFormat:@\"%llu\", [self.bodyStream contentLength]] forHTTPHeaderField:@\"Content-Length\"]; return self.request;&#125; 上传多个文件的时候回用到这个方法，里面有一个接受AFMultipartFormData协议的对象，AFN没有让AFMultipartBodyStream接受这个协议来处理。而是用另外一个类AFStreamingMultipartFormData来接受这个协议，就是为了把功能和业务代码逻辑分开。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187@interface AFStreamingMultipartFormData ()@property (readwrite, nonatomic, copy) NSMutableURLRequest *request;@property (readwrite, nonatomic, assign) NSStringEncoding stringEncoding;@property (readwrite, nonatomic, copy) NSString *boundary;@property (readwrite, nonatomic, strong) AFMultipartBodyStream *bodyStream;@end@interface AFStreamingMultipartFormData : NSObject &lt;AFMultipartFormData&gt;- (instancetype)initWithURLRequest:(NSMutableURLRequest *)urlRequest stringEncoding:(NSStringEncoding)encoding;- (NSMutableURLRequest *)requestByFinalizingMultipartFormData;@end@implementation AFStreamingMultipartFormData- (instancetype)initWithURLRequest:(NSMutableURLRequest *)urlRequest stringEncoding:(NSStringEncoding)encoding&#123; self = [super init]; if (!self) &#123; return nil; &#125; self.request = urlRequest; self.stringEncoding = encoding; self.boundary = AFCreateMultipartFormBoundary(); self.bodyStream = [[AFMultipartBodyStream alloc] initWithStringEncoding:encoding]; return self;&#125;- (void)setRequest:(NSMutableURLRequest *)request&#123; _request = [request mutableCopy];&#125;- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name error:(NSError * __autoreleasing *)error&#123; NSParameterAssert(fileURL); NSParameterAssert(name); NSString *fileName = [fileURL lastPathComponent]; NSString *mimeType = AFContentTypeForPathExtension([fileURL pathExtension]); return [self appendPartWithFileURL:fileURL name:name fileName:fileName mimeType:mimeType error:error];&#125;- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType error:(NSError * __autoreleasing *)error&#123; NSParameterAssert(fileURL); NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); if (![fileURL isFileURL]) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@\"Expected URL to be a file URL\", @\"AFNetworking\", nil)&#125;; if (error) &#123; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo]; &#125; return NO; &#125; else if ([fileURL checkResourceIsReachableAndReturnError:error] == NO) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@\"File URL not reachable.\", @\"AFNetworking\", nil)&#125;; if (error) &#123; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo]; &#125; return NO; &#125; NSDictionary *fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:[fileURL path] error:error]; if (!fileAttributes) &#123; return NO; &#125; NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\", name, fileName] forKey:@\"Content-Disposition\"]; [mutableHeaders setValue:mimeType forKey:@\"Content-Type\"]; AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = mutableHeaders; bodyPart.boundary = self.boundary; bodyPart.body = fileURL; bodyPart.bodyContentLength = [fileAttributes[NSFileSize] unsignedLongLongValue]; [self.bodyStream appendHTTPBodyPart:bodyPart]; return YES;&#125;- (void)appendPartWithInputStream:(NSInputStream *)inputStream name:(NSString *)name fileName:(NSString *)fileName length:(int64_t)length mimeType:(NSString *)mimeType&#123; NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\", name, fileName] forKey:@\"Content-Disposition\"]; [mutableHeaders setValue:mimeType forKey:@\"Content-Type\"]; AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = mutableHeaders; bodyPart.boundary = self.boundary; bodyPart.body = inputStream; bodyPart.bodyContentLength = (unsigned long long)length; [self.bodyStream appendHTTPBodyPart:bodyPart];&#125;- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType&#123; NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\", name, fileName] forKey:@\"Content-Disposition\"]; [mutableHeaders setValue:mimeType forKey:@\"Content-Type\"]; [self appendPartWithHeaders:mutableHeaders body:data];&#125;- (void)appendPartWithFormData:(NSData *)data name:(NSString *)name&#123; NSParameterAssert(name); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"\", name] forKey:@\"Content-Disposition\"]; [self appendPartWithHeaders:mutableHeaders body:data];&#125;- (void)appendPartWithHeaders:(NSDictionary *)headers body:(NSData *)body&#123; NSParameterAssert(body); AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = headers; bodyPart.boundary = self.boundary; bodyPart.bodyContentLength = [body length]; bodyPart.body = body; [self.bodyStream appendHTTPBodyPart:bodyPart];&#125;- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes delay:(NSTimeInterval)delay&#123; self.bodyStream.numberOfBytesInPacket = numberOfBytes; self.bodyStream.delay = delay;&#125;- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; [self.request setHTTPBodyStream:self.bodyStream]; [self.request setValue:[NSString stringWithFormat:@\"multipart/form-data; boundary=%@\", self.boundary] forHTTPHeaderField:@\"Content-Type\"]; [self.request setValue:[NSString stringWithFormat:@\"%llu\", [self.bodyStream contentLength]] forHTTPHeaderField:@\"Content-Length\"]; return self.request;&#125;@end 定义AFStreamingMultipartFormData，接受AFMultipartFormData，实现协议方法，把文件封装成bodyPart对象存储到AFStreamingMultipartFormData对象的属性bodyStream的数组中。通过read maxLength读取数据。 AFJSONRequestSerializer和AFPropertyListRequestSerializer这两个类继承自AFHTTPRequestSerializer。他们的基本实现都是继承自父类。但是也根据自身不同情况，做了处理。对于AFJSONRequestSerializer。需要把Content-Type指定为”application/json。同时HTTPBody需要使用JSON序列化： 1234567891011121314151617181920212223242526272829303132333435363738394041- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); /* 对于`GET`,`HEAD`,`DELETE`等方法中。直接使用父类的处理方式 */ if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; return [super requestBySerializingRequest:request withParameters:parameters error:error]; &#125; NSMutableURLRequest *mutableRequest = [request mutableCopy]; //把`HTTPRequestHeaders`中的值添加进入请求头中。 [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; if (parameters) &#123; //设置请求头的`Content-Type`类型 if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123; [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; &#125; if (![NSJSONSerialization isValidJSONObject:parameters]) &#123; if (error) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@&quot;The `parameters` argument is not valid JSON.&quot;, @&quot;AFNetworking&quot;, nil)&#125;; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo]; &#125; return nil; &#125; //把parameters转换为JSON序列化的data NSData *jsonData = [NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]; if (!jsonData) &#123; return nil; &#125; //JSON序列化的数据设置为httpbody [mutableRequest setHTTPBody:jsonData]; &#125; return mutableRequest;&#125; 对于AFPropertyListRequestSerializer也是同样的道理： 123456789101112131415161718192021222324252627282930313233- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); /* 对于`GET`,`HEAD`,`DELETE`等方法中。直接使用父类的处理方式 */ if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; return [super requestBySerializingRequest:request withParameters:parameters error:error]; &#125; NSMutableURLRequest *mutableRequest = [request mutableCopy]; //把`HTTPRequestHeaders`中的值添加进入请求头中。 [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; if (parameters) &#123; //设置请求头的`Content-Type`类型 if (![mutableRequest valueForHTTPHeaderField:@\"Content-Type\"]) &#123; [mutableRequest setValue:@\"application/x-plist\" forHTTPHeaderField:@\"Content-Type\"]; &#125; //把parameters转换为Plist序列化的data NSData *plistData = [NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]; if (!plistData) &#123; return nil; &#125; //Plist序列化的数据设置为httpbody [mutableRequest setHTTPBody:plistData]; &#125; return mutableRequest;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"https://nixzhang5.github.io/tags/AFNetWorking原理/"}]},{"title":"App签名原理","slug":"App签名原理","date":"2019-06-26T03:29:11.000Z","updated":"2019-06-27T03:24:35.971Z","comments":true,"path":"App签名原理.html","link":"","permalink":"https://nixzhang5.github.io/App签名原理.html","excerpt":"App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。","text":"App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。 苹果签名需求： 为了保证系统的安全性，所有iPhone上安装的应用必须是经过苹果授权的 安装包不需要上传到App Store也能被安装 （开发调试 企业灰度） 防止证书权限滥用：设备限制、指定APP、iCloud/PUSH/后台运行等附加权限控制 下载App签名签名原理： App上传到App Store时，苹果公司拿到App的HASH(MD5,SHA等)值，然后用私钥进行加密(签名)，这时候只有手机上的公钥才可以解密； 手机下载应用安装App时，先用公钥解密(验证签名)，拿到HASH值，然后将此HASH值，与要安装的App的HASH值进行校验，如果App有被修改过，则校验失败。这样就可以有效的保证每个App都是经过苹果公司官方认证的。 双层签名真机调试，企业包上面的签名方式就不适合了。这时候需要双层签名： 在Mac系统中生成一对非对称加密算法的公私钥M（keychain 里的 从证书颁发机构请求证书，保存的CertificateSigningRequest就包含公钥M，私钥保存在本地）。 苹果自己有固定的一对公私钥：私钥A在苹果后台，公钥A在每个iOS系统的手机中。 申请证书，把CertificateSigningRequest.certSigningRequest文件（包含公钥M，以及一些开发者信息）发送给苹果后台，用苹果后台的私钥A对公钥M签名，得到一份包含公钥M以及其签名结果的数据就是证书。 生成的证书下载下来，keychain会把这两个证书关联起来，因为公私钥是对应的。这个私钥只有这台电脑有，团队开发需要把这个私钥导出.p12给其他Mac. 配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件（包含设备IDs,AppID,Entitlements(权力文件包含是否可调试，推送，后台运行等信息)）。 XCode 会通过第3步下载回来的证书（存着公钥），在本地找到对应的私钥（第1步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。 打包过程用私钥M对App的HASH值进行加密(签名)，这时的APP内部实际包含了APP的签名(私钥M加密App的HASH值)、第3步生成的证书文件(包含公钥M和公钥M的HASH值)、Provision Profile(描述文件)，App可执行文件以及其他信息 解密： iPhone手机拿到证书文件(包含公钥M和公钥M的HASH值)，因为手机里有公钥A，所以能解密证书文件，得到公钥M和公钥M的HASH值，先验证公钥M生成的HASH值(MD5,SHA等)是不是和证书文件里的公钥M的HASH值一致，确保证书没有被修改； 验证一致后，就可以用公钥M来解密第2步的APP的签名，同样道理可以验证App是否被修改过。 因为在开发阶段App会经常修改，所以App就算是修改过，也能安装。第4步主要是验证证书是不是苹果认证的，只要证书对就可以安装运行。 加密解密： mac电脑：私钥M和公钥M(电脑生成) 苹果服务器：私钥A iPhone手机：公钥A .ipa包含的信息： 资源文件，例如图片、html、等等。 _CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。 可执行文件。此文件跟资源文件一样需要签名。 一个mobileprovision文件.打包的时候使用的，从MC上生成的。 Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件。 签名原理图： 签名原理图","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"Encryption","slug":"Encryption","permalink":"https://nixzhang5.github.io/tags/Encryption/"}]},{"title":"加密","slug":"加密","date":"2019-06-26T02:27:44.000Z","updated":"2019-06-26T03:25:10.730Z","comments":true,"path":"加密.html","link":"","permalink":"https://nixzhang5.github.io/加密.html","excerpt":"加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。","text":"加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。 对称加密A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。 优点简单快捷，密钥较短，且破译困难。 缺点如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通的两个用户之间怎么确定密钥也需要考虑，这其中就会有密钥泄露的风险，以及存在更换密钥的需求。 对称加密通常有 AES, DES, IDEA, 3DES 加密算法。 非对称加密用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。 缺点加解密比对称加密耗时. 优点比对称加密安全. 但是非对称加密也是存在漏洞，因为公钥是公开的，如果有 C 冒充 B 的身份利用 A 的公钥给 A 发消息，这样就乱套了，所以接下来就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。 常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） Hash算法（摘要算法）Hash算法的特点是单向不可还原，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。只要源数据不同，算法得到的摘要必定不同。 常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA 数字签名数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。 数字签名是 A将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要一起发送给B；B接收到后解密，得到这个摘要 a 和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要 b，比较 a 与 b 就可得知在传输过程中是否被更改过。 因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。 完整的非对称加密过程假如现在 你向支付宝 转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为： 首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息， 你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等； 你 对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）； 你 用自己的私钥对信息摘要进行加密得到 你 的数字签名，并将其附在数字信息上； 你 随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）； 你用 支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝； 支付宝收到 你 传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到 你随机产生的加密密钥； 支付宝 然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃； 支付宝 用你 的公钥对 你的的数字签名进行解密，得到信息摘要； 支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要； 支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。 确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。在这后面的流程就不属于本次非对称加密的范畴，算支付宝个人的自我流程，也就是循环以上过程。 iOS常用的加密方式Base64加密、MD5加密、AES加密、RSA加密 Base64加密Base64编码的思想是：采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组，以3个字节为一组，按顺序排列24位数据，再把这24位数据分成4组，即每组6位；再在每组的的最高位前补两个0凑足一个字节，这样就把一个3字节为一组的数据重新编码成了4个字节；当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节，这时在最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。例如：将对ABC进行Base64编码首先取ABC对应的ASCII码值，A : 65、B : 66、C : 67，再取二进制值A : 01000001、B : 01000010、C : 01000011，然后把这三个字节的二进制码接起来010000010100001001000011，再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值00010000、00010100、00001001、00000011；再把这4个字节数据转化成10进制数得16、20、19、3；最后根据Base64给出的64个基本字符表，查出对应的ASCII码字符Q、U、J、D，这里的值实际就是数据在字符表中的索引。解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。注：Base64字符表，包括大写A-Z小写a-z数字0-9和+以及/。Base64加密原则：6bit（原8bit）一个字节，不足的位数用0补齐，两个0用一个=表示。Base64加密特点： 数据加密之后，数据量会变大，变大1/3左右。 可进行反向解密。 编码后有个非常显著的特点，末尾有个=号。 其实Base64不算是加密，只是一种编码格式。 在iOS中Base64加解密使用方法介绍（本例使用系统API，仅支持iOS7及以后的系统版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/****************************Base64.m类实现文件内容****************************/+ (NSString *)base64EncodedStringWithData:(NSData *)data&#123; //判断是否传入需要加密数据参数 if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; //判断设备系统是否满足条件 if ([[[UIDevice currentDevice] systemVersion] doubleValue] &lt;= 6.9) &#123; return nil; &#125; //使用系统的API进行Base64加密操作 NSDataBase64EncodingOptions options; options = NSDataBase64EncodingEndLineWithLineFeed; return [data base64EncodedStringWithOptions:options];&#125;+ (NSData *)base64DecodeDataWithString:(NSString *)string&#123; //判断是否传入需要加密数据参数 if ((string == nil) || (string == NULL)) &#123; return nil; &#125; else if (![string isKindOfClass:[NSString class]]) &#123; return nil; &#125; //判断设备系统是否满足条件 if ([[[UIDevice currentDevice] systemVersion] doubleValue] &lt;= 6.9) &#123; return nil; &#125; //使用系统的API进行Base64解密操作 NSDataBase64DecodingOptions options; options = NSDataBase64DecodingIgnoreUnknownCharacters; return [[NSData alloc] initWithBase64EncodedString:string options:options];&#125;/*****************************************************************************///使用Base64文件进行Base64加密和解密/*********************************使用Base64类*********************************///使用Base64执行加密操作NSString *string = @\"abcdefghijklmnopqrstuvwxyz\";NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];NSString *encodeString = [Base64 base64EncodedStringWithData:data];NSLog(@\"encodeString : %@\", encodeString);//使用Base64执行解密操作NSString *decodeString = nil;NSData *decodeData = [Base64 base64DecodeDataWithString:encodeString];decodeString = [[NSString alloc] initWithData:decodeData encoding:NSUTF8StringEncoding];NSLog(@\"decodeString : %@\", decodeString);/******************************************************************************/ MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）MD5的全称是Message-DigestAlgorithm 5，Message-Digest泛指字节串(Message)的Hash变换，就是把一个任意长度的字节串变换成一定长的大整数。请注意我使用了字节串而不是字符串这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的字节串变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被”篡改”。举个例子，你将一段话写在一个叫readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的”抵赖”，这就是所谓的数字签名应用。MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的，用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并”不知道”用户的密码是什么。MD5加密大体都应用在：验证数据或文件一致性、数字签名、安全访问认证等等。大概可比喻为：人的指纹来理解。注：MD5加密是不可逆的，也就是说，MD5加密后是不能解密的，所谓的解密只是用大数据的”试用”，来测出结果的。MD5特点: 压缩性 : 任意长度的数据,算出的MD5值长度都是固定的。 容易计算 : 从原数据计算出MD5值很容易。 抗修改性 : 对原数据进行任何改动，哪怕只修改一个字节，所得到的MD5值都有很大区别。 弱抗碰撞 : 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 强抗碰撞 : 想找到两个不同数据，使他们具有相同的MD5值，是非常困难的。 在iOS中MD5加密和验签使用方法介绍 123456789101112131415161718192021222324252627282930313233343536373839/****************************MD5.m类实现文件内容****************************///对字符串数据进行MD5的签名+ (NSString *)md5SignWithString:(NSString *)string&#123; const char *object = [string UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(object,(CC_LONG)strlen(object),result); NSMutableString *hash = [NSMutableString string]; for (int i = 0; i &lt; 16; i ++) &#123; [hash appendFormat:@\"%02X\", result[i]]; &#125; return [hash lowercaseString];&#125;//对二进制数据进行MD5的签名+ (NSData *)md5SignWithData:(NSData *)data&#123; Byte byte[CC_MD5_DIGEST_LENGTH]; //定义一个字节数组来接收结果 CC_MD5((const void*)([data bytes]), (CC_LONG)[data length], byte); return [NSData dataWithBytes:byte length:CC_MD5_DIGEST_LENGTH];&#125;/******************************************************************************///使用MD5文件进行MD5加密和验签/*********************************使用MD5类*********************************///使用MD5执行加密操作NSString *string2 = @\"abcdefghijklmnopqrstuvwxyz\";NSString *encodeString2 = [MD5 md5SignWithString:string2];NSLog(@\"encodeString2 : %@\", encodeString2);//MD5为不可逆的操作，使用MD5执行验签操作NSString *verifyString2 = [MD5 md5SignWithString:string2];NSLog(@\"verifyString2 : %@\", verifyString2);if ([verifyString2 isEqualToString:encodeString2]) &#123; NSLog(@\"md5 verify sign success\");&#125; else &#123; NSLog(@\"md5 verify sign failed\");&#125;/******************************************************************************/ AES加密（对称加密的一种）高级加密标准Advanced Encryption Standard简称：AES，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。它是一种对称加密算法，这个标准也替代原先的DES标准，已经被多方分析且广为全世界所使用。AES设计有三个密钥长度:128、192、256位，相对而言，AES的128密钥比DES的56密钥强1021倍。AES算法主要包括三个方面：轮变化、圈数和密钥扩展。总体来说，AES作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活，在软件及硬件上都能快速地加解密且只需要很少的存储资源等优点。 AES加解密特点： AES强安全性、高性能、高效率、易用和灵活。 在软件及硬件上都能快速地加解密且只需要很少的存储资源。 AES加密需要的参数： 密钥长度（Key Size）AES算法下，key的长度有三种：128、192和256 bits。由于历史原因，JDK默认只支持不大于128 bits的密钥，而128 bits的key已能够满足商用安全需求。因此本例先使用AES-128。（Java使用大于128 bits的key方法在文末提及） 加密模式（Cipher Mode）AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。本例统一使用CBC模式。 填充方式（Padding）由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）在iOS SDK中提供了PKCS7Padding，而JDK则提供了PKCS5Padding。原则上PKCS5Padding限制了填充的Block Size为8 bytes，而Java实际上当块大于该值时，其PKCS5Padding与PKCS7Padding是相等的：每需要填充χ个字节，填充的值就是χ。 初始向量（Initialization Vector）使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等（AES的Block Size为128 bits），而两个平台的API文档均指明当不传入初始向量时，系统将默认使用一个全0的初始向量。有了上述的基础之后，可以开始分别在两个平台进行实现了。 在iOS中AES加解密的实现介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//需要导入：#import &lt;CommonCrypto/CommonCrypto.h&gt;库才能使用/** * AES128 + ECB + PKCS7 * @param data 要加密的原始数据 * @param key 加密 key * @return 加密后数据 */+ (NSData *)encryptData:(NSData *)data key:(NSData *)key&#123; //判断解密的流数据是否存在 if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([data length] &lt;= 0) &#123; return nil; &#125; //判断解密的Key是否存在 if ((key == nil) || (key == NULL)) &#123; return nil; &#125; else if (![key isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([key length] &lt;= 0) &#123; return nil; &#125; //setup key NSData *result = nil; unsigned char cKey[kCCKeySizeAES128]; bzero(cKey, sizeof(cKey)); [key getBytes:cKey length:kCCKeySizeAES128]; //setup output buffer size_t bufferSize = [data length] + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //do encrypt size_t encryptedSize = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionECBMode|kCCOptionPKCS7Padding, cKey, kCCKeySizeAES128, nil, [data bytes], [data length], buffer, bufferSize, &amp;encryptedSize); if (cryptStatus == kCCSuccess) &#123; result = [NSData dataWithBytesNoCopy:buffer length:encryptedSize]; &#125; else &#123; free(buffer); &#125; return result;&#125;/** * AES128 + ECB + PKCS7 * @param data 要解密的原始数据 * @param key 解密 key * @return 解密后数据 */+ (NSData *)decryptData:(NSData *)data key:(NSData *)key&#123; //判断解密的流数据是否存在 if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([data length] &lt;= 0) &#123; return nil; &#125; //判断解密的Key是否存在 if ((key == nil) || (key == NULL)) &#123; return nil; &#125; else if (![key isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([key length] &lt;= 0) &#123; return nil; &#125; //setup key NSData *result = nil; unsigned char cKey[kCCKeySizeAES128]; bzero(cKey, sizeof(cKey)); [key getBytes:cKey length:kCCKeySizeAES128]; //setup output buffer size_t bufferSize = [data length] + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //do decrypt size_t decryptedSize = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionECBMode|kCCOptionPKCS7Padding, cKey, kCCKeySizeAES128, nil, [data bytes], [data length], buffer, bufferSize, &amp;decryptedSize); if (cryptStatus == kCCSuccess) &#123; result = [NSData dataWithBytesNoCopy:buffer length:decryptedSize]; &#125; else &#123; free(buffer); &#125; return result;&#125; 在iOS中AES加解密使用方法介绍 123456789101112131415//使用AES执行加密操作NSString *aesKey = @\"a1b2c3d4e5f6g7h8\";NSString *string3 = @\"abcdefghijklmnopqrstuvwxyz\";NSData *keyData3 = [aesKey dataUsingEncoding:NSUTF8StringEncoding];NSData *sourceData3 = [string3 dataUsingEncoding:NSUTF8StringEncoding];NSData *encodeData3 = [AESEncrypt encryptData:sourceData3 key:keyData3];NSLog(@\"encodeData3 : %@\", encodeData3);//使用AES执行解密操作NSString *decodeString3 = nil;NSData *decodeData3 = [AESEncrypt decryptData:encodeData3 key:keyData3];decodeString3 = [[NSString alloc] initWithData:decodeData3 encoding:NSUTF8StringEncoding];NSLog(@\"decodeString3 : %@\", decodeString3); RSA加密（非对称加密的一种）RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要，对方收到信息后，用不同的密钥解密并可核对信息摘要。RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作，RSA是被研究得最广泛的公钥算法。RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。RSA加密大体都应用在：本地数据加密、网络传输数据加密、方法体和方法名高级混淆以及程序结构混排加密。例如：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取。 RSA的算法涉及三个参数，n、e1、e2。其中，n是两个大质数p、q的积，n的二进制表示时所占用的位数，就是所谓的密钥长度。e1和e2是一对相关的值，e1可以任意取，但要求e1与(p-1)(q-1)互质；再选择e2，要求(e2e1)mod((p-1)*(q-1))=1。(n，e1)，(n，e2)就是密钥对。其中(n，e1)为公钥，(n，e2)为私钥；RSA加解密的算法完全相同，公钥加密体制中，一般用公钥加密，私钥解密。假设A为明文，B为密文，则：A=B^e2 mod n；B=A^e1 mod n；e1和e2可以互换使用，即私钥加密，公钥解密，公式：A=B^e1 mod n；B=A^e2 mod n; RSA加解密特点： RSA密钥管理的方便，计算量很大速度相对比较慢。 RSA安全性很高，能够抵抗到目前为止已知的绝大多数密码攻击。在线生成RSA密钥对的网址：在线生成非对称加密公钥私钥对等，RSA密钥格式请使用PKCS#8格式。PKCS#1与PKCS#8的区别还待后续查阅资料，再进行补充记录。 在iOS中RSA加解密的实现介绍（支持密钥文件&lt;.pem&gt;和字符串密钥） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655/****************************RSAEncrypt.m类实现文件内容****************************/#pragma mark - Class Utils Method+ (BOOL)isEmptyKeyRef:(id)object&#123; if (object == nil) &#123; return YES; &#125; else if (object == NULL) &#123; return YES; &#125; else if (object == [NSNull null]) &#123; return YES; &#125; return NO;&#125;#pragma mark - Private Method+ (SecKeyRef)getPrivateKeyRefWithFilePath:(NSString *)filePath keyPassword:(NSString *)keyPassword&#123; //读取私钥证书文件的内容 NSData *certificateData = [NSData dataWithContentsOfFile:filePath]; if ((certificateData == nil) || (certificateData == NULL)) &#123; return nil; &#125; else if (![certificateData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([certificateData length] &lt;= 0) &#123; return nil; &#125; //拼接密码参数到字典中 NSString *passwordKey = (__bridge id)kSecImportExportPassphrase; NSString *passwordValue = [NSString stringWithFormat:@\"%@\",keyPassword]; if ((keyPassword == nil) || (keyPassword == NULL)) &#123; passwordValue = @\"\"; &#125; else if (![keyPassword isKindOfClass:[NSString class]]) &#123; passwordValue = @\"\"; &#125; else if ([keyPassword length] &lt;= 0) &#123; passwordValue = @\"\"; &#125; NSMutableDictionary *optionInfo = [[NSMutableDictionary alloc] init]; [optionInfo setObject:passwordValue forKey:passwordKey]; //获取私钥对象 SecKeyRef privateKeyRef = NULL; CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL); CFDataRef pkcs12Data = (__bridge CFDataRef)certificateData; CFDictionaryRef options = (__bridge CFDictionaryRef)optionInfo; OSStatus securityStatus = SecPKCS12Import(pkcs12Data, options, &amp;items); if (securityStatus == noErr &amp;&amp; CFArrayGetCount(items) &gt; 0) &#123; SecIdentityRef identity; const void *secpkey = kSecImportItemIdentity; CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0); identity = (SecIdentityRef)CFDictionaryGetValue(identityDict,secpkey); securityStatus = SecIdentityCopyPrivateKey(identity, &amp;privateKeyRef); if (securityStatus != noErr) &#123; privateKeyRef = NULL; &#125; &#125; CFRelease(items); return privateKeyRef;&#125;+ (SecKeyRef)privateKeyRefWithPrivateKey:(NSString *)privateKey&#123; //判断参数是否正确 if ((privateKey == nil) || (privateKey == NULL)) &#123; return nil; &#125; else if (![privateKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKey length] &lt;= 0) &#123; return nil; &#125; //解析私钥对象内容 NSString *pKey = [NSString stringWithFormat:@\"%@\",privateKey]; NSRange sposition = [pKey rangeOfString:@\"-----BEGIN RSA PRIVATE KEY-----\"]; NSRange eposition = [pKey rangeOfString:@\"-----END RSA PRIVATE KEY-----\"]; if (sposition.location != NSNotFound &amp;&amp; eposition.location != NSNotFound) &#123; NSUInteger endposition = eposition.location; NSUInteger startposition = sposition.location + sposition.length; NSRange range = NSMakeRange(startposition, endposition-startposition); pKey = [pKey substringWithRange:range]; &#125; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; //This will be base64 encoded, decode it. NSData *keyData = [Base64 base64DecodeDataWithString:pKey]; keyData = [self stripPrivateKeyHeader:keyData]; if ((keyData == nil) || (keyData == NULL)) &#123; return nil; &#125; else if (![keyData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([keyData length] &lt;= 0) &#123; return nil; &#125; //a tag to read/write keychain storage NSString *tag = @\"RSAUtil_PrivKey\"; const void *bytes = [tag UTF8String]; NSData *tagData = [NSData dataWithBytes:bytes length:[tag length]]; //Delete any old lingering key with the same tag NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init]; [attributes setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; [attributes setObject:tagData forKey:(__bridge id)kSecAttrApplicationTag]; SecItemDelete((__bridge CFDictionaryRef)attributes); //Add persistent version of the key to system keychain [attributes setObject:keyData forKey:(__bridge id)kSecValueData]; [attributes setObject:(__bridge id)kSecAttrKeyClassPrivate forKey:(__bridge id)kSecAttrKeyClass]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnPersistentRef]; OSStatus status = noErr; CFTypeRef persistKey = nil; status = SecItemAdd((__bridge CFDictionaryRef)attributes, &amp;persistKey); if (persistKey != nil) &#123;CFRelease(persistKey);&#125; if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) &#123; return nil; &#125; [attributes removeObjectForKey:(__bridge id)kSecValueData]; [attributes removeObjectForKey:(__bridge id)kSecReturnPersistentRef]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; //Now fetch the SecKeyRef version of the key SecKeyRef keyRef = nil; CFDictionaryRef query = (__bridge CFDictionaryRef)attributes; status = SecItemCopyMatching(query, (CFTypeRef *)&amp;keyRef); if (status != noErr) &#123; return nil; &#125; return keyRef;&#125;+ (NSData *)stripPrivateKeyHeader:(NSData *)d_key&#123; //Skip ASN.1 private key header if (d_key == nil) return nil; unsigned long len = [d_key length]; if (!len) return nil; unsigned char *c_key = (unsigned char *)[d_key bytes]; unsigned int idx = 22; //magic byte at offset 22 if (0x04 != c_key[idx++]) return nil; //calculate length of the key unsigned int c_len = c_key[idx++]; if (!(c_len &amp; 0x80)) &#123; c_len = c_len &amp; 0x7f; &#125; else &#123; int byteCount = c_len &amp; 0x7f; if (byteCount + idx &gt; len) &#123; //rsa length field longer than buffer return nil; &#125; unsigned int accum = 0; unsigned char *ptr = &amp;c_key[idx]; idx += byteCount; while (byteCount) &#123; accum = (accum &lt;&lt; 8) + *ptr; ptr++; byteCount--; &#125; c_len = accum; &#125; //Now make a new NSData from this buffer return [d_key subdataWithRange:NSMakeRange(idx, c_len)];&#125;+ (SecKeyRef)getPublicKeyRefWithFilePath:(NSString *)filePath&#123; //读取公钥证书文件的内容 NSData *certificateData = [NSData dataWithContentsOfFile:filePath]; if ((certificateData == nil) || (certificateData == NULL)) &#123; return nil; &#125; else if (![certificateData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([certificateData length] &lt;= 0) &#123; return nil; &#125; //将公钥证书制作成证书对象 CFDataRef data = (__bridge CFDataRef)certificateData; SecCertificateRef certificateRef = SecCertificateCreateWithData(NULL, data); //获取公钥对象 SecTrustRef trust = NULL; SecKeyRef publicKey = NULL; SecPolicyRef policies = SecPolicyCreateBasicX509(); if (![[self class] isEmptyKeyRef:(__bridge id)(certificateRef)] &amp;&amp; ![[self class] isEmptyKeyRef:(__bridge id)(policies)]) &#123; OSStatus status; status = SecTrustCreateWithCertificates((CFTypeRef)certificateRef, policies, &amp;trust); if (status == noErr) &#123; SecTrustResultType result; if (SecTrustEvaluate(trust, &amp;result) == noErr) &#123; publicKey = SecTrustCopyPublicKey(trust); &#125; &#125; &#125; if (certificateRef != NULL) CFRelease(certificateRef); if (policies != NULL) CFRelease(policies); if (trust != NULL) CFRelease(trust); return publicKey;&#125;+ (SecKeyRef)publicKeyRefWithPublicKey:(NSString *)publicKey&#123; //判断参数是否正确 if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //解析公钥对象内容 NSString *pKey = [NSString stringWithFormat:@\"%@\",publicKey]; NSRange sposition = [pKey rangeOfString:@\"-----BEGIN PUBLIC KEY-----\"]; NSRange eposition = [pKey rangeOfString:@\"-----END PUBLIC KEY-----\"]; if (sposition.location != NSNotFound &amp;&amp; eposition.location != NSNotFound) &#123; NSUInteger startposition = eposition.location; NSUInteger endposition = sposition.location + sposition.length; NSRange range = NSMakeRange(endposition, startposition-endposition); pKey = [pKey substringWithRange:range]; &#125; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; //This will be base64 encoded, decode it. NSData *keyData = [[self class] base64DecodeDataWithString:pKey]; keyData = [self stripPublicKeyHeader:keyData]; if ((keyData == nil) || (keyData == NULL)) &#123; return nil; &#125; else if (![keyData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([keyData length] &lt;= 0) &#123; return nil; &#125; //a tag to read/write keychain storage NSString *tag = @\"RSAUtil_PubKey\"; const void *bytes = [tag UTF8String]; NSData *tagData = [NSData dataWithBytes:bytes length:[tag length]]; //Delete any old lingering key with the same tag NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init]; [attributes setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; [attributes setObject:tagData forKey:(__bridge id)kSecAttrApplicationTag]; SecItemDelete((__bridge CFDictionaryRef)attributes); //Add persistent version of the key to system keychain [attributes setObject:keyData forKey:(__bridge id)kSecValueData]; [attributes setObject:(__bridge id)kSecAttrKeyClassPublic forKey:(__bridge id)kSecAttrKeyClass]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnPersistentRef]; OSStatus status = noErr; CFTypeRef persistKey = nil; status = SecItemAdd((__bridge CFDictionaryRef)attributes, &amp;persistKey); if (persistKey != nil) CFRelease(persistKey); if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) &#123; return nil; &#125; [attributes removeObjectForKey:(__bridge id)kSecValueData]; [attributes removeObjectForKey:(__bridge id)kSecReturnPersistentRef]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; //Now fetch the SecKeyRef version of the key SecKeyRef publicKeyRef = nil; CFDictionaryRef query = (__bridge CFDictionaryRef)attributes; status = SecItemCopyMatching(query, (CFTypeRef *)&amp;publicKeyRef); if (status != noErr) &#123; return nil; &#125; return publicKeyRef;&#125;+ (NSData *)stripPublicKeyHeader:(NSData *)d_key&#123; //Skip ASN.1 public key header if (d_key == nil) &#123;return nil;&#125; unsigned long len = [d_key length]; if (!len) return(nil); unsigned char *c_key = (unsigned char *)[d_key bytes]; unsigned int idx = 0; if (c_key[idx++] != 0x30) &#123;return nil;&#125; if (c_key[idx] &gt; 0x80) &#123; idx += c_key[idx] - 0x80 + 1; &#125; else &#123; idx++; &#125; //PKCS #1 rsaEncryption szOID_RSA_RSA static unsigned char seqiod[] = &#123;0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00&#125;; if (memcmp(&amp;c_key[idx], seqiod, 15)) &#123;return nil;&#125; idx += 15; if (c_key[idx++] != 0x03) &#123;return nil;&#125; if (c_key[idx] &gt; 0x80) &#123; idx += c_key[idx] - 0x80 + 1; &#125; else &#123; idx ++; &#125; if (c_key[idx++] != '\\0') &#123;return nil;&#125; //Now make a new NSData from this buffer return ([NSData dataWithBytes:&amp;c_key[idx] length:len - idx]);&#125;+ (NSData *)encryptData:(NSData *)data withKeyRef:(SecKeyRef)keyRef&#123; const uint8_t *srcbuf = (const uint8_t *)[data bytes]; size_t srclen = (size_t)data.length; size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t); void *outbuf = malloc(block_size); size_t src_block_size = block_size - 11; NSMutableData *ret = [[NSMutableData alloc] init]; for (int idx = 0; idx &lt; srclen; idx += src_block_size) &#123; size_t data_len = srclen - idx; if(data_len &gt; src_block_size)&#123; data_len = src_block_size; &#125; size_t outlen = block_size; OSStatus status = noErr; status = SecKeyEncrypt(keyRef, kSecPaddingPKCS1, srcbuf + idx, data_len, outbuf, &amp;outlen); if (status != 0) &#123; NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", (int)status); ret = nil; break; &#125; else &#123; [ret appendBytes:outbuf length:outlen]; &#125; &#125; free(outbuf); CFRelease(keyRef); return ret;&#125;+ (NSData *)decryptData:(NSData *)data withKeyRef:(SecKeyRef)keyRef&#123; const uint8_t *srcbuf = (const uint8_t *)[data bytes]; size_t srclen = (size_t)data.length; size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t); UInt8 *outbuf = malloc(block_size); size_t src_block_size = block_size; NSMutableData *ret = [[NSMutableData alloc] init]; for (int idx = 0; idx &lt; srclen; idx += src_block_size) &#123; size_t data_len = srclen - idx; if(data_len &gt; src_block_size) &#123; data_len = src_block_size; &#125; size_t outlen = block_size; OSStatus status = noErr; status = SecKeyDecrypt(keyRef, kSecPaddingNone, srcbuf + idx, data_len, outbuf, &amp;outlen); if (status != 0) &#123; NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", (int)status); ret = nil; break; &#125; else &#123; int idxFirstZero = -1; int idxNextZero = (int)outlen; for (int i = 0; i &lt; outlen; i ++) &#123; if (outbuf[i] == 0) &#123; if (idxFirstZero &lt; 0) &#123; idxFirstZero = i; &#125; else &#123; idxNextZero = i; break; &#125; &#125; &#125; NSUInteger length = idxNextZero-idxFirstZero-1; [ret appendBytes:&amp;outbuf[idxFirstZero+1] length:length]; &#125; &#125; free(outbuf); CFRelease(keyRef); return ret;&#125;#pragma mark - RSA Key File Encrypt/Decrypt Public Method+ (NSString *)encryptString:(NSString *)originString publicKeyPath:(NSString *)publicKeyPath&#123; //判断originString参数是否正确 if ((originString == nil) || (originString == NULL)) &#123; return nil; &#125; else if (![originString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([originString length] &lt;= 0) &#123; return nil; &#125; //判断publicKeyPath参数是否正确 if ((publicKeyPath == nil) || (publicKeyPath == NULL)) &#123; return nil; &#125; else if (![publicKeyPath isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKeyPath length] &lt;= 0) &#123; return nil; &#125; //获取公钥对象和需要加密的字符串内容编码数据流 SecKeyRef publicKeyRef = [self getPublicKeyRefWithFilePath:publicKeyPath]; NSData *originData = [originString dataUsingEncoding:NSUTF8StringEncoding]; if ([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)]) &#123; return nil; &#125; if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; //加密源字符串内容编码数据流的数据 NSData *resultData = nil; resultData = [self encryptData:originData withKeyRef:publicKeyRef]; return [[self class] base64EncodedStringWithData:resultData];&#125;+ (NSString *)decryptString:(NSString *)encryptString privateKeyPath:(NSString *)privateKeyPath privateKeyPwd:(NSString *)privateKeyPwd&#123; //判断encryptString参数是否正确 if ((encryptString == nil) || (encryptString == NULL)) &#123; return nil; &#125; else if (![encryptString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([encryptString length] &lt;= 0) &#123; return nil; &#125; //判断publicKeyPath参数是否正确 if ((privateKeyPath == nil) || (privateKeyPath == NULL)) &#123; return nil; &#125; else if (![privateKeyPath isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKeyPath length] &lt;= 0) &#123; return nil; &#125; //判断密码是否存在 NSString *keyPassword = [NSString stringWithFormat:@\"%@\",privateKeyPwd]; if ((privateKeyPwd == nil) || (privateKeyPwd == NULL)) &#123; keyPassword = @\"\"; &#125; else if (![privateKeyPwd isKindOfClass:[NSString class]]) &#123; keyPassword = @\"\"; &#125; else if ([privateKeyPwd length] &lt;= 0) &#123; keyPassword = @\"\"; &#125; //获取私钥对象和需要加密的字符串内容编码数据流 NSData *encryptData = nil, *decryptData = nil; SecKeyRef privateKeyRef = [self getPrivateKeyRefWithFilePath:privateKeyPath keyPassword:privateKeyPwd]; encryptData = [[self class] base64DecodeDataWithString:encryptString]; if ([[self class] isEmptyKeyRef:(__bridge id)(privateKeyRef)]) &#123; return nil; &#125; if ((encryptData == nil) || (encryptData == NULL)) &#123; return nil; &#125; else if (![encryptData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([encryptData length] &lt;= 0) &#123; return nil; &#125; NSStringEncoding encoding = NSUTF8StringEncoding; decryptData = [self decryptData:encryptData withKeyRef:privateKeyRef]; return [[NSString alloc] initWithData:decryptData encoding:encoding];&#125;#pragma mark - RSA Key String Encrypt/Decrypt Public Method+ (NSData *)encryptData:(NSData *)originData publicKey:(NSString *)publicKey&#123; //判断originData参数是否正确 if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; //判断publicKeyPath参数是否正确 if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //获取需要加密的字符串内容编码数据流 SecKeyRef publicKeyRef = [self publicKeyRefWithPublicKey:publicKey]; if([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)])&#123; return nil; &#125; return [self encryptData:originData withKeyRef:publicKeyRef];&#125;+ (NSString *)encryptString:(NSString *)originString publicKey:(NSString *)publicKey&#123; //判断publicKey参数是否正确 if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //判断originString参数是否正确 if ((originString == nil) || (originString == NULL)) &#123; return nil; &#125; else if (![originString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([originString length] &lt;= 0) &#123; return nil; &#125; //获取需要加密的字符串内容编码数据流 NSData *originData = nil, *encryptData = nil; SecKeyRef publicKeyRef = [self publicKeyRefWithPublicKey:publicKey]; originData = [originString dataUsingEncoding:NSUTF8StringEncoding]; if([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)])&#123; return nil; &#125; if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; encryptData = [self encryptData:originData withKeyRef:publicKeyRef]; return [[self class] base64EncodedStringWithData:encryptData];&#125;+ (NSString *)decryptString:(NSString *)encryptString privateKey:(NSString *)privateKey&#123; //判断publicKey参数是否正确 if ((privateKey == nil) || (privateKey == NULL)) &#123; return nil; &#125; else if (![privateKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKey length] &lt;= 0) &#123; return nil; &#125; //判断originString参数是否正确 if ((encryptString == nil) || (encryptString == NULL)) &#123; return nil; &#125; else if (![encryptString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([encryptString length] &lt;= 0) &#123; return nil; &#125; //获取私钥对象和需要加密的字符串内容编码数据流 SecKeyRef privateKeyRef; NSData *encryptData = nil, *decryptData = nil; privateKeyRef = [[self class] privateKeyRefWithPrivateKey:privateKey]; encryptData = [[self class] base64DecodeDataWithString:encryptString]; if ([[self class] isEmptyKeyRef:(__bridge id)(privateKeyRef)]) &#123; return nil; &#125; if ((encryptData == nil) || (encryptData == NULL)) &#123; return nil; &#125; else if (![encryptData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([encryptData length] &lt;= 0) &#123; return nil; &#125; NSStringEncoding encoding = NSUTF8StringEncoding; decryptData = [self decryptData:encryptData withKeyRef:privateKeyRef]; return [[NSString alloc] initWithData:decryptData encoding:encoding];&#125;/******************************************************************************/ 在iOS中RSA加解密使用方法介绍（RSA密钥格式请使用PKCS#8格式） 12345678910//使用RSA执行加密操作NSString *string4 = @\"abcdefghijklmnopqrstuvwxyz\";NSString *encodeString4 = [RSAEncrypt encryptString:string4 publicKey:mPublicKey];NSLog(@\"encodeString4 : %@\", encodeString4);//使用RSA执行解密操作NSString *decodeString4 = [RSAEncrypt decryptString:encodeString4 privateKey:mPrivateKey];NSLog(@\"decodeString4 : %@\", decodeString4);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"Encryption","slug":"Encryption","permalink":"https://nixzhang5.github.io/tags/Encryption/"}]},{"title":"AFNetWorking原理(二) AFSecurityPolicy","slug":"AFNetWorking原理二","date":"2019-06-25T03:31:07.000Z","updated":"2019-06-25T10:49:12.251Z","comments":true,"path":"AFNetWorking原理二.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorking原理二.html","excerpt":"AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。","text":"AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。 AFSecurityPolicy 的校验选项 AFSSLPinningMode 有三种： AFSSLPinningModeNone 在与服务器建立安全连接时，并不会使用应用中已有的证书（也可能本就没有）对服务器传递的信息进行校验，此为默认选项 AFSSLPinningModePublicKey 使用应用中已有的公钥对服务器传递的信息进行校验 AFSSLPinningModeCertificate 使用应用中已有的数字证书对服务器传递的信息进行校验 HTPPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。 HTTPS连接建立 非对称加密、对称加密：客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有（各个受信任的证书机构）根证书，用这些根证书对服务端返回的证书进行验证，经验证如果证书（服务端返回的证书）是可信任的，就生成一个pre-master secret，用这个证书（服务端返回的证书）的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master secret，客户端也同样根据这种算法从pre-master secret生成master secret（非对称加密），随后双方的通信都用这个master secret对传输数据进行加密解密（对称加密）。 非对称加密： d(c(x))=x HTTP和HTTPS区别超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下四点： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 SSLSSL(Secure Sockets Layer安全套接层),及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL (Secure Socket Layer)为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。 SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。 SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 SSL协议提供的服务主要有哪些 认证用户和服务器，确保数据发送到正确的客户机和服务器 加密数据以防止数据中途被窃取 维护数据的完整性，确保数据在传输过程中不被改变。 SSL协议的工作流程 服务器认证阶段：客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 从SSL 协议所提供的服务及其工作流程可以看出，SSL协议运行的基础是商家对消费者信息保密的承诺，这就有利于商家而不利于消费者。在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。但随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的单一认证问题就越来越突出。虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务器双方的身份验证，但是SSL协议仍存在一些问题，比如，只能提供交易中客户与服务器间的双方认证，在涉及多方的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。在这种情况下，Visa和MasterCard两大信用卡公组织制定了SET协议，为网上信用卡支付提供了全球性的标准。 SSL协议加密方式SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。 对称加密速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 SSL证书包含的信息 证书版本号，不同版本的证书格式不同 Serial Number 序列号，同一身份验证机构签发的证书序列号唯一 Algorithm Identifier 签名算法，包括必要的参数Issuer 身份验证机构的标识信息 Period of Validity 有效期 Subject 证书持有人的标识信息 Subject’s Public Key 证书持有人的公钥 Signature 身份验证机构对证书的签名 证书的格式 认证中心所发放的证书均遵循X.509 V3 标准，其基本格式如下： 证书版本号（Certificate Format Version）含义：用来指定证书格式采用的X.509 版本号。 证书序列号（Certificate Serial Number）含义：用来指定证书的唯一序列号，以标识CA 发出的所有公钥证书。 签名（Signature）算法标识（Algorithm Identifier）含义：用来指定 CA 签发证书所用的签名算法。 签发此证书的 CA 名称（Issuer ）含义：用来指定签发证书的 CA 的X.500 唯一名称（DN，Distinguished Name）。 证书有效期（Validity Period）起始日期（notBefore） 终止日期（notAfter）含义：用来指定证书起始日期和终止日期。 用户名称（Subject）含义：用来指定证书用户的X.500 唯一名称（DN，Distinguished Name）。 用户公钥信息（Subject Public Key Information）算法（algorithm） 算法标识（Algorithm Identifier）用户公钥（subject Public Key）含义：用来标识公钥使用的算法，并包含公钥本身。 证书扩充部分（扩展域）（Extensions）含义：用来指定额外信息。 X.509 V3 证书的扩充部分（扩展域）及实现方法如下： CA 的公钥标识（Authority Key Identifier） 公钥标识（SET 未使用）（Key Identifier） 签发证书者证书的签发者的甄别名（Certificate Issuer） 签发证书者证书的序列号（Certificate Serial Number） X.509 V3 证书的扩充部分（扩展域）及实现CA 的公钥标识（Authority Key Identifier） 公钥标识（SET 未使用）（Key Identifier） 签发证书者证书的签发者的甄别名（Certificat签发证书者证书的序列号（Certificate Serial Number）含义：CA 签名证书所用的密钥对的唯一标识用户的公钥标识（Subject Key Identifier）含义：用来标识与证书中公钥相关的特定密钥进行解密。 证书中的公钥用途（Key Usage）含义：用来指定公钥用途。 用户的私钥有效期（Private Key Usage Period）起始日期（Note Before） 终止日期（Note After）含义：用来指定用户签名私钥的起始日期和终止日期。 CA 承认的证书政策列表（Certificate Policies）含义：用来指定用户证书所适用的政策，证书政策可由对象标识符表示。 用户的代用名（Substitutional Name）含义：用来指定用户的代用名。 CA 的代用名（Issuer Alt Name）含义：用来指定 CA 的代用名。 基本制约（Basic Constraints）含义：用来表明证书用户是最终用户还是CA。 在SET 系统中有一些私有扩充部分（扩展域）Hashed Root Key 含义：只在根证书中使用，用于证书更新时进行回溯。 证书类型（Certificate Type）含义：用来区别不同的实体。该项是必选的。 商户数据（Merchant Data）含义：包含支付网关需要的所有商户信息。 持卡人证书需求（Card Cert Required）含义：显示支付网关是否支持与没有证书的持卡人进行交易。 SET 扩展（SETExtensions）含义：列出支付网关支持的支付命令的 SET 信息扩展。 CRL 数据定义版本（Version）含义：显示 CRL 的版本号。 CRL 的签发者（Issuer）含义：指明签发 CRL 的CA 的甄别名。 CRL 发布时间（this Update）预计下一个 CRL 更新时间（Next Update）撤销证书信息目录（Revoked Certificates）CRL 扩展（CRL Extension）CA 的公钥标识（Authority Key Identifier）CRL 号（CRL Number） SSL证书种类：CFCA，GlobalSign，VeriSign ，Geotrust ，Thawte。 域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站； 企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高； 增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。 握手过程为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下： 客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。 服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 HTTPS的认证过程单向认证Https在建立Socket连接之前，需要进行握手，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 服务器将选择好的加密方案通过明文方式返回给客户端 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 验证客户端的证书，通过验证后，会获得客户端的公钥 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 AFSecurityPolicy和认证认证过程和原理AFN是靠着AFSecurityPolicy这个类保证数据安全的，调用下面方法用来验证是否信任服务器。 1[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host] 看一下AFN中的接口 123456789101112131415161718192021/*! @typedef SecTrustRef @abstract CFType used for performing X.509 certificate trust evaluations. // 执行X.509证书信任评估，其实就是一个容器，装了服务器端需要验证的证书的基本信息、 公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书， 这个客户端的证书，可以用来和服务端的证书去匹配验证的 */typedef struct CF_BRIDGED_TYPE(id) __SecTrust *SecTrustRef;/** Whether or not the specified server trust should be accepted, based on the security policy. This method should be used when responding to an authentication challenge from a server. @param serverTrust The X.509 certificate trust of the server. @param domain The domain of serverTrust. If `nil`, the domain will not be validated. // 服务器域名 @return Whether or not to trust the server. */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain; 根据安全策略是否接受指定的服务器信任。 响应来自服务器的身份验证质询时应使用此方法。 大家还记得这个代理方法吗？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; //挑战处理类型为 默认 /* NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理 NSURLSessionAuthChallengeUseCredential：使用指定的证书 NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战 */ NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; // sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战 if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; // 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust // 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。 // 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象 if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; // 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战 if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; // 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书） credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; // 确定挑战的方式 if (credential) &#123; //证书挑战 设计policy,none，则跑到这里 disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; //取消挑战 disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; //默认挑战方式 disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; //完成挑战 if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; 这个方法是如何进行接受挑战的 首先指定了HTTPS为默认的认证方式。 判断有没有自定义Block:sessionDidReceiveAuthenticationChallenge，有的话，使用我们自定义Block,生成一个认证方式，并且可以给credential赋值，即我们需要接受认证的证书。然后直接调用completionHandler，去根据这两个参数，执行系统的认证。 如果没有自定义Block，我们判断如果服务端的认证方法要求是NSURLAuthenticationMethodServerTrust，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现） 接着我们就执行了AFSecurityPolicy相关的上面的方法- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain，关于这个方法，AF默认的处理是，如果这行返回NO、说明AF内部认证失败，则取消HTTPS认证，即取消请求。返回YES则进入if块，用服务器返回的一个serverTrust去生成了一个认证证书。（注：这个serverTrust是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。最后调用completionHandler传递认证方式和要认证的证书，去做系统根证书验证。也可以这么理解：这里securityPolicy存在的作用就是，使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。如果通不过，则直接越过系统的验证，取消HTTPS的网络请求。否则，继续去走系统根证书的验证。 AFSecurityPolicy实例化先看一下该类的实例化 12345678AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125; 这里有一个很重要的属性就是SSLPinningMode，先看一下这个枚举 12345typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, //不验证 AFSSLPinningModePublicKey, //只验证公钥 AFSSLPinningModeCertificate, // 验证证书&#125;; 下面我们看一下类AFSecurityPolicy的几个属性 123456789101112131415161718192021222324252627/** The criteria by which server trust should be evaluated against the pinned SSL certificates. Defaults to `AFSSLPinningModeNone`. */// 验证模式 这个枚举值上面讲述过@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;/** The certificates used to evaluate server trust according to the SSL pinning mode. By default, this property is set to any (`.cer`) certificates included in the target compiling AFNetworking. Note that if you are using AFNetworking as embedded framework, no certificates will be pinned by default. Use `certificatesInBundle` to load certificates from your target, and then create a new policy by calling `policyWithPinningMode:withPinnedCertificates`. Note that if pinning is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches. */// 可以去匹配服务端证书验证的证书@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;/** Whether or not to trust servers with an invalid or expired SSL certificates. Defaults to `NO`. */// 是否支持非法的证书（例如自签名证书）@property (nonatomic, assign) BOOL allowInvalidCertificates;/** Whether or not to validate the domain name in the certificate's CN field. Defaults to `YES`. */// 是否去验证证书域名是否匹配@property (nonatomic, assign) BOOL validatesDomainName; AFNetWorking HTTPS请求示例自签名证书我们手动指定securityPolicy认证属性。通过12306证书来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//自建证书认证- (IBAction)buttion1:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://kyfw.12306.cn/otn/leftTicket/init\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // [request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定安全策略 manager.securityPolicy = [self ticketSecurityPolicy]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/** 12306的认证证书，他的认证证书是自签名的 @return 返回指定的认证策略 */-(AFSecurityPolicy*)ticketSecurityPolicy &#123; // /先导入证书 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"12306\" ofType:@\"cer\"];//证书的路径 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; &#125; // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO // 如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = YES; //validatesDomainName 是否需要验证域名，默认为YES； //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。 //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。 //如置为NO，建议自己添加对应域名的校验逻辑。 securityPolicy.validatesDomainName = NO; return securityPolicy;&#125; SSL信任证书我们手动指定securityPolicy认证属性。通过百度证书来实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//认证证书认证- (IBAction)button2:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.baidu.com\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //[request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定安全策略 manager.securityPolicy = [self baiduSecurityPolicy]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/**百度的的认证证书，他的认证证书是花钱买的，也就是不是自签名的证书。这种证书，如果我们要手动指定，pinmode只能是`AFSSLPinningModeNone` @return 返回指定的认证策略 */-(AFSecurityPolicy*)baiduSecurityPolicy &#123; // /先导入证书 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"baidu\" ofType:@\"cer\"];//证书的路径 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; //这里只能用AFSSLPinningModeNone才能成功，而且我系统的证书列表里面已经有百度的证书了 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone]; &#125; // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO // 如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = NO; //validatesDomainName 是否需要验证域名，默认为YES； //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。 //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。 //如置为NO，建议自己添加对应域名的校验逻辑。 securityPolicy.validatesDomainName = YES; return securityPolicy;&#125; SSL证书AFN默认处理这里我们不做任何额外的处理，直接使用AFN的默认证书处理机制。通过AFURLSessionManager的securityPolicy默认实现。它会和存在系统中的做对比来验证证书。 1234567891011121314//系统证书认证- (IBAction)button3:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.apple.com/\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125; AFSecurityPolicy源码解析AFSecurityPolicy分三种验证模式 AFSSLPinningModeNone:这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。 AFSSLPinningModeCertificate:这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。这里还没弄明白第一步的验证是怎么进行的，代码上跟去系统信任机构列表里验证一样调用了SecTrustEvaluate，只是这里的列表换成了客户端保存的那些证书列表。若要验证这个，是否应该把服务端证书的颁发机构根证书也放到客户端里？ AFSSLPinningModePublicKey:这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。 SecTrustRef这是一个需要验证的信任对象,包含待验证的证书和支持的验证方法等。 SecTrustResultType表示验证结果。其中 kSecTrustResultProceed表示serverTrust验证成功，且该验证得到了用户认可(例如在弹出的是否信任的alert框中选择always trust)。 kSecTrustResultUnspecified表示 serverTrust验证成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书。 两者取其一就可以认为对serverTrust验证成功。 SecTrustEvaluate证书校验函数,在函数的内部递归地从叶节点证书到根证书验证。需要验证证书本身的合法性（验证签名完整性，验证证书有效期等);验证证书颁发者的合法性（查找颁发者的证书并检查其合法性，这个过程是递归的).而递归的终止条件是证书验证过程中遇到了锚点证书(锚点证书:嵌入到操作系统中的根证书,这个根证书是权威证书颁发机构颁发的自签名证书)。 AFSecurityPolicy的源码细节如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383/** 证书的验证类型 - AFSSLPinningModeNone: 不使用`pinned certificates`来验证证书 - AFSSLPinningModePublicKey: 使用`pinned certificates`来验证证书的公钥 - AFSSLPinningModeCertificate: 使用`pinned certificates`来验证整个证书 */typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate,&#125;;/** 获取指定证书的公钥 @param certificate 证书数据 @return 公钥 */static id AFPublicKeyForCertificate(NSData *certificate) &#123; id allowedPublicKey = nil; SecCertificateRef allowedCertificate; SecPolicyRef policy = nil; SecTrustRef allowedTrust = nil; SecTrustResultType result; //获取证书对象 allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate); __Require_Quiet(allowedCertificate != NULL, _out); //获取X.509的认证策略 policy = SecPolicyCreateBasicX509(); //获取allowedTrust对象的值 __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _out); __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out); //根据allowedTrust获取对应的公钥 allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);//C++的gumpto跳转，当前面的操作出错以后，直接跳入_out执行_out: if (allowedTrust) &#123; CFRelease(allowedTrust); &#125; if (policy) &#123; CFRelease(policy); &#125; if (allowedCertificate) &#123; CFRelease(allowedCertificate); &#125; //返回公钥 return allowedPublicKey;&#125;/** 在指定的证书和认证策略下，验证SecTrustRef对象是否是受信任的、合法的。 @param serverTrust SecTrustRef对象 @return 结果 */static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; //获取serverTrust的认证结果，调用`SecTrustEvaluate`表示通过系统的证书来比较认证 __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125;/** 根据`serverTrust`获取认证的证书链 @param serverTrust serverTrust对象 @return 认证证书链 */static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //获取认证链的总层次 CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; //获取每一级认证链，把获取的证书数据存入数组中 for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)]; &#125; //返回证书链数组 return [NSArray arrayWithArray:trustChain];&#125;/** 获取serverTrust对象的认证链的公钥数组 @param serverTrust serverTrust对象 @return 公钥数组 */static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //X.509标准的安全策略 SecPolicyRef policy = SecPolicyCreateBasicX509(); //获取证书链的证书数量 CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); SecCertificateRef someCertificates[] = &#123;certificate&#125;; CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL); SecTrustRef trust; //通过一个证书、认证策略新建一个SecTrustRef对象 __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _out); SecTrustResultType result; //验证SecTrustRef对象是否成功 __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _out); //把SecTrustRef对应的公钥加入数组中 [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)]; _out: if (trust) &#123; CFRelease(trust); &#125; if (certificates) &#123; CFRelease(certificates); &#125; continue; &#125; CFRelease(policy); return [NSArray arrayWithArray:trustChain];&#125;#pragma mark -@interface AFSecurityPolicy()//认证策略@property (readwrite, nonatomic, assign) AFSSLPinningMode SSLPinningMode;//公钥集合@property (readwrite, nonatomic, strong) NSSet *pinnedPublicKeys;@end@implementation AFSecurityPolicy/** 从MainBundle中获取所有证书 @param bundle 返回包含在bundle中的证书集合。如果AFNetworking使用的是静态库，我们必须通过这个方法来加载证书。并且通过`policyWithPinningMode:withPinnedCertificates`方法来指定认证类型。 @return 返回bundle里面的证书 */+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123; //获取项目里的所有.cer证书 NSArray *paths = [bundle pathsForResourcesOfType:@\"cer\" inDirectory:@\".\"]; NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]]; for (NSString *path in paths) &#123; //获取证书对应的NSData，并且加入集合中 NSData *certificateData = [NSData dataWithContentsOfFile:path]; [certificates addObject:certificateData]; &#125; //返回证书集合 return [NSSet setWithSet:certificates];&#125;/** 返回当前类所在bundle所在的证书集合 @return 证书集合 */+ (NSSet *)defaultPinnedCertificates &#123; static NSSet *_defaultPinnedCertificates = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //获取当前类所在bundle NSBundle *bundle = [NSBundle bundleForClass:[self class]]; _defaultPinnedCertificates = [self certificatesInBundle:bundle]; &#125;); return _defaultPinnedCertificates;&#125;/** 返回默认的安全认证策略,在这里是验证系统的证书。这个策略不允许非法证书、验证主机名、不验证证书内容和公钥 @return 返回认证策略 */+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125;/** 根据指定的认证策略和默认的证书列表初始化一个`AFSecurityPolicy`对象 @param pinningMode 认证策略 @return `AFSecurityPolicy`对象 */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123; return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];&#125;/** 通过制定的认证策略`pinningMode`和证书集合`pinnedCertificates`来初始化一个`AFSecurityPolicy`对象 @param pinningMode 认证模型 @param pinnedCertificates 证书集合 @return AFSecurityPolicy对象 */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = pinningMode; //设置`_pinnedCertificates`和`pinnedPublicKeys`属性，分别对应证书集合和公钥集合 [securityPolicy setPinnedCertificates:pinnedCertificates]; //返回初始化成功的`AFSecurityPolicy` return securityPolicy;&#125;- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; //默认是要认证主机名称 self.validatesDomainName = YES; return self;&#125;/**通过指定的证书结合获取到对应的公钥集合。然后赋值给`pinnedPublicKeys`属性 @param pinnedCertificates 证书集合 */- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123; _pinnedCertificates = pinnedCertificates; if (self.pinnedCertificates) &#123; NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]]; //迭代每一个证书 for (NSData *certificate in self.pinnedCertificates) &#123; //获取证书对应的公钥 id publicKey = AFPublicKeyForCertificate(certificate); if (!publicKey) &#123; continue; &#125; [mutablePinnedPublicKeys addObject:publicKey]; &#125; //赋值给对应的属性 self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys]; &#125; else &#123; self.pinnedPublicKeys = nil; &#125;&#125;#pragma mark -/** 为serverTrust对象指定认证策略，如果domain不为nil,则包括对主机名的认证。这个方法必须在接受到`authentication challenge`返回的时候调用。 SecTrustRef可以理解为桥接证书与认证策略的对象，他关联指定的证书与认证策略 @param serverTrust 服务器的X.509标准的证书数据 @param domain 认证服务器的主机名。如果是nil,则不会对主机名进行认证。 @return serverTrust是否通过认证 */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // \"Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors.\" NSLog(@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\"); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; //使用需要认证主机名的认证策略 [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; //使用默认的认证策略 [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; //给serverTrust对象指定认证策略 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; return NO; &#125; //根据证书验证策略、数字签名认证策略、其他认证策略来处理不同情况 switch (self.SSLPinningMode) &#123; case AFSSLPinningModeNone://不验证公钥和证书 default: return NO; case AFSSLPinningModeCertificate: &#123;//验证整个证书 NSMutableArray *pinnedCertificates = [NSMutableArray array]; //根据指定证书获取，获取对应的证书对象 for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; //把证书与serverTrust关联起来 SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA) //获取serverTrust证书链。直到根证书。 NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); //如果`pinnedCertificates`包含`serverTrust`对象对应的证书链的根证书。则返回true for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; return YES; &#125; &#125; return NO; &#125; case AFSSLPinningModePublicKey: &#123;//只验证证书里面的数字签名 NSUInteger trustedPublicKeyCount = 0; //根据serverTrust对象和SecPolicyCreateBasicX509认证策略，获取对应的公钥集合 NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); for (id trustChainPublicKey in publicKeys) &#123; //把获取的公钥和系统获取的默认公钥比较，如果相等，则通过认证 for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125;#pragma mark - NSKeyValueObserving+ (NSSet *)keyPathsForValuesAffectingPinnedPublicKeys &#123; return [NSSet setWithObject:@\"pinnedCertificates\"];&#125;#pragma mark - NSSecureCoding+ (BOOL)supportsSecureCoding &#123; return YES;&#125;- (instancetype)initWithCoder:(NSCoder *)decoder &#123; self = [self init]; if (!self) &#123; return nil; &#125; self.SSLPinningMode = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(SSLPinningMode))] unsignedIntegerValue]; self.allowInvalidCertificates = [decoder decodeBoolForKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; self.validatesDomainName = [decoder decodeBoolForKey:NSStringFromSelector(@selector(validatesDomainName))]; self.pinnedCertificates = [decoder decodeObjectOfClass:[NSArray class] forKey:NSStringFromSelector(@selector(pinnedCertificates))]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder &#123; [coder encodeObject:[NSNumber numberWithUnsignedInteger:self.SSLPinningMode] forKey:NSStringFromSelector(@selector(SSLPinningMode))]; [coder encodeBool:self.allowInvalidCertificates forKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; [coder encodeBool:self.validatesDomainName forKey:NSStringFromSelector(@selector(validatesDomainName))]; [coder encodeObject:self.pinnedCertificates forKey:NSStringFromSelector(@selector(pinnedCertificates))];&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFSecurityPolicy *securityPolicy = [[[self class] allocWithZone:zone] init]; securityPolicy.SSLPinningMode = self.SSLPinningMode; securityPolicy.allowInvalidCertificates = self.allowInvalidCertificates; securityPolicy.validatesDomainName = self.validatesDomainName; securityPolicy.pinnedCertificates = [self.pinnedCertificates copyWithZone:zone]; return securityPolicy;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"https://nixzhang5.github.io/tags/AFNetWorking原理/"},{"name":"Encryption","slug":"Encryption","permalink":"https://nixzhang5.github.io/tags/Encryption/"}]},{"title":"AFNetWorking原理(一) AFURLSessionManager解读","slug":"AFNetWorking原理","date":"2019-06-21T07:48:30.000Z","updated":"2019-06-25T03:19:09.896Z","comments":true,"path":"AFNetWorking原理.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorking原理.html","excerpt":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。","text":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。 AFNetworking由5个模块组成 NSURLSession：网络通信模块（核心模块） AFURLSessionManager 对NSURLSession的封装 AFHTTPSessionManager 是继承于 AFURLSessionmanager Security：网络通讯安全策略模块 AFSecurityPolicy Reachability：网络状态监听模块 AFNetworkReachabilityManager Seriaalization：网络通信信息序列化、反序列化模块 AFHTTPRequestSerializer AFURLResponseSerialization UIKit：对于iOS UIKit的扩展库 网络请求类 AFURLSessionManager声明.h文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226// AFURLSessionManager类实现了NSURLSession相关的众多协议，用于帮助我们进行数据的处理@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;// NSURLSession 作为一个实例变量，AFN发起的网络请求都是通过该session创建的task实现的@property (readonly, nonatomic, strong) NSURLSession *session;// NSURLSession delegate方法执行队列@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;// 响应序列化 不能为nil@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;// 安全策略，用于https等需要验证的地方@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;#if !TARGET_OS_WATCH（生成的代码将在Apple Watch操作系统下运行）///--------------------------------------/// @name Monitoring Network Reachability///--------------------------------------// 监测网络连通性，使用AFNetworkReachabilityManager@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;#endif///----------------------------/// @name Getting Session Tasks///----------------------------// session管理的data upload download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;// session管理的data task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;// session管理的upload task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;// session管理的download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;///-------------------------------/// @name Managing Callback Queues///-------------------------------// 完成网络请求后执行回调块的队列，如果为nil则使用主队列@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;// 完成网络请求后回调块的@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;///---------------------------------/// @name Working Around System Bugs///---------------------------------// background类型的session是否尝试重新创建上传任务@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;///---------------------/// @name Initialization///---------------------// 初始化函数，根据指定NSURLSessionConfiguration创建session- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;// 设置session无效，cancelPendingTasks标识是否取消session中正在执行的任务// 内部还是调用NSURLSession的invalidate方法- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;///-------------------------/// @name Running Data Tasks///-------------------------// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler DEPRECATED_ATTRIBUTE;// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///---------------------------/// @name Running Upload Tasks///---------------------------// 根据指定request fileURL等参数构造一个NSURLSessionUploadTask任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 根据指定request和data等参数构造一个上传任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 创建一个具有特定数据流的NSURLSessionUploadTask请求，上传的body使用的是request.HTTPBodyStream- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///-----------------------------/// @name Running Download Tasks///-----------------------------// 构造下载任务- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;/*构造下载任务 断点续传根据未下载完成的数据，创建一个NSURLSessionDownloadTask对象。resumeData：未完成的下载数据destination：决定下载文件的存放路径的block。block中有两个参数，目标路径和服务器的响应。同时返回文件下载的URLcompletionHandler：当任务完成后completionHandler的block会被调用progress：下载进度block。每当下载进度更新时就会执行这个block*/- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;///---------------------------------/// @name Getting Progress for Tasks///---------------------------------// 根据NSURLSessionTask获取对应的任务完成进度NSProgress- (nullable NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task;// 根据NSURLSessionTask获取对应下载任务的进度NSProgress- (nullable NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task;///-----------------------------------------/// @name Setting Session Delegate Callbacks///-----------------------------------------// 设置session无效时执行的回调块- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;// 设置session收到challenge时执行的回调块- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;///--------------------------------------/// @name Setting Task Delegate Callbacks///--------------------------------------// 设置session需要新的流时执行的回调块- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;// 设置session的任务需要执行重定向时执行的回调块- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * _Nullable (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;// 设置Block用于当一个session的task接收到证书验证时调用。实际上依赖由NSURLSessionTaskDelegate 的 URLSession:task:didReceiveChallenge:completionHandler:.方法处理- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;// 设置Block每隔一段时间调用用来跟踪上传进度，实际上依赖由NSURLSessionTaskDelegate的 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法实现- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;// 设置一个当task完成时调用的Block- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;///-------------------------------------------/// @name Setting Data Task Delegate Callbacks///-------------------------------------------// 设置一个当DataTask请求接收到响应时调用的block。交由NSURLSessionDataDelegate的URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;// 设置当一个dataTask转变成downloadTak时调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didBecomeDownloadTask:.方法处理- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;// 设置当一个dataTask接受到数据时就调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;// 设置当一个dataTask对请求结果的缓冲时的block。交由NSURLSessionDataDelegate 的 URLSession:dataTask:willCacheResponse:completionHandler:.方法处理- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;// 设置当session中所有消息都被发送时，调用的block。交由NSURLSessionDataDelegate的URLSessionDidFinishEventsForBackgroundURLSession：方法实现- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block AF_API_UNAVAILABLE(macos);///-----------------------------------------------/// @name Setting Download Task Delegate Callbacks///-----------------------------------------------// 设置一个当下载任务完成一个下载时调用的block。最终交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didFinishDownloadingToURL:.方法处理- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;// 设置每次追踪下载进度时调用的block，最终交由NSURLSessionDownloadDelegate的URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite：方法处理- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;// 设置一个block，当任务重新下载时调用。交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:.方式- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;@end///--------------------/// @name Notifications///--------------------FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidSuspendNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDidInvalidateNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseDataKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteAssetPathKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteErrorKey;NS_ASSUME_NONNULL_END 通过头文件可以发现，AFURLSessionManager是封装了NSURLSession并实现了其相关的所有协议，提供了一系列方法用于构造各种网络请求任务，并提供回调块进行处理，还提供了一系列设置代理方法执行时的执行回调块的方法，这样，我们也可以监听整个网络请求的过程，当然也可以忽略这些代理方法执行情况，提供了各种通知，通过头文件可以看出，主要目的还是为了封装NSURLSession从而提供更加便捷的方法来实现网络请求。 实现.m文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef NSFoundationVersionNumber_iOS_8_0#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11#else#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0#endif//C静态函数，GCD只执行一次，用于创建一个串行队列来执行各种网络请求任务的创建工作static dispatch_queue_t url_session_manager_creation_queue() &#123; static dispatch_queue_t af_url_session_manager_creation_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_creation_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.creation\", DISPATCH_QUEUE_SERIAL); &#125;); return af_url_session_manager_creation_queue;&#125;/*C静态函数，用于执行创建网络请求任务的block主要目的是为了解决ios8以下存在的一个block和task不匹配的bug上面那个队列也是为了解决这个bug才创建的具体可查看Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093*/static void url_session_manager_create_task_safely(dispatch_block_t block) &#123; if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123; dispatch_sync(url_session_manager_creation_queue(), block); &#125; else &#123; block(); &#125;&#125;//C静态函数，创建一个并发队列，用于在网络请求任务完成后处理数据的，并发队列实现多线程处理多个请求完成后的数据处理static dispatch_queue_t url_session_manager_processing_queue() &#123; static dispatch_queue_t af_url_session_manager_processing_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_processing_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.processing\", DISPATCH_QUEUE_CONCURRENT); &#125;); return af_url_session_manager_processing_queue;&#125;//C静态函数创建一个dispatch的组//但在接下来的源码中并没有使用这个组来实现notify等功能，仅仅是将block和组关联了，不太清楚具体用意//有明白的读者还请不吝赐教static dispatch_group_t url_session_manager_completion_group() &#123; static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_completion_group = dispatch_group_create(); &#125;); return af_url_session_manager_completion_group;&#125;//一系列通知名称的定义NSString * const AFNetworkingTaskDidResumeNotification = @\"com.alamofire.networking.task.resume\";NSString * const AFNetworkingTaskDidCompleteNotification = @\"com.alamofire.networking.task.complete\";NSString * const AFNetworkingTaskDidSuspendNotification = @\"com.alamofire.networking.task.suspend\";NSString * const AFURLSessionDidInvalidateNotification = @\"com.alamofire.networking.session.invalidate\";NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification = @\"com.alamofire.networking.session.download.file-manager-error\";NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey = @\"com.alamofire.networking.task.complete.serializedresponse\";NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey = @\"com.alamofire.networking.task.complete.responseserializer\";NSString * const AFNetworkingTaskDidCompleteResponseDataKey = @\"com.alamofire.networking.complete.finish.responsedata\";NSString * const AFNetworkingTaskDidCompleteErrorKey = @\"com.alamofire.networking.task.complete.error\";NSString * const AFNetworkingTaskDidCompleteAssetPathKey = @\"com.alamofire.networking.task.complete.assetpath\";//需要使用的NSLock锁的名称static NSString * const AFURLSessionManagerLockName = @\"com.alamofire.networking.session.manager.lock\";//background session重试创建上传任务次数static NSUInteger const AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = 3; 对于url_session_manager_create_task_safely这个有什么用？其实这个是被当做是一个在ios8以下，NSURLSessionDataTask出现的一个Bug。问题产生的原因就是当队列是并发的，这是当两个任务同时在不同的线程上创建任务的时候taskIdentifier可能是一样的。大致的意思就是当我们同时创建两个任务，返回了重复的taskIdentifier，这样的话第一个被创建的completionHandler就会被清空，被第二个任务的completionHandler给替换，如果第一个数据是早于第二个数据返回的，那么第一个数据返回之后就会去调用第二个任务的completionHandler。 12345678910111213141516171819202122typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session, NSError *error);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef NSURLRequest * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef void (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(NSURLSession *session);typedef NSInputStream * (^AFURLSessionTaskNeedNewBodyStreamBlock)(NSURLSession *session, NSURLSessionTask *task);typedef void (^AFURLSessionTaskDidSendBodyDataBlock)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);typedef void (^AFURLSessionTaskDidCompleteBlock)(NSURLSession *session, NSURLSessionTask *task, NSError *error);typedef NSURLSessionResponseDisposition (^AFURLSessionDataTaskDidReceiveResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response);typedef void (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask);typedef void (^AFURLSessionDataTaskDidReceiveDataBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data);typedef NSCachedURLResponse * (^AFURLSessionDataTaskWillCacheResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse);typedef NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);typedef void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);typedef void (^AFURLSessionDownloadTaskDidResumeBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);typedef void (^AFURLSessionTaskProgressBlock)(NSProgress *);typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response, id responseObject, NSError *error); 定义一些回调的block 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248//定义了一个类AFURLSessionManagerTaskDelegate并实现了NSURLSessionTask的相关协议//这个类是用于处理NSURLSessionTask相关代理方法的@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;//初始化构造函数，需要传入一个关联的task- (instancetype)initWithTask:(NSURLSessionTask *)task;//weak修饰的manager@property (nonatomic, weak) AFURLSessionManager *manager;//可变data用于存储获取到的网络数据@property (nonatomic, strong) NSMutableData *mutableData;//上传进度NSProgress@property (nonatomic, strong) NSProgress *uploadProgress;//下载进度NSProgress@property (nonatomic, strong) NSProgress *downloadProgress;//下载文件的NSURL@property (nonatomic, copy) NSURL *downloadFileURL;//下载完成的回调块@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;//上传进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;//下载进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;//网络请求完成的回调块@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;@end@implementation AFURLSessionManagerTaskDelegate//初始化构造函数- (instancetype)initWithTask:(NSURLSessionTask *)task &#123; self = [super init]; if (!self) &#123; return nil; &#125; _mutableData = [NSMutableData data]; _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; //遍历两个上传和下载NSProgress设置一些属性 __weak __typeof__(task) weakTask = task; for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ]) &#123; //初始化progress progress.totalUnitCount = NSURLSessionTransferSizeUnknown; progress.cancellable = YES; //设置取消进度的回调块，执行task的cancel方法 progress.cancellationHandler = ^&#123; [weakTask cancel]; &#125;; progress.pausable = YES; //设置暂停进度的回调块，执行task的suspend方法 progress.pausingHandler = ^&#123; [weakTask suspend]; &#125;; //设置重新开始的回调块，执行task的resume方法 if ([progress respondsToSelector:@selector(setResumingHandler:)]) &#123; progress.resumingHandler = ^&#123; [weakTask resume]; &#125;; &#125; //progress添加kvo，监听progress的进度fractionCompleted [progress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; &#125; return self;&#125;//析构函数- (void)dealloc &#123; //删除KVO [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];&#125;#pragma mark - NSProgress Tracking//KVO回调方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; //上次或下载进度有改变时，执行上传或下载进度回调块 if ([object isEqual:self.downloadProgress]) &#123; if (self.downloadProgressBlock) &#123; self.downloadProgressBlock(object); &#125; &#125; else if ([object isEqual:self.uploadProgress]) &#123; if (self.uploadProgressBlock) &#123; self.uploadProgressBlock(object); &#125; &#125;&#125;#pragma mark - NSURLSessionTaskDelegate//代理方法，网络请求完成或出错- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //manager用weak修饰，这里strong一下防止manager被释放 __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; //为userInfo字典设置响应序列化 userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 //赋值mutableData到data中，并释放mutableData NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; &#125; //如果downloadFileURL存在，即是下载任务就设置下载完成后的文件存储url到字典中 if (self.downloadFileURL) &#123; userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; &#125; else if (data) &#123; //否则就设置对应的NSData数据到字典中 userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; &#125; //如果网络请求有错误 if (error) &#123; //设置error信息到字典中 userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; /* 这个三目运算符需要解释一下，在其他语言中这么写很可能就是语法错误 这里的意思就是如果manager.completionGroup存在就使用它 不存在就使用url_session_manager_completion_group函数返回的group 后面的三目运算符同理 所以如果自己不设置manager的completionGroup或completionQueue就会使用默认提供的 */ //执行对应的completionHandler回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, error); &#125; //在主队列即主线程中发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125; else &#123; //如果网络任务成功完成，异步在并发队列中执行数据处理 dispatch_async(url_session_manager_processing_queue(), ^&#123; //序列化响应数据 NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; //如果是下载任务设置响应数据为文件的url if (self.downloadFileURL) &#123; responseObject = self.downloadFileURL; &#125; //如果响应对象序列化成功或是文件url就设置相关字典key-value if (responseObject) &#123; userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; &#125; //如果序列化出错，设置相关字典值 if (serializationError) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; &#125; //同理，在dispatch组中和特定队列执行回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; //主线程发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); &#125;&#125;#pragma mark - NSURLSessionDataDelegate//回调方法，收到数据- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive; self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived; //添加数据到mutableData [self.mutableData appendData:data];&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //设置上传进度的相关属性 self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.uploadProgress.completedUnitCount = task.countOfBytesSent;&#125;#pragma mark - NSURLSessionDownloadDelegate//下载任务的回调方法//由于NSURLSession的downloadTask直接将文件下载到磁盘沙盒中，所以不需要mutableData自行接收数据- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = totalBytesExpectedToWrite; self.downloadProgress.completedUnitCount = totalBytesWritten;&#125;//恢复下载任务的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = expectedTotalBytes; self.downloadProgress.completedUnitCount = fileOffset;&#125;//下载任务下载文件完成后的回调方法//location就是文件下载到磁盘沙盒目录的NSURL- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //设置downloadFileURL为nil self.downloadFileURL = nil; //如果有下载完成的回调块 if (self.downloadTaskDidFinishDownloading) &#123; //执行该回调块，这个回调块返回一个下载的文件保存的路径URL //默认保存在沙盒tmp文件中，可能会被删除，需要持久化时要自己设置一个目录存储 self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果需要移动文件的路径使用NSFileManaegr移动 if (self.downloadFileURL) &#123; NSError *fileManagerError = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123; //文件移动发生错误发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; &#125; &#125; &#125;&#125;@end AFURLSessionManagerTaskDelegate的源码，主要就是关联一个NSURLSessionTask并实现了相关任务的代理方法用于数据的获取、上传文件和下载文件。需要注意的是NSURLSessionTask的delegate属性是只读的，只能在使用session创建task的函数中传入代理对象，而且通过源码也没有发现相关代理的设置，所以AFURLSessionManagerTaskDelegate类实现相关代理是为了其他类手动调用相关方法，AFURLSessionManager也实现了这些代理，所以具体的调用是由AFURLSessionManger手动触发的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(theClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123; return class_addMethod(theClass, selector, method_getImplementation(method), method_getTypeEncoding(method));&#125;static NSString * const AFNSURLSessionTaskDidResumeNotification = @\"com.alamofire.networking.nsurlsessiontask.resume\";static NSString * const AFNSURLSessionTaskDidSuspendNotification = @\"com.alamofire.networking.nsurlsessiontask.suspend\";@interface _AFURLSessionTaskSwizzling : NSObject@end@implementation _AFURLSessionTaskSwizzling+ (void)load &#123; /** WARNING: Trouble Ahead https://github.com/AFNetworking/AFNetworking/pull/2702 */ if (NSClassFromString(@\"NSURLSessionTask\")) &#123; /** iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky. Many Unit Tests have been built to validate as much of this behavior has possible. Here is what we know: - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn't actually the type of class you will get back. - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there. - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`. - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`. - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled. - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled. - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there. Some Assumptions: - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we'd need to handle it. - No background task classes override `resume` or `suspend` The current solution: 1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task. 2) Grab a pointer to the original implementation of `af_resume` 3) Check to see if the current class has an implementation of resume. If so, continue to step 4. 4) Grab the super class of the current class. 5) Grab a pointer for the current class to the current implementation of `resume`. 6) Grab a pointer for the super class to the current implementation of `resume`. 7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods 8) Set the current class to the super class, and repeat steps 3-8 */ NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];#pragma GCC diagnostic push#pragma GCC diagnostic ignored \"-Wnonnull\" NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];#pragma clang diagnostic pop IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume))); Class currentClass = [localDataTask class]; while (class_getInstanceMethod(currentClass, @selector(resume))) &#123; Class superClass = [currentClass superclass]; IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume))); IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume))); if (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; [self swizzleResumeAndSuspendMethodForClass:currentClass]; &#125; currentClass = [currentClass superclass]; &#125; [localDataTask cancel]; [session finishTasksAndInvalidate]; &#125;&#125;+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123; Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume)); Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend)); if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123; af_swizzleSelector(theClass, @selector(resume), @selector(af_resume)); &#125; if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123; af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend)); &#125;&#125;- (NSURLSessionTaskState)state &#123; NSAssert(NO, @\"State method should never be called in the actual dummy class\"); return NSURLSessionTaskStateCanceling;&#125;- (void)af_resume &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_resume]; if (state != NSURLSessionTaskStateRunning) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self]; &#125;&#125;- (void)af_suspend &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_suspend]; if (state != NSURLSessionTaskStateSuspended) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self]; &#125;&#125;@end 这里用到了method-swizzling的技术，交换了 resume 和 suspend方法的实现，因为iOS7和iOS8中NSURLSessionTask的父类不同，需要做一些处理（发送task暂停、继续通知）。 123456789101112131415161718192021222324252627282930313233@interface AFURLSessionManager ()//管理的session运行模式，默认情况下使用默认运行模式，defaultConfiguration@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;/*NSOperation队列，代理方法执行的队列.h文件里是readonly，所以这里定义一个readwrite用于赋值*/@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;//管理的session，readwrite@property (readwrite, nonatomic, strong) NSURLSession *session;//可变字典，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;//只读属性，通过getter返回数据@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;//NSLock锁@property (readwrite, nonatomic, strong) NSLock *lock;//下面是一系列回调块@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;@end 延展里面定义了一些属性和响应的回调block。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation AFURLSessionManager//构造函数- (instancetype)init &#123; return [self initWithSessionConfiguration:nil];&#125;//构造函数- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; //如果没有指定session运行模式就使用默认的 if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; //创建代理方法执行的队列，最大并发数为1，即串行队列 //感觉这里设置为1是为了让回调一个个执行 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; //创建session，注意代理对象是self self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; //创建响应序列化器 self.responseSerializer = [AFJSONResponseSerializer serializer]; //设置默认安全策略 self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH //获取网络可达性manager self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; //创建锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* 获取session中的任务，并调用相关方法关联AFURLSessionManagerTaskDelegate 不太明白这里为什么要这么做，刚创建的session应该没有任何任务在执行 */ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self;&#125;//析构方法，移除所有通知监听- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 初始化方法里面有一个有一个不明白的点，创建完session之后就去获取它正在执行的任务，刚创建完session为何会有任务呢？这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。 1234567891011121314151617181920212223242526272829//taskDescriptionForSessionTasks属性的getter，返回地址的字符串形式数据，可以保证这个字符串是唯一的- (NSString *)taskDescriptionForSessionTasks &#123; return [NSString stringWithFormat:@\"%p\", self];&#125;//通知的回调方法，接下来的代码会添加相关通知- (void)taskDidResume:(NSNotification *)notification &#123; //发送通知的时候会将task添加进通知中 NSURLSessionTask *task = notification.object; //判断这个任务是否是当前manager管理的，如果是就发送相关通知 //task的taskDescription属性在下文的源码中会设置 if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task]; &#125;); &#125; &#125;&#125;//同上- (void)taskDidSuspend:(NSNotification *)notification &#123; NSURLSessionTask *task = notification.object; if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task]; &#125;); &#125; &#125;&#125; 上面的代码就是通知的回调方法，用于通知resume和suspend事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//根据task获取相关联的AFURLSessionManagerTaskDelegate对象- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123; //task不能为空 NSParameterAssert(task); //上锁，通过task的唯一taskIdentifier从字典中取值，这个唯一标识是在创建task的时候NSURLSessionTask为其设置的，不需要手动设置，保证唯一性 AFURLSessionManagerTaskDelegate *delegate = nil; [self.lock lock]; delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate;&#125;//为task设置关联的delegate- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; //task和delegate都不能为空 NSParameterAssert(task); NSParameterAssert(delegate); //上锁，向字典中添加key-value对 [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125;//重点方法，为dataTask创建一个关联的AFURLSessionManagerTaskDelegate对象- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; //创建AFURLSessionManagerTaskDelegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; //设置相关属性 delegate.manager = self; delegate.completionHandler = completionHandler; /* 设置task的taskDescription，注意和taskIdentifier区分 taskDescription是开发者自行设置的 taskIdentifier是NSURLSessionTask设置的，保证每一个task的id不同 这里设置的taskDescription就是AFURLSessionManager的地址 所以同一个manager创建的task的description都是一致的 设置这个值的目的就是为了区分task是否是当前manger创建的 */ dataTask.taskDescription = self.taskDescriptionForSessionTasks; //调用上面的方法将task-delegate键值对添加进字典中 [self setDelegate:delegate forTask:dataTask]; //设置回调块 delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//同上，创建上传任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; uploadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:uploadTask]; delegate.uploadProgressBlock = uploadProgressBlock;&#125;//同上，创建下载文件任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; /* 需要注意下，AFURLSessionManagerTaskDelegate中下载文件完成后会调用delegate.downloadTaskDidFinishDownloading回调块 来获取下载文件要移动到的目录URL 所以这里就是创建这个回调块，直接返回参数中的destination回调块 */ if (destination) &#123; delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123; return destination(location, task.response); &#125;; &#125; downloadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:downloadTask]; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//从字典中删除task对应的delegate的key-value对- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); [self.lock lock]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; 上面的代码就是对AFURLSessionManagerTaskDelegate的创建、添加进字典、删除、获取的操作，这样就实现了每一个NSURLSessionTask对应一个AFURLSessionManagerTaskDelegate对象，可能读者会有疑问，AFURLSessionManager既然已经实现了代理的方法，为什么不直接使用它来处理代理方法，为什么要创建一个类来专门处理，继续看完源码可能你就会明白了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//根据keyPath获取不同类型任务的集合- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray *tasks = nil; //创建一个信号量，值是0 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); //这个方法是异步的，所以为了同步返回结果，需要使用锁，信号量值设置为0或者1时就可以当锁来使用了 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks = dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks = uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks = downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@\"@unionOfArrays.self\"]; &#125; //signal通知信号量，信号量值加1 dispatch_semaphore_signal(semaphore); &#125;]; //等待信号量，直到值大于0，等待时间是forever dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125;//下面是tasks、dataTasks、uploadTasks、downloadTasks属性的getter，都是调用上述方法来获取对应类型的任务集合- (NSArray *)tasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)dataTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)uploadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)downloadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;#pragma mark -//设置session无效，根据参数判断是否需要取消正在执行的任务- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks &#123; //调用NSURLSession对应的方法来设置session无效，同时打破引用循环 if (cancelPendingTasks) &#123; [self.session invalidateAndCancel]; &#125; else &#123; [self.session finishTasksAndInvalidate]; &#125;&#125;#pragma mark -//responseSerializer的setter- (void)setResponseSerializer:(id &lt;AFURLResponseSerialization&gt;)responseSerializer &#123; NSParameterAssert(responseSerializer); _responseSerializer = responseSerializer;&#125;#pragma mark -//添加通知，taskDidResume、taskDidSuspend方法前面讲过了- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];&#125;//删除通知- (void)removeNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidSuspendNotification object:task]; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidResumeNotification object:task];&#125; 上面的方法是一些getter和setter，很简单，不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];&#125;//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; //为了解决iOS8一下的一个bug，调用一个串行队列来创建dataTask __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^&#123; //使用session来创建一个NSURLSessionDataTask对象 dataTask = [self.session dataTaskWithRequest:request]; &#125;); //为这个task创建一个AFURLSessionManagerTaskDelegate并关联加入字典中 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125;#pragma mark -//创建一个NSURLSessionUploadTask对象- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125;); // uploadTask may be nil on iOS7 because uploadTaskWithRequest:fromFile: may return nil despite being documented as nonnull (https://devforums.apple.com/message/926113#926113) //解决iOS7的一个bug按照配置的尝试次数创建上传任务，默认尝试3次 if (!uploadTask &amp;&amp; self.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; self.session.configuration.identifier) &#123; for (NSUInteger attempts = 0; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125; &#125; //创建关联的delegate并添加到字典中 [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;#pragma mark -//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithRequest:request]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125;//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithResumeData:resumeData]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125; 上面的方法就是AFURLSessionManager为我们提供的获取NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask的方法，上面这些方法主要目的就是传入进度或完成回调块，然后构造一个AFURLSessionManagerTaskDeleagte对象并关联，这样就不需要开发者自行实现和管理代理方法做相关数据处理，只需要在回调块中做处理即可。 接下来源码中是一系列回调块的setter方法，就不列下来了，读者可以自己看看。接下来就讲解重点的各种代理的回调方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//session无效后的回调方法- (void)URLSession:(NSURLSession *)sessiondidBecomeInvalidWithError:(NSError *)error&#123; //如果回调块存在就执行回调块 if (self.sessionDidBecomeInvalid) &#123; self.sessionDidBecomeInvalid(session, error); &#125; //发送对应通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];&#125;//收到服务端的challenge，例如https需要验证证书等- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; //如果有对应回调块就执行 if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; //处理https if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; 上面两个方法是NSURLSessionDelegate的方法，关于验证HTTPS的部分代码可以当做模板代码来写，具体内容不是本文讲解范畴，读者可自行查阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//要执行重定向的代理方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskwillPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler&#123; //套路就是执行用户自定义的回调块，执行完成回调块 NSURLRequest *redirectRequest = request; if (self.taskWillPerformHTTPRedirection) &#123; redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request); &#125; if (completionHandler) &#123; completionHandler(redirectRequest); &#125;&#125;//同前面一样，处理https链接- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (self.taskDidReceiveAuthenticationChallenge) &#123; disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential); &#125; else &#123; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125;//处理需要一个新的流- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler&#123; //调用用户自定义的回调块来获取，或者copy一个 NSInputStream *inputStream = nil; if (self.taskNeedNewBodyStream) &#123; inputStream = self.taskNeedNewBodyStream(session, task); &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123; inputStream = [task.originalRequest.HTTPBodyStream copy]; &#125; if (completionHandler) &#123; completionHandler(inputStream); &#125;&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //获取上传的总大小，如果数据不正确就从http首部中获取 int64_t totalUnitCount = totalBytesExpectedToSend; if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123; NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@\"Content-Length\"]; if(contentLength) &#123; totalUnitCount = (int64_t) [contentLength longLongValue]; &#125; &#125; //获取task关联的AFURLSessionManagerTaskDelegate对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; //如果代理对象存在，就调用代理对象的这个方法 if (delegate) &#123; [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend]; &#125; //如果用户自定义回调块存在，执行回调块 if (self.taskDidSendBodyData) &#123; self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount); &#125;&#125;//任务完成的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //同样的套路，获取关联的代理对象，手动调用代理对象的这个方法，执行用户自定义的回调块 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; &#125; if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error); &#125;&#125; 以上代码是NSURLSessionTaskDelegate的回调方法，通过上面的代码可以发现AFURLSessionManagerTaskDelegate的作用了，AFURLSessionManager的代理方法中会根据task获取到对应的delegate，如果需要提前处理一些数据就先处理，处理完成后手动触发delegate中的对应方法，然后具体的数据处理就交由AFURLSessionManagerTaskDelegate来处理。继续看其他代理方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//收到服务端响应的代理回调方法- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; //调用用户自定义回调块，执行完成回调块 NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; if (self.dataTaskDidReceiveResponse) &#123; disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; if (completionHandler) &#123; completionHandler(disposition); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; if (delegate) &#123; [self removeDelegateForTask:dataTask]; [self setDelegate:delegate forTask:downloadTask]; &#125; if (self.dataTaskDidBecomeDownloadTask) &#123; self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //获取代理，然后调用代理的这个方法，有自定义回调块就执行 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; [delegate URLSession:session dataTask:dataTask didReceiveData:data]; if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (self.dataTaskWillCacheResponse) &#123; cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse); &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125;- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123; if (self.didFinishEventsForBackgroundURLSession) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.didFinishEventsForBackgroundURLSession(session); &#125;); &#125;&#125; 上面的代码是NSURLSessionDataDelegate的代理方法，同样的，如果AFURLSessionManagerTaskDelegate能响应的关于数据处理的方法都会通过task找到对应delegate后调用其对应的方法，然后执行用户自定义的回调块，如果代理不能响应的方法就由AFURLSessionManager自行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//下载任务下载文件完成后的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //获取对应的代理对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果downloadTaskDidFinishDownloading回调块存在就执行它来获取一个保存文件的URL路径 if (self.downloadTaskDidFinishDownloading) &#123; NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果这个路径存在就通过NSFileManager来移动，移动失败发送通知 if (fileURL) &#123; delegate.downloadFileURL = fileURL; NSError *error = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo]; &#125; return; &#125; &#125; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location]; &#125;&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //通过task获取delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果delegate存在就调用其该方法 if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite]; &#125; //如果回调块存在就执行 if (self.downloadTaskDidWriteData) &#123; self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite); &#125;&#125;//同上套路- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes]; &#125; if (self.downloadTaskDidResume) &#123; self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes); &#125;&#125; 到现在为止，AFURLSessionManager所有源码都看完了，代码封装了NSURLSession并提供了简洁的创建NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask对象的方法，使用人员可以不需要考虑具体的数据处理过程，最简单的可以只通过回调块来获取网络请求的各种信息。在具体实现上，AFURLSessionManager通过定义AFURLSessionManagerTaskDelegate来做具体task的数据处理，而AFURLSessionManager只关注于通用部分的实现，并提供各种方法和回调块用于处理task，使得代码结构更清晰，AFURLSessionManager代理方法结构也更简单。 AFURLSessionManager个人总结 AFURLSessionManagerTaskDelegate 是为了对应每一个task，单独定义一个类，解耦合，代码逻辑更清晰 mutableData 在请求完成之后置位 nil，节省内存 dispatch_semaphore的使用，信号量线程同步 method swizzing巧妙监听 task 的 suspend 和 resume NSLock 安全加锁，避免字典中假如的 delegate 和 task不对应","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"https://nixzhang5.github.io/tags/AFNetWorking原理/"}]},{"title":"Github Blog With Hexo","slug":"hello-world","date":"2019-06-21T07:40:42.265Z","updated":"2019-06-24T10:16:01.754Z","comments":true,"path":"hello-world.html","link":"","permalink":"https://nixzhang5.github.io/hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://nixzhang5.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://nixzhang5.github.io/tags/hexo/"}]}]}