{"meta":{"title":"Xinping\\'s Blog","subtitle":"因为有了危机感，所以会义无反顾。","description":null,"author":"张新平","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-06-24T18:03:14.000Z","updated":"2019-06-24T10:25:07.974Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-24T18:08:50.000Z","updated":"2019-06-24T10:25:34.397Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AFNetWorking原理","slug":"AFNetWorking原理","date":"2019-06-21T15:48:30.000Z","updated":"2019-06-24T10:18:43.281Z","comments":true,"path":"2019/06/21/AFNetWorking原理/","link":"","permalink":"http://yoursite.com/2019/06/21/AFNetWorking原理/","excerpt":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。","text":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。 AFNetworking由5个模块组成 NSURLSession：网络通信模块（核心模块） AFURLSessionManager 对NSURLSession的封装 AFHTTPSessionManager 是继承于 AFURLSessionmanager Security：网络通讯安全策略模块 AFSecurityPolicy Reachability：网络状态监听模块 AFNetworkReachabilityManager Seriaalization：网络通信信息序列化、反序列化模块 AFHTTPRequestSerializer AFURLResponseSerialization UIKit：对于iOS UIKit的扩展库 网络请求类 AFURLSessionManager声明.h文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226// AFURLSessionManager类实现了NSURLSession相关的众多协议，用于帮助我们进行数据的处理@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;// NSURLSession 作为一个实例变量，AFN发起的网络请求都是通过该session创建的task实现的@property (readonly, nonatomic, strong) NSURLSession *session;// NSURLSession delegate方法执行队列@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;// 响应序列化 不能为nil@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;// 安全策略，用于https等需要验证的地方@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;#if !TARGET_OS_WATCH（生成的代码将在Apple Watch操作系统下运行）///--------------------------------------/// @name Monitoring Network Reachability///--------------------------------------// 监测网络连通性，使用AFNetworkReachabilityManager@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;#endif///----------------------------/// @name Getting Session Tasks///----------------------------// session管理的data upload download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;// session管理的data task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;// session管理的upload task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;// session管理的download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;///-------------------------------/// @name Managing Callback Queues///-------------------------------// 完成网络请求后执行回调块的队列，如果为nil则使用主队列@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;// 完成网络请求后回调块的@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;///---------------------------------/// @name Working Around System Bugs///---------------------------------// background类型的session是否尝试重新创建上传任务@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;///---------------------/// @name Initialization///---------------------// 初始化函数，根据指定NSURLSessionConfiguration创建session- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;// 设置session无效，cancelPendingTasks标识是否取消session中正在执行的任务// 内部还是调用NSURLSession的invalidate方法- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;///-------------------------/// @name Running Data Tasks///-------------------------// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler DEPRECATED_ATTRIBUTE;// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///---------------------------/// @name Running Upload Tasks///---------------------------// 根据指定request fileURL等参数构造一个NSURLSessionUploadTask任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 根据指定request和data等参数构造一个上传任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 创建一个具有特定数据流的NSURLSessionUploadTask请求，上传的body使用的是request.HTTPBodyStream- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///-----------------------------/// @name Running Download Tasks///-----------------------------// 构造下载任务- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;/*构造下载任务 断点续传根据未下载完成的数据，创建一个NSURLSessionDownloadTask对象。resumeData：未完成的下载数据destination：决定下载文件的存放路径的block。block中有两个参数，目标路径和服务器的响应。同时返回文件下载的URLcompletionHandler：当任务完成后completionHandler的block会被调用progress：下载进度block。每当下载进度更新时就会执行这个block*/- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;///---------------------------------/// @name Getting Progress for Tasks///---------------------------------// 根据NSURLSessionTask获取对应的任务完成进度NSProgress- (nullable NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task;// 根据NSURLSessionTask获取对应下载任务的进度NSProgress- (nullable NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task;///-----------------------------------------/// @name Setting Session Delegate Callbacks///-----------------------------------------// 设置session无效时执行的回调块- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;// 设置session收到challenge时执行的回调块- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;///--------------------------------------/// @name Setting Task Delegate Callbacks///--------------------------------------// 设置session需要新的流时执行的回调块- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;// 设置session的任务需要执行重定向时执行的回调块- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * _Nullable (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;// 设置Block用于当一个session的task接收到证书验证时调用。实际上依赖由NSURLSessionTaskDelegate 的 URLSession:task:didReceiveChallenge:completionHandler:.方法处理- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;// 设置Block每隔一段时间调用用来跟踪上传进度，实际上依赖由NSURLSessionTaskDelegate的 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法实现- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;// 设置一个当task完成时调用的Block- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;///-------------------------------------------/// @name Setting Data Task Delegate Callbacks///-------------------------------------------// 设置一个当DataTask请求接收到响应时调用的block。交由NSURLSessionDataDelegate的URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;// 设置当一个dataTask转变成downloadTak时调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didBecomeDownloadTask:.方法处理- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;// 设置当一个dataTask接受到数据时就调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;// 设置当一个dataTask对请求结果的缓冲时的block。交由NSURLSessionDataDelegate 的 URLSession:dataTask:willCacheResponse:completionHandler:.方法处理- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;// 设置当session中所有消息都被发送时，调用的block。交由NSURLSessionDataDelegate的URLSessionDidFinishEventsForBackgroundURLSession：方法实现- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block AF_API_UNAVAILABLE(macos);///-----------------------------------------------/// @name Setting Download Task Delegate Callbacks///-----------------------------------------------// 设置一个当下载任务完成一个下载时调用的block。最终交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didFinishDownloadingToURL:.方法处理- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;// 设置每次追踪下载进度时调用的block，最终交由NSURLSessionDownloadDelegate的URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite：方法处理- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;// 设置一个block，当任务重新下载时调用。交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:.方式- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;@end///--------------------/// @name Notifications///--------------------FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidSuspendNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDidInvalidateNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseDataKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteAssetPathKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteErrorKey;NS_ASSUME_NONNULL_END 通过头文件可以发现，AFURLSessionManager是封装了NSURLSession并实现了其相关的所有协议，提供了一系列方法用于构造各种网络请求任务，并提供回调块进行处理，还提供了一系列设置代理方法执行时的执行回调块的方法，这样，我们也可以监听整个网络请求的过程，当然也可以忽略这些代理方法执行情况，提供了各种通知，通过头文件可以看出，主要目的还是为了封装NSURLSession从而提供更加便捷的方法来实现网络请求。 实现.m文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef NSFoundationVersionNumber_iOS_8_0#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11#else#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0#endif//C静态函数，GCD只执行一次，用于创建一个串行队列来执行各种网络请求任务的创建工作static dispatch_queue_t url_session_manager_creation_queue() &#123; static dispatch_queue_t af_url_session_manager_creation_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_creation_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.creation\", DISPATCH_QUEUE_SERIAL); &#125;); return af_url_session_manager_creation_queue;&#125;/*C静态函数，用于执行创建网络请求任务的block主要目的是为了解决ios8以下存在的一个block和task不匹配的bug上面那个队列也是为了解决这个bug才创建的具体可查看Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093*/static void url_session_manager_create_task_safely(dispatch_block_t block) &#123; if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123; dispatch_sync(url_session_manager_creation_queue(), block); &#125; else &#123; block(); &#125;&#125;//C静态函数，创建一个并发队列，用于在网络请求任务完成后处理数据的，并发队列实现多线程处理多个请求完成后的数据处理static dispatch_queue_t url_session_manager_processing_queue() &#123; static dispatch_queue_t af_url_session_manager_processing_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_processing_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.processing\", DISPATCH_QUEUE_CONCURRENT); &#125;); return af_url_session_manager_processing_queue;&#125;//C静态函数创建一个dispatch的组//但在接下来的源码中并没有使用这个组来实现notify等功能，仅仅是将block和组关联了，不太清楚具体用意//有明白的读者还请不吝赐教static dispatch_group_t url_session_manager_completion_group() &#123; static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_completion_group = dispatch_group_create(); &#125;); return af_url_session_manager_completion_group;&#125;//一系列通知名称的定义NSString * const AFNetworkingTaskDidResumeNotification = @\"com.alamofire.networking.task.resume\";NSString * const AFNetworkingTaskDidCompleteNotification = @\"com.alamofire.networking.task.complete\";NSString * const AFNetworkingTaskDidSuspendNotification = @\"com.alamofire.networking.task.suspend\";NSString * const AFURLSessionDidInvalidateNotification = @\"com.alamofire.networking.session.invalidate\";NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification = @\"com.alamofire.networking.session.download.file-manager-error\";NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey = @\"com.alamofire.networking.task.complete.serializedresponse\";NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey = @\"com.alamofire.networking.task.complete.responseserializer\";NSString * const AFNetworkingTaskDidCompleteResponseDataKey = @\"com.alamofire.networking.complete.finish.responsedata\";NSString * const AFNetworkingTaskDidCompleteErrorKey = @\"com.alamofire.networking.task.complete.error\";NSString * const AFNetworkingTaskDidCompleteAssetPathKey = @\"com.alamofire.networking.task.complete.assetpath\";//需要使用的NSLock锁的名称static NSString * const AFURLSessionManagerLockName = @\"com.alamofire.networking.session.manager.lock\";//background session重试创建上传任务次数static NSUInteger const AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = 3; 对于url_session_manager_create_task_safely这个有什么用？其实这个是被当做是一个在ios8以下，NSURLSessionDataTask出现的一个Bug。问题产生的原因就是当队列是并发的，这是当两个任务同时在不同的线程上创建任务的时候taskIdentifier可能是一样的。大致的意思就是当我们同时创建两个任务，返回了重复的taskIdentifier，这样的话第一个被创建的completionHandler就会被清空，被第二个任务的completionHandler给替换，如果第一个数据是早于第二个数据返回的，那么第一个数据返回之后就会去调用第二个任务的completionHandler。 12345678910111213141516171819202122typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session, NSError *error);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef NSURLRequest * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef void (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(NSURLSession *session);typedef NSInputStream * (^AFURLSessionTaskNeedNewBodyStreamBlock)(NSURLSession *session, NSURLSessionTask *task);typedef void (^AFURLSessionTaskDidSendBodyDataBlock)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);typedef void (^AFURLSessionTaskDidCompleteBlock)(NSURLSession *session, NSURLSessionTask *task, NSError *error);typedef NSURLSessionResponseDisposition (^AFURLSessionDataTaskDidReceiveResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response);typedef void (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask);typedef void (^AFURLSessionDataTaskDidReceiveDataBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data);typedef NSCachedURLResponse * (^AFURLSessionDataTaskWillCacheResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse);typedef NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);typedef void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);typedef void (^AFURLSessionDownloadTaskDidResumeBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);typedef void (^AFURLSessionTaskProgressBlock)(NSProgress *);typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response, id responseObject, NSError *error); 定义一些回调的block 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248//定义了一个类AFURLSessionManagerTaskDelegate并实现了NSURLSessionTask的相关协议//这个类是用于处理NSURLSessionTask相关代理方法的@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;//初始化构造函数，需要传入一个关联的task- (instancetype)initWithTask:(NSURLSessionTask *)task;//weak修饰的manager@property (nonatomic, weak) AFURLSessionManager *manager;//可变data用于存储获取到的网络数据@property (nonatomic, strong) NSMutableData *mutableData;//上传进度NSProgress@property (nonatomic, strong) NSProgress *uploadProgress;//下载进度NSProgress@property (nonatomic, strong) NSProgress *downloadProgress;//下载文件的NSURL@property (nonatomic, copy) NSURL *downloadFileURL;//下载完成的回调块@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;//上传进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;//下载进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;//网络请求完成的回调块@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;@end@implementation AFURLSessionManagerTaskDelegate//初始化构造函数- (instancetype)initWithTask:(NSURLSessionTask *)task &#123; self = [super init]; if (!self) &#123; return nil; &#125; _mutableData = [NSMutableData data]; _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; //遍历两个上传和下载NSProgress设置一些属性 __weak __typeof__(task) weakTask = task; for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ]) &#123; //初始化progress progress.totalUnitCount = NSURLSessionTransferSizeUnknown; progress.cancellable = YES; //设置取消进度的回调块，执行task的cancel方法 progress.cancellationHandler = ^&#123; [weakTask cancel]; &#125;; progress.pausable = YES; //设置暂停进度的回调块，执行task的suspend方法 progress.pausingHandler = ^&#123; [weakTask suspend]; &#125;; //设置重新开始的回调块，执行task的resume方法 if ([progress respondsToSelector:@selector(setResumingHandler:)]) &#123; progress.resumingHandler = ^&#123; [weakTask resume]; &#125;; &#125; //progress添加kvo，监听progress的进度fractionCompleted [progress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; &#125; return self;&#125;//析构函数- (void)dealloc &#123; //删除KVO [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];&#125;#pragma mark - NSProgress Tracking//KVO回调方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; //上次或下载进度有改变时，执行上传或下载进度回调块 if ([object isEqual:self.downloadProgress]) &#123; if (self.downloadProgressBlock) &#123; self.downloadProgressBlock(object); &#125; &#125; else if ([object isEqual:self.uploadProgress]) &#123; if (self.uploadProgressBlock) &#123; self.uploadProgressBlock(object); &#125; &#125;&#125;#pragma mark - NSURLSessionTaskDelegate//代理方法，网络请求完成或出错- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //manager用weak修饰，这里strong一下防止manager被释放 __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; //为userInfo字典设置响应序列化 userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 //赋值mutableData到data中，并释放mutableData NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; &#125; //如果downloadFileURL存在，即是下载任务就设置下载完成后的文件存储url到字典中 if (self.downloadFileURL) &#123; userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; &#125; else if (data) &#123; //否则就设置对应的NSData数据到字典中 userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; &#125; //如果网络请求有错误 if (error) &#123; //设置error信息到字典中 userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; /* 这个三目运算符需要解释一下，在其他语言中这么写很可能就是语法错误 这里的意思就是如果manager.completionGroup存在就使用它 不存在就使用url_session_manager_completion_group函数返回的group 后面的三目运算符同理 所以如果自己不设置manager的completionGroup或completionQueue就会使用默认提供的 */ //执行对应的completionHandler回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, error); &#125; //在主队列即主线程中发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125; else &#123; //如果网络任务成功完成，异步在并发队列中执行数据处理 dispatch_async(url_session_manager_processing_queue(), ^&#123; //序列化响应数据 NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; //如果是下载任务设置响应数据为文件的url if (self.downloadFileURL) &#123; responseObject = self.downloadFileURL; &#125; //如果响应对象序列化成功或是文件url就设置相关字典key-value if (responseObject) &#123; userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; &#125; //如果序列化出错，设置相关字典值 if (serializationError) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; &#125; //同理，在dispatch组中和特定队列执行回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; //主线程发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); &#125;&#125;#pragma mark - NSURLSessionDataDelegate//回调方法，收到数据- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive; self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived; //添加数据到mutableData [self.mutableData appendData:data];&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //设置上传进度的相关属性 self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.uploadProgress.completedUnitCount = task.countOfBytesSent;&#125;#pragma mark - NSURLSessionDownloadDelegate//下载任务的回调方法//由于NSURLSession的downloadTask直接将文件下载到磁盘沙盒中，所以不需要mutableData自行接收数据- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = totalBytesExpectedToWrite; self.downloadProgress.completedUnitCount = totalBytesWritten;&#125;//恢复下载任务的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = expectedTotalBytes; self.downloadProgress.completedUnitCount = fileOffset;&#125;//下载任务下载文件完成后的回调方法//location就是文件下载到磁盘沙盒目录的NSURL- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //设置downloadFileURL为nil self.downloadFileURL = nil; //如果有下载完成的回调块 if (self.downloadTaskDidFinishDownloading) &#123; //执行该回调块，这个回调块返回一个下载的文件保存的路径URL //默认保存在沙盒tmp文件中，可能会被删除，需要持久化时要自己设置一个目录存储 self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果需要移动文件的路径使用NSFileManaegr移动 if (self.downloadFileURL) &#123; NSError *fileManagerError = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123; //文件移动发生错误发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; &#125; &#125; &#125;&#125;@end AFURLSessionManagerTaskDelegate的源码，主要就是关联一个NSURLSessionTask并实现了相关任务的代理方法用于数据的获取、上传文件和下载文件。需要注意的是NSURLSessionTask的delegate属性是只读的，只能在使用session创建task的函数中传入代理对象，而且通过源码也没有发现相关代理的设置，所以AFURLSessionManagerTaskDelegate类实现相关代理是为了其他类手动调用相关方法，AFURLSessionManager也实现了这些代理，所以具体的调用是由AFURLSessionManger手动触发的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(theClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123; return class_addMethod(theClass, selector, method_getImplementation(method), method_getTypeEncoding(method));&#125;static NSString * const AFNSURLSessionTaskDidResumeNotification = @\"com.alamofire.networking.nsurlsessiontask.resume\";static NSString * const AFNSURLSessionTaskDidSuspendNotification = @\"com.alamofire.networking.nsurlsessiontask.suspend\";@interface _AFURLSessionTaskSwizzling : NSObject@end@implementation _AFURLSessionTaskSwizzling+ (void)load &#123; /** WARNING: Trouble Ahead https://github.com/AFNetworking/AFNetworking/pull/2702 */ if (NSClassFromString(@\"NSURLSessionTask\")) &#123; /** iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky. Many Unit Tests have been built to validate as much of this behavior has possible. Here is what we know: - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn't actually the type of class you will get back. - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there. - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`. - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`. - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled. - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled. - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there. Some Assumptions: - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we'd need to handle it. - No background task classes override `resume` or `suspend` The current solution: 1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task. 2) Grab a pointer to the original implementation of `af_resume` 3) Check to see if the current class has an implementation of resume. If so, continue to step 4. 4) Grab the super class of the current class. 5) Grab a pointer for the current class to the current implementation of `resume`. 6) Grab a pointer for the super class to the current implementation of `resume`. 7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods 8) Set the current class to the super class, and repeat steps 3-8 */ NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];#pragma GCC diagnostic push#pragma GCC diagnostic ignored \"-Wnonnull\" NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];#pragma clang diagnostic pop IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume))); Class currentClass = [localDataTask class]; while (class_getInstanceMethod(currentClass, @selector(resume))) &#123; Class superClass = [currentClass superclass]; IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume))); IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume))); if (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; [self swizzleResumeAndSuspendMethodForClass:currentClass]; &#125; currentClass = [currentClass superclass]; &#125; [localDataTask cancel]; [session finishTasksAndInvalidate]; &#125;&#125;+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123; Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume)); Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend)); if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123; af_swizzleSelector(theClass, @selector(resume), @selector(af_resume)); &#125; if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123; af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend)); &#125;&#125;- (NSURLSessionTaskState)state &#123; NSAssert(NO, @\"State method should never be called in the actual dummy class\"); return NSURLSessionTaskStateCanceling;&#125;- (void)af_resume &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_resume]; if (state != NSURLSessionTaskStateRunning) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self]; &#125;&#125;- (void)af_suspend &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_suspend]; if (state != NSURLSessionTaskStateSuspended) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self]; &#125;&#125;@end 这里用到了method-swizzling的技术，交换了 resume 和 suspend方法的实现，因为iOS7和iOS8中NSURLSessionTask的父类不同，需要做一些处理（发送task暂停、继续通知）。 123456789101112131415161718192021222324252627282930313233@interface AFURLSessionManager ()//管理的session运行模式，默认情况下使用默认运行模式，defaultConfiguration@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;/*NSOperation队列，代理方法执行的队列.h文件里是readonly，所以这里定义一个readwrite用于赋值*/@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;//管理的session，readwrite@property (readwrite, nonatomic, strong) NSURLSession *session;//可变字典，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;//只读属性，通过getter返回数据@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;//NSLock锁@property (readwrite, nonatomic, strong) NSLock *lock;//下面是一系列回调块@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;@end 延展里面定义了一些属性和响应的回调block。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation AFURLSessionManager//构造函数- (instancetype)init &#123; return [self initWithSessionConfiguration:nil];&#125;//构造函数- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; //如果没有指定session运行模式就使用默认的 if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; //创建代理方法执行的队列，最大并发数为1，即串行队列 //感觉这里设置为1是为了让回调一个个执行 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; //创建session，注意代理对象是self self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; //创建响应序列化器 self.responseSerializer = [AFJSONResponseSerializer serializer]; //设置默认安全策略 self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH //获取网络可达性manager self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; //创建锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* 获取session中的任务，并调用相关方法关联AFURLSessionManagerTaskDelegate 不太明白这里为什么要这么做，刚创建的session应该没有任何任务在执行 */ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self;&#125;//析构方法，移除所有通知监听- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 初始化方法里面有一个有一个不明白的点，创建完session之后就去获取它正在执行的任务，刚创建完session为何会有任务呢？这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。 1234567891011121314151617181920212223242526272829//taskDescriptionForSessionTasks属性的getter，返回地址的字符串形式数据，可以保证这个字符串是唯一的- (NSString *)taskDescriptionForSessionTasks &#123; return [NSString stringWithFormat:@\"%p\", self];&#125;//通知的回调方法，接下来的代码会添加相关通知- (void)taskDidResume:(NSNotification *)notification &#123; //发送通知的时候会将task添加进通知中 NSURLSessionTask *task = notification.object; //判断这个任务是否是当前manager管理的，如果是就发送相关通知 //task的taskDescription属性在下文的源码中会设置 if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task]; &#125;); &#125; &#125;&#125;//同上- (void)taskDidSuspend:(NSNotification *)notification &#123; NSURLSessionTask *task = notification.object; if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task]; &#125;); &#125; &#125;&#125; 上面的代码就是通知的回调方法，用于通知resume和suspend事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//根据task获取相关联的AFURLSessionManagerTaskDelegate对象- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123; //task不能为空 NSParameterAssert(task); //上锁，通过task的唯一taskIdentifier从字典中取值，这个唯一标识是在创建task的时候NSURLSessionTask为其设置的，不需要手动设置，保证唯一性 AFURLSessionManagerTaskDelegate *delegate = nil; [self.lock lock]; delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate;&#125;//为task设置关联的delegate- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; //task和delegate都不能为空 NSParameterAssert(task); NSParameterAssert(delegate); //上锁，向字典中添加key-value对 [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125;//重点方法，为dataTask创建一个关联的AFURLSessionManagerTaskDelegate对象- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; //创建AFURLSessionManagerTaskDelegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; //设置相关属性 delegate.manager = self; delegate.completionHandler = completionHandler; /* 设置task的taskDescription，注意和taskIdentifier区分 taskDescription是开发者自行设置的 taskIdentifier是NSURLSessionTask设置的，保证每一个task的id不同 这里设置的taskDescription就是AFURLSessionManager的地址 所以同一个manager创建的task的description都是一致的 设置这个值的目的就是为了区分task是否是当前manger创建的 */ dataTask.taskDescription = self.taskDescriptionForSessionTasks; //调用上面的方法将task-delegate键值对添加进字典中 [self setDelegate:delegate forTask:dataTask]; //设置回调块 delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//同上，创建上传任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; uploadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:uploadTask]; delegate.uploadProgressBlock = uploadProgressBlock;&#125;//同上，创建下载文件任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; /* 需要注意下，AFURLSessionManagerTaskDelegate中下载文件完成后会调用delegate.downloadTaskDidFinishDownloading回调块 来获取下载文件要移动到的目录URL 所以这里就是创建这个回调块，直接返回参数中的destination回调块 */ if (destination) &#123; delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123; return destination(location, task.response); &#125;; &#125; downloadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:downloadTask]; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//从字典中删除task对应的delegate的key-value对- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); [self.lock lock]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; 上面的代码就是对AFURLSessionManagerTaskDelegate的创建、添加进字典、删除、获取的操作，这样就实现了每一个NSURLSessionTask对应一个AFURLSessionManagerTaskDelegate对象，可能读者会有疑问，AFURLSessionManager既然已经实现了代理的方法，为什么不直接使用它来处理代理方法，为什么要创建一个类来专门处理，继续看完源码可能你就会明白了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//根据keyPath获取不同类型任务的集合- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray *tasks = nil; //创建一个信号量，值是0 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); //这个方法是异步的，所以为了同步返回结果，需要使用锁，信号量值设置为0或者1时就可以当锁来使用了 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks = dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks = uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks = downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@\"@unionOfArrays.self\"]; &#125; //signal通知信号量，信号量值加1 dispatch_semaphore_signal(semaphore); &#125;]; //等待信号量，直到值大于0，等待时间是forever dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125;//下面是tasks、dataTasks、uploadTasks、downloadTasks属性的getter，都是调用上述方法来获取对应类型的任务集合- (NSArray *)tasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)dataTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)uploadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)downloadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;#pragma mark -//设置session无效，根据参数判断是否需要取消正在执行的任务- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks &#123; //调用NSURLSession对应的方法来设置session无效，同时打破引用循环 if (cancelPendingTasks) &#123; [self.session invalidateAndCancel]; &#125; else &#123; [self.session finishTasksAndInvalidate]; &#125;&#125;#pragma mark -//responseSerializer的setter- (void)setResponseSerializer:(id &lt;AFURLResponseSerialization&gt;)responseSerializer &#123; NSParameterAssert(responseSerializer); _responseSerializer = responseSerializer;&#125;#pragma mark -//添加通知，taskDidResume、taskDidSuspend方法前面讲过了- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];&#125;//删除通知- (void)removeNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidSuspendNotification object:task]; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidResumeNotification object:task];&#125; 上面的方法是一些getter和setter，很简单，不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];&#125;//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; //为了解决iOS8一下的一个bug，调用一个串行队列来创建dataTask __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^&#123; //使用session来创建一个NSURLSessionDataTask对象 dataTask = [self.session dataTaskWithRequest:request]; &#125;); //为这个task创建一个AFURLSessionManagerTaskDelegate并关联加入字典中 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125;#pragma mark -//创建一个NSURLSessionUploadTask对象- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125;); // uploadTask may be nil on iOS7 because uploadTaskWithRequest:fromFile: may return nil despite being documented as nonnull (https://devforums.apple.com/message/926113#926113) //解决iOS7的一个bug按照配置的尝试次数创建上传任务，默认尝试3次 if (!uploadTask &amp;&amp; self.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; self.session.configuration.identifier) &#123; for (NSUInteger attempts = 0; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125; &#125; //创建关联的delegate并添加到字典中 [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;#pragma mark -//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithRequest:request]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125;//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithResumeData:resumeData]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125; 上面的方法就是AFURLSessionManager为我们提供的获取NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask的方法，上面这些方法主要目的就是传入进度或完成回调块，然后构造一个AFURLSessionManagerTaskDeleagte对象并关联，这样就不需要开发者自行实现和管理代理方法做相关数据处理，只需要在回调块中做处理即可。 接下来源码中是一系列回调块的setter方法，就不列下来了，读者可以自己看看。接下来就讲解重点的各种代理的回调方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//session无效后的回调方法- (void)URLSession:(NSURLSession *)sessiondidBecomeInvalidWithError:(NSError *)error&#123; //如果回调块存在就执行回调块 if (self.sessionDidBecomeInvalid) &#123; self.sessionDidBecomeInvalid(session, error); &#125; //发送对应通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];&#125;//收到服务端的challenge，例如https需要验证证书等- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; //如果有对应回调块就执行 if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; //处理https if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; 上面两个方法是NSURLSessionDelegate的方法，关于验证HTTPS的部分代码可以当做模板代码来写，具体内容不是本文讲解范畴，读者可自行查阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//要执行重定向的代理方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskwillPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler&#123; //套路就是执行用户自定义的回调块，执行完成回调块 NSURLRequest *redirectRequest = request; if (self.taskWillPerformHTTPRedirection) &#123; redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request); &#125; if (completionHandler) &#123; completionHandler(redirectRequest); &#125;&#125;//同前面一样，处理https链接- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (self.taskDidReceiveAuthenticationChallenge) &#123; disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential); &#125; else &#123; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125;//处理需要一个新的流- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler&#123; //调用用户自定义的回调块来获取，或者copy一个 NSInputStream *inputStream = nil; if (self.taskNeedNewBodyStream) &#123; inputStream = self.taskNeedNewBodyStream(session, task); &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123; inputStream = [task.originalRequest.HTTPBodyStream copy]; &#125; if (completionHandler) &#123; completionHandler(inputStream); &#125;&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //获取上传的总大小，如果数据不正确就从http首部中获取 int64_t totalUnitCount = totalBytesExpectedToSend; if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123; NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@\"Content-Length\"]; if(contentLength) &#123; totalUnitCount = (int64_t) [contentLength longLongValue]; &#125; &#125; //获取task关联的AFURLSessionManagerTaskDelegate对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; //如果代理对象存在，就调用代理对象的这个方法 if (delegate) &#123; [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend]; &#125; //如果用户自定义回调块存在，执行回调块 if (self.taskDidSendBodyData) &#123; self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount); &#125;&#125;//任务完成的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //同样的套路，获取关联的代理对象，手动调用代理对象的这个方法，执行用户自定义的回调块 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; &#125; if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error); &#125;&#125; 以上代码是NSURLSessionTaskDelegate的回调方法，通过上面的代码可以发现AFURLSessionManagerTaskDelegate的作用了，AFURLSessionManager的代理方法中会根据task获取到对应的delegate，如果需要提前处理一些数据就先处理，处理完成后手动触发delegate中的对应方法，然后具体的数据处理就交由AFURLSessionManagerTaskDelegate来处理。继续看其他代理方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//收到服务端响应的代理回调方法- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; //调用用户自定义回调块，执行完成回调块 NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; if (self.dataTaskDidReceiveResponse) &#123; disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; if (completionHandler) &#123; completionHandler(disposition); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; if (delegate) &#123; [self removeDelegateForTask:dataTask]; [self setDelegate:delegate forTask:downloadTask]; &#125; if (self.dataTaskDidBecomeDownloadTask) &#123; self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //获取代理，然后调用代理的这个方法，有自定义回调块就执行 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; [delegate URLSession:session dataTask:dataTask didReceiveData:data]; if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (self.dataTaskWillCacheResponse) &#123; cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse); &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125;- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123; if (self.didFinishEventsForBackgroundURLSession) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.didFinishEventsForBackgroundURLSession(session); &#125;); &#125;&#125; 上面的代码是NSURLSessionDataDelegate的代理方法，同样的，如果AFURLSessionManagerTaskDelegate能响应的关于数据处理的方法都会通过task找到对应delegate后调用其对应的方法，然后执行用户自定义的回调块，如果代理不能响应的方法就由AFURLSessionManager自行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//下载任务下载文件完成后的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //获取对应的代理对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果downloadTaskDidFinishDownloading回调块存在就执行它来获取一个保存文件的URL路径 if (self.downloadTaskDidFinishDownloading) &#123; NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果这个路径存在就通过NSFileManager来移动，移动失败发送通知 if (fileURL) &#123; delegate.downloadFileURL = fileURL; NSError *error = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo]; &#125; return; &#125; &#125; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location]; &#125;&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //通过task获取delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果delegate存在就调用其该方法 if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite]; &#125; //如果回调块存在就执行 if (self.downloadTaskDidWriteData) &#123; self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite); &#125;&#125;//同上套路- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes]; &#125; if (self.downloadTaskDidResume) &#123; self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes); &#125;&#125; 到现在为止，AFURLSessionManager所有源码都看完了，代码封装了NSURLSession并提供了简洁的创建NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask对象的方法，使用人员可以不需要考虑具体的数据处理过程，最简单的可以只通过回调块来获取网络请求的各种信息。在具体实现上，AFURLSessionManager通过定义AFURLSessionManagerTaskDelegate来做具体task的数据处理，而AFURLSessionManager只关注于通用部分的实现，并提供各种方法和回调块用于处理task，使得代码结构更清晰，AFURLSessionManager代理方法结构也更简单。 AFURLSessionManager个人总结 AFURLSessionManagerTaskDelegate 是为了对应每一个task，单独定义一个类，解耦合，代码逻辑更清晰 mutableData 在请求完成之后置位 nil，节省内存 信号量线程同步 method swizzing巧妙监听 task 的 suspend 和 resume NSLock 安全加锁，避免字典中假如的 delegate 和 task不对应","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"http://yoursite.com/tags/AFNetWorking原理/"}]},{"title":"Github Blog With Hexo","slug":"hello-world","date":"2019-06-21T07:40:42.265Z","updated":"2019-06-24T10:16:01.754Z","comments":true,"path":"2019/06/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/21/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}