{"meta":{"title":"Xinping's Blog","subtitle":"因为有了危机感，所以才会义无反顾。","description":"积累 记录 传播 共进","author":"张新平","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-06-24T10:03:14.000Z","updated":"2019-06-24T10:25:07.974Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-24T10:08:50.000Z","updated":"2019-06-24T10:25:34.397Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"App签名原理","slug":"App签名原理","date":"2019-06-26T03:29:11.000Z","updated":"2019-06-27T02:16:48.499Z","comments":true,"path":"2019/06/26/App签名原理/","link":"","permalink":"http://yoursite.com/2019/06/26/App签名原理/","excerpt":"App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。","text":"App签名是为了保证每个App都是经过苹果公司官方认证的。iPhone和系统都是苹果公司生产的，所以苹果公司可以在手机上内置公钥，App Store上内置私钥。 苹果签名需求： 为了保证系统的安全性，所有iPhone上安装的应用必须是经过苹果授权的 安装包不需要上传到App Store也能被安装 （开发调试 企业灰度） 防止证书权限滥用：设备限制、指定APP、iCloud/PUSH/后台运行等附加权限控制 下载App签名签名原理： App上传到App Store时，苹果公司拿到App的HASH(MD5,SHA等)值，然后用私钥进行加密(签名)，这时候只有手机上的公钥才可以解密； 手机下载应用安装App时，先用公钥解密(验证签名)，拿到HASH值，然后将此HASH值，与要安装的App的HASH值进行校验，如果App有被修改过，则校验失败。这样就可以有效的保证每个App都是经过苹果公司官方认证的。 双层签名真机调试，企业包上面的签名方式就不适合了。这时候需要双层签名： 在Mac系统中生成一对非对称加密算法的公私钥M（keychain 里的 从证书颁发机构请求证书，保存的CertificateSigningRequest就包含公钥M，私钥保存在本地）。 苹果自己有固定的一对公私钥：私钥A在苹果后台，公钥A在每个iOS系统的手机中。 申请证书，把CertificateSigningRequest.certSigningRequest文件（包含公钥M，以及一些开发者信息）发送给苹果后台，用苹果后台的私钥A对公钥M签名，得到一份包含公钥M以及其签名结果的数据就是证书。 生成的证书下载下来，keychain会把这两个证书关联起来，因为公私钥是对应的。这个私钥只有这台电脑有，团队开发需要把这个私钥导出.p12给其他Mac. 配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件（包含设备IDs,AppID,Entitlements(权力文件包含是否可调试，推送，后台运行等信息)）。 XCode 会通过第3步下载回来的证书（存着公钥），在本地找到对应的私钥（第1步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。 打包过程用私钥M对App的HASH值进行加密(签名)，这时的APP内部实际包含了APP的签名(私钥M加密App的HASH值)、第3步生成的证书文件(包含公钥M和公钥M的HASH值)、Provision Profile(描述文件)，App可执行文件以及其他信息 解密： iPhone手机拿到证书文件(包含公钥M和公钥M的HASH值)，因为手机里有公钥A，所以能解密证书文件，得到公钥M和公钥M的HASH值，先验证公钥M生成的HASH值(MD5,SHA等)是不是和证书文件里的公钥M的HASH值一致，确保证书没有被修改； 验证一致后，就可以用公钥M来解密第2步的APP的签名，同样道理可以验证App是否被修改过。 因为在开发阶段App会经常修改，所以App就算是修改过，也能安装。第4步主要是验证证书是不是苹果认证的，只要证书对就可以安装运行。 加密解密： mac电脑：私钥M和公钥M(电脑生成) 苹果服务器：私钥A iPhone手机：公钥A .ipa包含的信息： 资源文件，例如图片、html、等等。 _CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。 可执行文件。此文件跟资源文件一样需要签名。 一个mobileprovision文件.打包的时候使用的，从MC上生成的。 Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件。 签名原理图： sign","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"Encryption","slug":"Encryption","permalink":"http://yoursite.com/tags/Encryption/"}]},{"title":"加密","slug":"加密","date":"2019-06-26T02:27:44.000Z","updated":"2019-06-26T03:25:10.730Z","comments":true,"path":"2019/06/26/加密/","link":"","permalink":"http://yoursite.com/2019/06/26/加密/","excerpt":"加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。","text":"加密是为了保证我们的数据安全，即不被他人篡改或截取到有用的信息的操作。iOS一直以安全著称，但是从Xcode的Ghost事件之后，iOS安全不可摧的神话似乎已经被打破。事实证明，无论是Android还是iOS，该加密处理的还是需要加密处理，谁也不能保证自己一定是安全的。 对称加密A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。 优点简单快捷，密钥较短，且破译困难。 缺点如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通的两个用户之间怎么确定密钥也需要考虑，这其中就会有密钥泄露的风险，以及存在更换密钥的需求。 对称加密通常有 AES, DES, IDEA, 3DES 加密算法。 非对称加密用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。 缺点加解密比对称加密耗时. 优点比对称加密安全. 但是非对称加密也是存在漏洞，因为公钥是公开的，如果有 C 冒充 B 的身份利用 A 的公钥给 A 发消息，这样就乱套了，所以接下来就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。 常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） Hash算法（摘要算法）Hash算法的特点是单向不可还原，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。只要源数据不同，算法得到的摘要必定不同。 常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA 数字签名数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。 数字签名是 A将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要一起发送给B；B接收到后解密，得到这个摘要 a 和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要 b，比较 a 与 b 就可得知在传输过程中是否被更改过。 因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。 完整的非对称加密过程假如现在 你向支付宝 转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为： 首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息， 你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等； 你 对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）； 你 用自己的私钥对信息摘要进行加密得到 你 的数字签名，并将其附在数字信息上； 你 随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）； 你用 支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝； 支付宝收到 你 传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到 你随机产生的加密密钥； 支付宝 然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃； 支付宝 用你 的公钥对 你的的数字签名进行解密，得到信息摘要； 支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要； 支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。 确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。在这后面的流程就不属于本次非对称加密的范畴，算支付宝个人的自我流程，也就是循环以上过程。 iOS常用的加密方式Base64加密、MD5加密、AES加密、RSA加密 Base64加密Base64编码的思想是：采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组，以3个字节为一组，按顺序排列24位数据，再把这24位数据分成4组，即每组6位；再在每组的的最高位前补两个0凑足一个字节，这样就把一个3字节为一组的数据重新编码成了4个字节；当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节，这时在最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。例如：将对ABC进行Base64编码首先取ABC对应的ASCII码值，A : 65、B : 66、C : 67，再取二进制值A : 01000001、B : 01000010、C : 01000011，然后把这三个字节的二进制码接起来010000010100001001000011，再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值00010000、00010100、00001001、00000011；再把这4个字节数据转化成10进制数得16、20、19、3；最后根据Base64给出的64个基本字符表，查出对应的ASCII码字符Q、U、J、D，这里的值实际就是数据在字符表中的索引。解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。注：Base64字符表，包括大写A-Z小写a-z数字0-9和+以及/。Base64加密原则：6bit（原8bit）一个字节，不足的位数用0补齐，两个0用一个=表示。Base64加密特点： 数据加密之后，数据量会变大，变大1/3左右。 可进行反向解密。 编码后有个非常显著的特点，末尾有个=号。 其实Base64不算是加密，只是一种编码格式。 在iOS中Base64加解密使用方法介绍（本例使用系统API，仅支持iOS7及以后的系统版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/****************************Base64.m类实现文件内容****************************/+ (NSString *)base64EncodedStringWithData:(NSData *)data&#123; //判断是否传入需要加密数据参数 if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; //判断设备系统是否满足条件 if ([[[UIDevice currentDevice] systemVersion] doubleValue] &lt;= 6.9) &#123; return nil; &#125; //使用系统的API进行Base64加密操作 NSDataBase64EncodingOptions options; options = NSDataBase64EncodingEndLineWithLineFeed; return [data base64EncodedStringWithOptions:options];&#125;+ (NSData *)base64DecodeDataWithString:(NSString *)string&#123; //判断是否传入需要加密数据参数 if ((string == nil) || (string == NULL)) &#123; return nil; &#125; else if (![string isKindOfClass:[NSString class]]) &#123; return nil; &#125; //判断设备系统是否满足条件 if ([[[UIDevice currentDevice] systemVersion] doubleValue] &lt;= 6.9) &#123; return nil; &#125; //使用系统的API进行Base64解密操作 NSDataBase64DecodingOptions options; options = NSDataBase64DecodingIgnoreUnknownCharacters; return [[NSData alloc] initWithBase64EncodedString:string options:options];&#125;/*****************************************************************************///使用Base64文件进行Base64加密和解密/*********************************使用Base64类*********************************///使用Base64执行加密操作NSString *string = @\"abcdefghijklmnopqrstuvwxyz\";NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];NSString *encodeString = [Base64 base64EncodedStringWithData:data];NSLog(@\"encodeString : %@\", encodeString);//使用Base64执行解密操作NSString *decodeString = nil;NSData *decodeData = [Base64 base64DecodeDataWithString:encodeString];decodeString = [[NSString alloc] initWithData:decodeData encoding:NSUTF8StringEncoding];NSLog(@\"decodeString : %@\", decodeString);/******************************************************************************/ MD5加密（MD5是一种摘要，而非加密，只是经常与加密配合使用）MD5的全称是Message-DigestAlgorithm 5，Message-Digest泛指字节串(Message)的Hash变换，就是把一个任意长度的字节串变换成一定长的大整数。请注意我使用了字节串而不是字符串这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的字节串变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被”篡改”。举个例子，你将一段话写在一个叫readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的”抵赖”，这就是所谓的数字签名应用。MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的，用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并”不知道”用户的密码是什么。MD5加密大体都应用在：验证数据或文件一致性、数字签名、安全访问认证等等。大概可比喻为：人的指纹来理解。注：MD5加密是不可逆的，也就是说，MD5加密后是不能解密的，所谓的解密只是用大数据的”试用”，来测出结果的。MD5特点: 压缩性 : 任意长度的数据,算出的MD5值长度都是固定的。 容易计算 : 从原数据计算出MD5值很容易。 抗修改性 : 对原数据进行任何改动，哪怕只修改一个字节，所得到的MD5值都有很大区别。 弱抗碰撞 : 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 强抗碰撞 : 想找到两个不同数据，使他们具有相同的MD5值，是非常困难的。 在iOS中MD5加密和验签使用方法介绍 123456789101112131415161718192021222324252627282930313233343536373839/****************************MD5.m类实现文件内容****************************///对字符串数据进行MD5的签名+ (NSString *)md5SignWithString:(NSString *)string&#123; const char *object = [string UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(object,(CC_LONG)strlen(object),result); NSMutableString *hash = [NSMutableString string]; for (int i = 0; i &lt; 16; i ++) &#123; [hash appendFormat:@\"%02X\", result[i]]; &#125; return [hash lowercaseString];&#125;//对二进制数据进行MD5的签名+ (NSData *)md5SignWithData:(NSData *)data&#123; Byte byte[CC_MD5_DIGEST_LENGTH]; //定义一个字节数组来接收结果 CC_MD5((const void*)([data bytes]), (CC_LONG)[data length], byte); return [NSData dataWithBytes:byte length:CC_MD5_DIGEST_LENGTH];&#125;/******************************************************************************///使用MD5文件进行MD5加密和验签/*********************************使用MD5类*********************************///使用MD5执行加密操作NSString *string2 = @\"abcdefghijklmnopqrstuvwxyz\";NSString *encodeString2 = [MD5 md5SignWithString:string2];NSLog(@\"encodeString2 : %@\", encodeString2);//MD5为不可逆的操作，使用MD5执行验签操作NSString *verifyString2 = [MD5 md5SignWithString:string2];NSLog(@\"verifyString2 : %@\", verifyString2);if ([verifyString2 isEqualToString:encodeString2]) &#123; NSLog(@\"md5 verify sign success\");&#125; else &#123; NSLog(@\"md5 verify sign failed\");&#125;/******************************************************************************/ AES加密（对称加密的一种）高级加密标准Advanced Encryption Standard简称：AES，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。它是一种对称加密算法，这个标准也替代原先的DES标准，已经被多方分析且广为全世界所使用。AES设计有三个密钥长度:128、192、256位，相对而言，AES的128密钥比DES的56密钥强1021倍。AES算法主要包括三个方面：轮变化、圈数和密钥扩展。总体来说，AES作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活，在软件及硬件上都能快速地加解密且只需要很少的存储资源等优点。 AES加解密特点： AES强安全性、高性能、高效率、易用和灵活。 在软件及硬件上都能快速地加解密且只需要很少的存储资源。 AES加密需要的参数： 密钥长度（Key Size）AES算法下，key的长度有三种：128、192和256 bits。由于历史原因，JDK默认只支持不大于128 bits的密钥，而128 bits的key已能够满足商用安全需求。因此本例先使用AES-128。（Java使用大于128 bits的key方法在文末提及） 加密模式（Cipher Mode）AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。本例统一使用CBC模式。 填充方式（Padding）由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）在iOS SDK中提供了PKCS7Padding，而JDK则提供了PKCS5Padding。原则上PKCS5Padding限制了填充的Block Size为8 bytes，而Java实际上当块大于该值时，其PKCS5Padding与PKCS7Padding是相等的：每需要填充χ个字节，填充的值就是χ。 初始向量（Initialization Vector）使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等（AES的Block Size为128 bits），而两个平台的API文档均指明当不传入初始向量时，系统将默认使用一个全0的初始向量。有了上述的基础之后，可以开始分别在两个平台进行实现了。 在iOS中AES加解密的实现介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//需要导入：#import &lt;CommonCrypto/CommonCrypto.h&gt;库才能使用/** * AES128 + ECB + PKCS7 * @param data 要加密的原始数据 * @param key 加密 key * @return 加密后数据 */+ (NSData *)encryptData:(NSData *)data key:(NSData *)key&#123; //判断解密的流数据是否存在 if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([data length] &lt;= 0) &#123; return nil; &#125; //判断解密的Key是否存在 if ((key == nil) || (key == NULL)) &#123; return nil; &#125; else if (![key isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([key length] &lt;= 0) &#123; return nil; &#125; //setup key NSData *result = nil; unsigned char cKey[kCCKeySizeAES128]; bzero(cKey, sizeof(cKey)); [key getBytes:cKey length:kCCKeySizeAES128]; //setup output buffer size_t bufferSize = [data length] + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //do encrypt size_t encryptedSize = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionECBMode|kCCOptionPKCS7Padding, cKey, kCCKeySizeAES128, nil, [data bytes], [data length], buffer, bufferSize, &amp;encryptedSize); if (cryptStatus == kCCSuccess) &#123; result = [NSData dataWithBytesNoCopy:buffer length:encryptedSize]; &#125; else &#123; free(buffer); &#125; return result;&#125;/** * AES128 + ECB + PKCS7 * @param data 要解密的原始数据 * @param key 解密 key * @return 解密后数据 */+ (NSData *)decryptData:(NSData *)data key:(NSData *)key&#123; //判断解密的流数据是否存在 if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([data length] &lt;= 0) &#123; return nil; &#125; //判断解密的Key是否存在 if ((key == nil) || (key == NULL)) &#123; return nil; &#125; else if (![key isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([key length] &lt;= 0) &#123; return nil; &#125; //setup key NSData *result = nil; unsigned char cKey[kCCKeySizeAES128]; bzero(cKey, sizeof(cKey)); [key getBytes:cKey length:kCCKeySizeAES128]; //setup output buffer size_t bufferSize = [data length] + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //do decrypt size_t decryptedSize = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionECBMode|kCCOptionPKCS7Padding, cKey, kCCKeySizeAES128, nil, [data bytes], [data length], buffer, bufferSize, &amp;decryptedSize); if (cryptStatus == kCCSuccess) &#123; result = [NSData dataWithBytesNoCopy:buffer length:decryptedSize]; &#125; else &#123; free(buffer); &#125; return result;&#125; 在iOS中AES加解密使用方法介绍 123456789101112131415//使用AES执行加密操作NSString *aesKey = @\"a1b2c3d4e5f6g7h8\";NSString *string3 = @\"abcdefghijklmnopqrstuvwxyz\";NSData *keyData3 = [aesKey dataUsingEncoding:NSUTF8StringEncoding];NSData *sourceData3 = [string3 dataUsingEncoding:NSUTF8StringEncoding];NSData *encodeData3 = [AESEncrypt encryptData:sourceData3 key:keyData3];NSLog(@\"encodeData3 : %@\", encodeData3);//使用AES执行解密操作NSString *decodeString3 = nil;NSData *decodeData3 = [AESEncrypt decryptData:encodeData3 key:keyData3];decodeString3 = [[NSString alloc] initWithData:decodeData3 encoding:NSUTF8StringEncoding];NSLog(@\"decodeString3 : %@\", decodeString3); RSA加密（非对称加密的一种）RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要，对方收到信息后，用不同的密钥解密并可核对信息摘要。RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作，RSA是被研究得最广泛的公钥算法。RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。RSA加密大体都应用在：本地数据加密、网络传输数据加密、方法体和方法名高级混淆以及程序结构混排加密。例如：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取。 RSA的算法涉及三个参数，n、e1、e2。其中，n是两个大质数p、q的积，n的二进制表示时所占用的位数，就是所谓的密钥长度。e1和e2是一对相关的值，e1可以任意取，但要求e1与(p-1)(q-1)互质；再选择e2，要求(e2e1)mod((p-1)*(q-1))=1。(n，e1)，(n，e2)就是密钥对。其中(n，e1)为公钥，(n，e2)为私钥；RSA加解密的算法完全相同，公钥加密体制中，一般用公钥加密，私钥解密。假设A为明文，B为密文，则：A=B^e2 mod n；B=A^e1 mod n；e1和e2可以互换使用，即私钥加密，公钥解密，公式：A=B^e1 mod n；B=A^e2 mod n; RSA加解密特点： RSA密钥管理的方便，计算量很大速度相对比较慢。 RSA安全性很高，能够抵抗到目前为止已知的绝大多数密码攻击。在线生成RSA密钥对的网址：在线生成非对称加密公钥私钥对等，RSA密钥格式请使用PKCS#8格式。PKCS#1与PKCS#8的区别还待后续查阅资料，再进行补充记录。 在iOS中RSA加解密的实现介绍（支持密钥文件&lt;.pem&gt;和字符串密钥） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655/****************************RSAEncrypt.m类实现文件内容****************************/#pragma mark - Class Utils Method+ (BOOL)isEmptyKeyRef:(id)object&#123; if (object == nil) &#123; return YES; &#125; else if (object == NULL) &#123; return YES; &#125; else if (object == [NSNull null]) &#123; return YES; &#125; return NO;&#125;#pragma mark - Private Method+ (SecKeyRef)getPrivateKeyRefWithFilePath:(NSString *)filePath keyPassword:(NSString *)keyPassword&#123; //读取私钥证书文件的内容 NSData *certificateData = [NSData dataWithContentsOfFile:filePath]; if ((certificateData == nil) || (certificateData == NULL)) &#123; return nil; &#125; else if (![certificateData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([certificateData length] &lt;= 0) &#123; return nil; &#125; //拼接密码参数到字典中 NSString *passwordKey = (__bridge id)kSecImportExportPassphrase; NSString *passwordValue = [NSString stringWithFormat:@\"%@\",keyPassword]; if ((keyPassword == nil) || (keyPassword == NULL)) &#123; passwordValue = @\"\"; &#125; else if (![keyPassword isKindOfClass:[NSString class]]) &#123; passwordValue = @\"\"; &#125; else if ([keyPassword length] &lt;= 0) &#123; passwordValue = @\"\"; &#125; NSMutableDictionary *optionInfo = [[NSMutableDictionary alloc] init]; [optionInfo setObject:passwordValue forKey:passwordKey]; //获取私钥对象 SecKeyRef privateKeyRef = NULL; CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL); CFDataRef pkcs12Data = (__bridge CFDataRef)certificateData; CFDictionaryRef options = (__bridge CFDictionaryRef)optionInfo; OSStatus securityStatus = SecPKCS12Import(pkcs12Data, options, &amp;items); if (securityStatus == noErr &amp;&amp; CFArrayGetCount(items) &gt; 0) &#123; SecIdentityRef identity; const void *secpkey = kSecImportItemIdentity; CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0); identity = (SecIdentityRef)CFDictionaryGetValue(identityDict,secpkey); securityStatus = SecIdentityCopyPrivateKey(identity, &amp;privateKeyRef); if (securityStatus != noErr) &#123; privateKeyRef = NULL; &#125; &#125; CFRelease(items); return privateKeyRef;&#125;+ (SecKeyRef)privateKeyRefWithPrivateKey:(NSString *)privateKey&#123; //判断参数是否正确 if ((privateKey == nil) || (privateKey == NULL)) &#123; return nil; &#125; else if (![privateKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKey length] &lt;= 0) &#123; return nil; &#125; //解析私钥对象内容 NSString *pKey = [NSString stringWithFormat:@\"%@\",privateKey]; NSRange sposition = [pKey rangeOfString:@\"-----BEGIN RSA PRIVATE KEY-----\"]; NSRange eposition = [pKey rangeOfString:@\"-----END RSA PRIVATE KEY-----\"]; if (sposition.location != NSNotFound &amp;&amp; eposition.location != NSNotFound) &#123; NSUInteger endposition = eposition.location; NSUInteger startposition = sposition.location + sposition.length; NSRange range = NSMakeRange(startposition, endposition-startposition); pKey = [pKey substringWithRange:range]; &#125; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; //This will be base64 encoded, decode it. NSData *keyData = [Base64 base64DecodeDataWithString:pKey]; keyData = [self stripPrivateKeyHeader:keyData]; if ((keyData == nil) || (keyData == NULL)) &#123; return nil; &#125; else if (![keyData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([keyData length] &lt;= 0) &#123; return nil; &#125; //a tag to read/write keychain storage NSString *tag = @\"RSAUtil_PrivKey\"; const void *bytes = [tag UTF8String]; NSData *tagData = [NSData dataWithBytes:bytes length:[tag length]]; //Delete any old lingering key with the same tag NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init]; [attributes setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; [attributes setObject:tagData forKey:(__bridge id)kSecAttrApplicationTag]; SecItemDelete((__bridge CFDictionaryRef)attributes); //Add persistent version of the key to system keychain [attributes setObject:keyData forKey:(__bridge id)kSecValueData]; [attributes setObject:(__bridge id)kSecAttrKeyClassPrivate forKey:(__bridge id)kSecAttrKeyClass]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnPersistentRef]; OSStatus status = noErr; CFTypeRef persistKey = nil; status = SecItemAdd((__bridge CFDictionaryRef)attributes, &amp;persistKey); if (persistKey != nil) &#123;CFRelease(persistKey);&#125; if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) &#123; return nil; &#125; [attributes removeObjectForKey:(__bridge id)kSecValueData]; [attributes removeObjectForKey:(__bridge id)kSecReturnPersistentRef]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; //Now fetch the SecKeyRef version of the key SecKeyRef keyRef = nil; CFDictionaryRef query = (__bridge CFDictionaryRef)attributes; status = SecItemCopyMatching(query, (CFTypeRef *)&amp;keyRef); if (status != noErr) &#123; return nil; &#125; return keyRef;&#125;+ (NSData *)stripPrivateKeyHeader:(NSData *)d_key&#123; //Skip ASN.1 private key header if (d_key == nil) return nil; unsigned long len = [d_key length]; if (!len) return nil; unsigned char *c_key = (unsigned char *)[d_key bytes]; unsigned int idx = 22; //magic byte at offset 22 if (0x04 != c_key[idx++]) return nil; //calculate length of the key unsigned int c_len = c_key[idx++]; if (!(c_len &amp; 0x80)) &#123; c_len = c_len &amp; 0x7f; &#125; else &#123; int byteCount = c_len &amp; 0x7f; if (byteCount + idx &gt; len) &#123; //rsa length field longer than buffer return nil; &#125; unsigned int accum = 0; unsigned char *ptr = &amp;c_key[idx]; idx += byteCount; while (byteCount) &#123; accum = (accum &lt;&lt; 8) + *ptr; ptr++; byteCount--; &#125; c_len = accum; &#125; //Now make a new NSData from this buffer return [d_key subdataWithRange:NSMakeRange(idx, c_len)];&#125;+ (SecKeyRef)getPublicKeyRefWithFilePath:(NSString *)filePath&#123; //读取公钥证书文件的内容 NSData *certificateData = [NSData dataWithContentsOfFile:filePath]; if ((certificateData == nil) || (certificateData == NULL)) &#123; return nil; &#125; else if (![certificateData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([certificateData length] &lt;= 0) &#123; return nil; &#125; //将公钥证书制作成证书对象 CFDataRef data = (__bridge CFDataRef)certificateData; SecCertificateRef certificateRef = SecCertificateCreateWithData(NULL, data); //获取公钥对象 SecTrustRef trust = NULL; SecKeyRef publicKey = NULL; SecPolicyRef policies = SecPolicyCreateBasicX509(); if (![[self class] isEmptyKeyRef:(__bridge id)(certificateRef)] &amp;&amp; ![[self class] isEmptyKeyRef:(__bridge id)(policies)]) &#123; OSStatus status; status = SecTrustCreateWithCertificates((CFTypeRef)certificateRef, policies, &amp;trust); if (status == noErr) &#123; SecTrustResultType result; if (SecTrustEvaluate(trust, &amp;result) == noErr) &#123; publicKey = SecTrustCopyPublicKey(trust); &#125; &#125; &#125; if (certificateRef != NULL) CFRelease(certificateRef); if (policies != NULL) CFRelease(policies); if (trust != NULL) CFRelease(trust); return publicKey;&#125;+ (SecKeyRef)publicKeyRefWithPublicKey:(NSString *)publicKey&#123; //判断参数是否正确 if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //解析公钥对象内容 NSString *pKey = [NSString stringWithFormat:@\"%@\",publicKey]; NSRange sposition = [pKey rangeOfString:@\"-----BEGIN PUBLIC KEY-----\"]; NSRange eposition = [pKey rangeOfString:@\"-----END PUBLIC KEY-----\"]; if (sposition.location != NSNotFound &amp;&amp; eposition.location != NSNotFound) &#123; NSUInteger startposition = eposition.location; NSUInteger endposition = sposition.location + sposition.length; NSRange range = NSMakeRange(endposition, startposition-endposition); pKey = [pKey substringWithRange:range]; &#125; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; //This will be base64 encoded, decode it. NSData *keyData = [[self class] base64DecodeDataWithString:pKey]; keyData = [self stripPublicKeyHeader:keyData]; if ((keyData == nil) || (keyData == NULL)) &#123; return nil; &#125; else if (![keyData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([keyData length] &lt;= 0) &#123; return nil; &#125; //a tag to read/write keychain storage NSString *tag = @\"RSAUtil_PubKey\"; const void *bytes = [tag UTF8String]; NSData *tagData = [NSData dataWithBytes:bytes length:[tag length]]; //Delete any old lingering key with the same tag NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init]; [attributes setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; [attributes setObject:tagData forKey:(__bridge id)kSecAttrApplicationTag]; SecItemDelete((__bridge CFDictionaryRef)attributes); //Add persistent version of the key to system keychain [attributes setObject:keyData forKey:(__bridge id)kSecValueData]; [attributes setObject:(__bridge id)kSecAttrKeyClassPublic forKey:(__bridge id)kSecAttrKeyClass]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnPersistentRef]; OSStatus status = noErr; CFTypeRef persistKey = nil; status = SecItemAdd((__bridge CFDictionaryRef)attributes, &amp;persistKey); if (persistKey != nil) CFRelease(persistKey); if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) &#123; return nil; &#125; [attributes removeObjectForKey:(__bridge id)kSecValueData]; [attributes removeObjectForKey:(__bridge id)kSecReturnPersistentRef]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; //Now fetch the SecKeyRef version of the key SecKeyRef publicKeyRef = nil; CFDictionaryRef query = (__bridge CFDictionaryRef)attributes; status = SecItemCopyMatching(query, (CFTypeRef *)&amp;publicKeyRef); if (status != noErr) &#123; return nil; &#125; return publicKeyRef;&#125;+ (NSData *)stripPublicKeyHeader:(NSData *)d_key&#123; //Skip ASN.1 public key header if (d_key == nil) &#123;return nil;&#125; unsigned long len = [d_key length]; if (!len) return(nil); unsigned char *c_key = (unsigned char *)[d_key bytes]; unsigned int idx = 0; if (c_key[idx++] != 0x30) &#123;return nil;&#125; if (c_key[idx] &gt; 0x80) &#123; idx += c_key[idx] - 0x80 + 1; &#125; else &#123; idx++; &#125; //PKCS #1 rsaEncryption szOID_RSA_RSA static unsigned char seqiod[] = &#123;0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00&#125;; if (memcmp(&amp;c_key[idx], seqiod, 15)) &#123;return nil;&#125; idx += 15; if (c_key[idx++] != 0x03) &#123;return nil;&#125; if (c_key[idx] &gt; 0x80) &#123; idx += c_key[idx] - 0x80 + 1; &#125; else &#123; idx ++; &#125; if (c_key[idx++] != '\\0') &#123;return nil;&#125; //Now make a new NSData from this buffer return ([NSData dataWithBytes:&amp;c_key[idx] length:len - idx]);&#125;+ (NSData *)encryptData:(NSData *)data withKeyRef:(SecKeyRef)keyRef&#123; const uint8_t *srcbuf = (const uint8_t *)[data bytes]; size_t srclen = (size_t)data.length; size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t); void *outbuf = malloc(block_size); size_t src_block_size = block_size - 11; NSMutableData *ret = [[NSMutableData alloc] init]; for (int idx = 0; idx &lt; srclen; idx += src_block_size) &#123; size_t data_len = srclen - idx; if(data_len &gt; src_block_size)&#123; data_len = src_block_size; &#125; size_t outlen = block_size; OSStatus status = noErr; status = SecKeyEncrypt(keyRef, kSecPaddingPKCS1, srcbuf + idx, data_len, outbuf, &amp;outlen); if (status != 0) &#123; NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", (int)status); ret = nil; break; &#125; else &#123; [ret appendBytes:outbuf length:outlen]; &#125; &#125; free(outbuf); CFRelease(keyRef); return ret;&#125;+ (NSData *)decryptData:(NSData *)data withKeyRef:(SecKeyRef)keyRef&#123; const uint8_t *srcbuf = (const uint8_t *)[data bytes]; size_t srclen = (size_t)data.length; size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t); UInt8 *outbuf = malloc(block_size); size_t src_block_size = block_size; NSMutableData *ret = [[NSMutableData alloc] init]; for (int idx = 0; idx &lt; srclen; idx += src_block_size) &#123; size_t data_len = srclen - idx; if(data_len &gt; src_block_size) &#123; data_len = src_block_size; &#125; size_t outlen = block_size; OSStatus status = noErr; status = SecKeyDecrypt(keyRef, kSecPaddingNone, srcbuf + idx, data_len, outbuf, &amp;outlen); if (status != 0) &#123; NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", (int)status); ret = nil; break; &#125; else &#123; int idxFirstZero = -1; int idxNextZero = (int)outlen; for (int i = 0; i &lt; outlen; i ++) &#123; if (outbuf[i] == 0) &#123; if (idxFirstZero &lt; 0) &#123; idxFirstZero = i; &#125; else &#123; idxNextZero = i; break; &#125; &#125; &#125; NSUInteger length = idxNextZero-idxFirstZero-1; [ret appendBytes:&amp;outbuf[idxFirstZero+1] length:length]; &#125; &#125; free(outbuf); CFRelease(keyRef); return ret;&#125;#pragma mark - RSA Key File Encrypt/Decrypt Public Method+ (NSString *)encryptString:(NSString *)originString publicKeyPath:(NSString *)publicKeyPath&#123; //判断originString参数是否正确 if ((originString == nil) || (originString == NULL)) &#123; return nil; &#125; else if (![originString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([originString length] &lt;= 0) &#123; return nil; &#125; //判断publicKeyPath参数是否正确 if ((publicKeyPath == nil) || (publicKeyPath == NULL)) &#123; return nil; &#125; else if (![publicKeyPath isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKeyPath length] &lt;= 0) &#123; return nil; &#125; //获取公钥对象和需要加密的字符串内容编码数据流 SecKeyRef publicKeyRef = [self getPublicKeyRefWithFilePath:publicKeyPath]; NSData *originData = [originString dataUsingEncoding:NSUTF8StringEncoding]; if ([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)]) &#123; return nil; &#125; if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; //加密源字符串内容编码数据流的数据 NSData *resultData = nil; resultData = [self encryptData:originData withKeyRef:publicKeyRef]; return [[self class] base64EncodedStringWithData:resultData];&#125;+ (NSString *)decryptString:(NSString *)encryptString privateKeyPath:(NSString *)privateKeyPath privateKeyPwd:(NSString *)privateKeyPwd&#123; //判断encryptString参数是否正确 if ((encryptString == nil) || (encryptString == NULL)) &#123; return nil; &#125; else if (![encryptString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([encryptString length] &lt;= 0) &#123; return nil; &#125; //判断publicKeyPath参数是否正确 if ((privateKeyPath == nil) || (privateKeyPath == NULL)) &#123; return nil; &#125; else if (![privateKeyPath isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKeyPath length] &lt;= 0) &#123; return nil; &#125; //判断密码是否存在 NSString *keyPassword = [NSString stringWithFormat:@\"%@\",privateKeyPwd]; if ((privateKeyPwd == nil) || (privateKeyPwd == NULL)) &#123; keyPassword = @\"\"; &#125; else if (![privateKeyPwd isKindOfClass:[NSString class]]) &#123; keyPassword = @\"\"; &#125; else if ([privateKeyPwd length] &lt;= 0) &#123; keyPassword = @\"\"; &#125; //获取私钥对象和需要加密的字符串内容编码数据流 NSData *encryptData = nil, *decryptData = nil; SecKeyRef privateKeyRef = [self getPrivateKeyRefWithFilePath:privateKeyPath keyPassword:privateKeyPwd]; encryptData = [[self class] base64DecodeDataWithString:encryptString]; if ([[self class] isEmptyKeyRef:(__bridge id)(privateKeyRef)]) &#123; return nil; &#125; if ((encryptData == nil) || (encryptData == NULL)) &#123; return nil; &#125; else if (![encryptData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([encryptData length] &lt;= 0) &#123; return nil; &#125; NSStringEncoding encoding = NSUTF8StringEncoding; decryptData = [self decryptData:encryptData withKeyRef:privateKeyRef]; return [[NSString alloc] initWithData:decryptData encoding:encoding];&#125;#pragma mark - RSA Key String Encrypt/Decrypt Public Method+ (NSData *)encryptData:(NSData *)originData publicKey:(NSString *)publicKey&#123; //判断originData参数是否正确 if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; //判断publicKeyPath参数是否正确 if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //获取需要加密的字符串内容编码数据流 SecKeyRef publicKeyRef = [self publicKeyRefWithPublicKey:publicKey]; if([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)])&#123; return nil; &#125; return [self encryptData:originData withKeyRef:publicKeyRef];&#125;+ (NSString *)encryptString:(NSString *)originString publicKey:(NSString *)publicKey&#123; //判断publicKey参数是否正确 if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //判断originString参数是否正确 if ((originString == nil) || (originString == NULL)) &#123; return nil; &#125; else if (![originString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([originString length] &lt;= 0) &#123; return nil; &#125; //获取需要加密的字符串内容编码数据流 NSData *originData = nil, *encryptData = nil; SecKeyRef publicKeyRef = [self publicKeyRefWithPublicKey:publicKey]; originData = [originString dataUsingEncoding:NSUTF8StringEncoding]; if([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)])&#123; return nil; &#125; if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; encryptData = [self encryptData:originData withKeyRef:publicKeyRef]; return [[self class] base64EncodedStringWithData:encryptData];&#125;+ (NSString *)decryptString:(NSString *)encryptString privateKey:(NSString *)privateKey&#123; //判断publicKey参数是否正确 if ((privateKey == nil) || (privateKey == NULL)) &#123; return nil; &#125; else if (![privateKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKey length] &lt;= 0) &#123; return nil; &#125; //判断originString参数是否正确 if ((encryptString == nil) || (encryptString == NULL)) &#123; return nil; &#125; else if (![encryptString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([encryptString length] &lt;= 0) &#123; return nil; &#125; //获取私钥对象和需要加密的字符串内容编码数据流 SecKeyRef privateKeyRef; NSData *encryptData = nil, *decryptData = nil; privateKeyRef = [[self class] privateKeyRefWithPrivateKey:privateKey]; encryptData = [[self class] base64DecodeDataWithString:encryptString]; if ([[self class] isEmptyKeyRef:(__bridge id)(privateKeyRef)]) &#123; return nil; &#125; if ((encryptData == nil) || (encryptData == NULL)) &#123; return nil; &#125; else if (![encryptData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([encryptData length] &lt;= 0) &#123; return nil; &#125; NSStringEncoding encoding = NSUTF8StringEncoding; decryptData = [self decryptData:encryptData withKeyRef:privateKeyRef]; return [[NSString alloc] initWithData:decryptData encoding:encoding];&#125;/******************************************************************************/ 在iOS中RSA加解密使用方法介绍（RSA密钥格式请使用PKCS#8格式） 12345678910//使用RSA执行加密操作NSString *string4 = @\"abcdefghijklmnopqrstuvwxyz\";NSString *encodeString4 = [RSAEncrypt encryptString:string4 publicKey:mPublicKey];NSLog(@\"encodeString4 : %@\", encodeString4);//使用RSA执行解密操作NSString *decodeString4 = [RSAEncrypt decryptString:encodeString4 privateKey:mPrivateKey];NSLog(@\"decodeString4 : %@\", decodeString4);","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"Encryption","slug":"Encryption","permalink":"http://yoursite.com/tags/Encryption/"}]},{"title":"AFNetWorking原理(二) AFSecurityPolicy","slug":"AFNetWorking原理二","date":"2019-06-25T03:31:07.000Z","updated":"2019-06-25T10:49:12.251Z","comments":true,"path":"2019/06/25/AFNetWorking原理二/","link":"","permalink":"http://yoursite.com/2019/06/25/AFNetWorking原理二/","excerpt":"AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。","text":"AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。 AFSecurityPolicy 的校验选项 AFSSLPinningMode 有三种： AFSSLPinningModeNone 在与服务器建立安全连接时，并不会使用应用中已有的证书（也可能本就没有）对服务器传递的信息进行校验，此为默认选项 AFSSLPinningModePublicKey 使用应用中已有的公钥对服务器传递的信息进行校验 AFSSLPinningModeCertificate 使用应用中已有的数字证书对服务器传递的信息进行校验 HTPPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。 HTTPS连接建立 非对称加密、对称加密：客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有（各个受信任的证书机构）根证书，用这些根证书对服务端返回的证书进行验证，经验证如果证书（服务端返回的证书）是可信任的，就生成一个pre-master secret，用这个证书（服务端返回的证书）的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master secret，客户端也同样根据这种算法从pre-master secret生成master secret（非对称加密），随后双方的通信都用这个master secret对传输数据进行加密解密（对称加密）。 非对称加密： d(c(x))=x HTTP和HTTPS区别超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下四点： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 SSLSSL(Secure Sockets Layer安全套接层),及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL (Secure Socket Layer)为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。 SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。 SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 SSL协议提供的服务主要有哪些 认证用户和服务器，确保数据发送到正确的客户机和服务器 加密数据以防止数据中途被窃取 维护数据的完整性，确保数据在传输过程中不被改变。 SSL协议的工作流程 服务器认证阶段：客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 从SSL 协议所提供的服务及其工作流程可以看出，SSL协议运行的基础是商家对消费者信息保密的承诺，这就有利于商家而不利于消费者。在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。但随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的单一认证问题就越来越突出。虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务器双方的身份验证，但是SSL协议仍存在一些问题，比如，只能提供交易中客户与服务器间的双方认证，在涉及多方的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。在这种情况下，Visa和MasterCard两大信用卡公组织制定了SET协议，为网上信用卡支付提供了全球性的标准。 SSL协议加密方式SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。 对称加密速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 SSL证书包含的信息 证书版本号，不同版本的证书格式不同 Serial Number 序列号，同一身份验证机构签发的证书序列号唯一 Algorithm Identifier 签名算法，包括必要的参数Issuer 身份验证机构的标识信息 Period of Validity 有效期 Subject 证书持有人的标识信息 Subject’s Public Key 证书持有人的公钥 Signature 身份验证机构对证书的签名 证书的格式 认证中心所发放的证书均遵循X.509 V3 标准，其基本格式如下： 证书版本号（Certificate Format Version）含义：用来指定证书格式采用的X.509 版本号。 证书序列号（Certificate Serial Number）含义：用来指定证书的唯一序列号，以标识CA 发出的所有公钥证书。 签名（Signature）算法标识（Algorithm Identifier）含义：用来指定 CA 签发证书所用的签名算法。 签发此证书的 CA 名称（Issuer ）含义：用来指定签发证书的 CA 的X.500 唯一名称（DN，Distinguished Name）。 证书有效期（Validity Period）起始日期（notBefore） 终止日期（notAfter）含义：用来指定证书起始日期和终止日期。 用户名称（Subject）含义：用来指定证书用户的X.500 唯一名称（DN，Distinguished Name）。 用户公钥信息（Subject Public Key Information）算法（algorithm） 算法标识（Algorithm Identifier）用户公钥（subject Public Key）含义：用来标识公钥使用的算法，并包含公钥本身。 证书扩充部分（扩展域）（Extensions）含义：用来指定额外信息。 X.509 V3 证书的扩充部分（扩展域）及实现方法如下： CA 的公钥标识（Authority Key Identifier） 公钥标识（SET 未使用）（Key Identifier） 签发证书者证书的签发者的甄别名（Certificate Issuer） 签发证书者证书的序列号（Certificate Serial Number） X.509 V3 证书的扩充部分（扩展域）及实现CA 的公钥标识（Authority Key Identifier） 公钥标识（SET 未使用）（Key Identifier） 签发证书者证书的签发者的甄别名（Certificat签发证书者证书的序列号（Certificate Serial Number）含义：CA 签名证书所用的密钥对的唯一标识用户的公钥标识（Subject Key Identifier）含义：用来标识与证书中公钥相关的特定密钥进行解密。 证书中的公钥用途（Key Usage）含义：用来指定公钥用途。 用户的私钥有效期（Private Key Usage Period）起始日期（Note Before） 终止日期（Note After）含义：用来指定用户签名私钥的起始日期和终止日期。 CA 承认的证书政策列表（Certificate Policies）含义：用来指定用户证书所适用的政策，证书政策可由对象标识符表示。 用户的代用名（Substitutional Name）含义：用来指定用户的代用名。 CA 的代用名（Issuer Alt Name）含义：用来指定 CA 的代用名。 基本制约（Basic Constraints）含义：用来表明证书用户是最终用户还是CA。 在SET 系统中有一些私有扩充部分（扩展域）Hashed Root Key 含义：只在根证书中使用，用于证书更新时进行回溯。 证书类型（Certificate Type）含义：用来区别不同的实体。该项是必选的。 商户数据（Merchant Data）含义：包含支付网关需要的所有商户信息。 持卡人证书需求（Card Cert Required）含义：显示支付网关是否支持与没有证书的持卡人进行交易。 SET 扩展（SETExtensions）含义：列出支付网关支持的支付命令的 SET 信息扩展。 CRL 数据定义版本（Version）含义：显示 CRL 的版本号。 CRL 的签发者（Issuer）含义：指明签发 CRL 的CA 的甄别名。 CRL 发布时间（this Update）预计下一个 CRL 更新时间（Next Update）撤销证书信息目录（Revoked Certificates）CRL 扩展（CRL Extension）CA 的公钥标识（Authority Key Identifier）CRL 号（CRL Number） SSL证书种类：CFCA，GlobalSign，VeriSign ，Geotrust ，Thawte。 域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站； 企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高； 增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。 握手过程为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下： 客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。 服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 HTTPS的认证过程单向认证Https在建立Socket连接之前，需要进行握手，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 服务器将选择好的加密方案通过明文方式返回给客户端 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 验证客户端的证书，通过验证后，会获得客户端的公钥 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 AFSecurityPolicy和认证认证过程和原理AFN是靠着AFSecurityPolicy这个类保证数据安全的，调用下面方法用来验证是否信任服务器。 1[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host] 看一下AFN中的接口 123456789101112131415161718192021/*! @typedef SecTrustRef @abstract CFType used for performing X.509 certificate trust evaluations. // 执行X.509证书信任评估，其实就是一个容器，装了服务器端需要验证的证书的基本信息、 公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书， 这个客户端的证书，可以用来和服务端的证书去匹配验证的 */typedef struct CF_BRIDGED_TYPE(id) __SecTrust *SecTrustRef;/** Whether or not the specified server trust should be accepted, based on the security policy. This method should be used when responding to an authentication challenge from a server. @param serverTrust The X.509 certificate trust of the server. @param domain The domain of serverTrust. If `nil`, the domain will not be validated. // 服务器域名 @return Whether or not to trust the server. */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain; 根据安全策略是否接受指定的服务器信任。 响应来自服务器的身份验证质询时应使用此方法。 大家还记得这个代理方法吗？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; //挑战处理类型为 默认 /* NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理 NSURLSessionAuthChallengeUseCredential：使用指定的证书 NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战 */ NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; // sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战 if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; // 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust // 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。 // 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象 if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; // 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战 if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; // 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书） credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; // 确定挑战的方式 if (credential) &#123; //证书挑战 设计policy,none，则跑到这里 disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; //取消挑战 disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; //默认挑战方式 disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; //完成挑战 if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; 这个方法是如何进行接受挑战的 首先指定了HTTPS为默认的认证方式。 判断有没有自定义Block:sessionDidReceiveAuthenticationChallenge，有的话，使用我们自定义Block,生成一个认证方式，并且可以给credential赋值，即我们需要接受认证的证书。然后直接调用completionHandler，去根据这两个参数，执行系统的认证。 如果没有自定义Block，我们判断如果服务端的认证方法要求是NSURLAuthenticationMethodServerTrust，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现） 接着我们就执行了AFSecurityPolicy相关的上面的方法- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain，关于这个方法，AF默认的处理是，如果这行返回NO、说明AF内部认证失败，则取消HTTPS认证，即取消请求。返回YES则进入if块，用服务器返回的一个serverTrust去生成了一个认证证书。（注：这个serverTrust是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。最后调用completionHandler传递认证方式和要认证的证书，去做系统根证书验证。也可以这么理解：这里securityPolicy存在的作用就是，使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。如果通不过，则直接越过系统的验证，取消HTTPS的网络请求。否则，继续去走系统根证书的验证。 AFSecurityPolicy实例化先看一下该类的实例化 12345678AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125; 这里有一个很重要的属性就是SSLPinningMode，先看一下这个枚举 12345typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, //不验证 AFSSLPinningModePublicKey, //只验证公钥 AFSSLPinningModeCertificate, // 验证证书&#125;; 下面我们看一下类AFSecurityPolicy的几个属性 123456789101112131415161718192021222324252627/** The criteria by which server trust should be evaluated against the pinned SSL certificates. Defaults to `AFSSLPinningModeNone`. */// 验证模式 这个枚举值上面讲述过@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;/** The certificates used to evaluate server trust according to the SSL pinning mode. By default, this property is set to any (`.cer`) certificates included in the target compiling AFNetworking. Note that if you are using AFNetworking as embedded framework, no certificates will be pinned by default. Use `certificatesInBundle` to load certificates from your target, and then create a new policy by calling `policyWithPinningMode:withPinnedCertificates`. Note that if pinning is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches. */// 可以去匹配服务端证书验证的证书@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;/** Whether or not to trust servers with an invalid or expired SSL certificates. Defaults to `NO`. */// 是否支持非法的证书（例如自签名证书）@property (nonatomic, assign) BOOL allowInvalidCertificates;/** Whether or not to validate the domain name in the certificate's CN field. Defaults to `YES`. */// 是否去验证证书域名是否匹配@property (nonatomic, assign) BOOL validatesDomainName; AFNetWorking HTTPS请求示例自签名证书我们手动指定securityPolicy认证属性。通过12306证书来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//自建证书认证- (IBAction)buttion1:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://kyfw.12306.cn/otn/leftTicket/init\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // [request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定安全策略 manager.securityPolicy = [self ticketSecurityPolicy]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/** 12306的认证证书，他的认证证书是自签名的 @return 返回指定的认证策略 */-(AFSecurityPolicy*)ticketSecurityPolicy &#123; // /先导入证书 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"12306\" ofType:@\"cer\"];//证书的路径 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; &#125; // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO // 如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = YES; //validatesDomainName 是否需要验证域名，默认为YES； //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。 //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。 //如置为NO，建议自己添加对应域名的校验逻辑。 securityPolicy.validatesDomainName = NO; return securityPolicy;&#125; SSL信任证书我们手动指定securityPolicy认证属性。通过百度证书来实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//认证证书认证- (IBAction)button2:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.baidu.com\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //[request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定安全策略 manager.securityPolicy = [self baiduSecurityPolicy]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/**百度的的认证证书，他的认证证书是花钱买的，也就是不是自签名的证书。这种证书，如果我们要手动指定，pinmode只能是`AFSSLPinningModeNone` @return 返回指定的认证策略 */-(AFSecurityPolicy*)baiduSecurityPolicy &#123; // /先导入证书 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"baidu\" ofType:@\"cer\"];//证书的路径 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; //这里只能用AFSSLPinningModeNone才能成功，而且我系统的证书列表里面已经有百度的证书了 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone]; &#125; // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO // 如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = NO; //validatesDomainName 是否需要验证域名，默认为YES； //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。 //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。 //如置为NO，建议自己添加对应域名的校验逻辑。 securityPolicy.validatesDomainName = YES; return securityPolicy;&#125; SSL证书AFN默认处理这里我们不做任何额外的处理，直接使用AFN的默认证书处理机制。通过AFURLSessionManager的securityPolicy默认实现。它会和存在系统中的做对比来验证证书。 1234567891011121314//系统证书认证- (IBAction)button3:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.apple.com/\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125; AFSecurityPolicy源码解析AFSecurityPolicy分三种验证模式 AFSSLPinningModeNone:这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。 AFSSLPinningModeCertificate:这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。这里还没弄明白第一步的验证是怎么进行的，代码上跟去系统信任机构列表里验证一样调用了SecTrustEvaluate，只是这里的列表换成了客户端保存的那些证书列表。若要验证这个，是否应该把服务端证书的颁发机构根证书也放到客户端里？ AFSSLPinningModePublicKey:这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。 SecTrustRef这是一个需要验证的信任对象,包含待验证的证书和支持的验证方法等。 SecTrustResultType表示验证结果。其中 kSecTrustResultProceed表示serverTrust验证成功，且该验证得到了用户认可(例如在弹出的是否信任的alert框中选择always trust)。 kSecTrustResultUnspecified表示 serverTrust验证成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书。 两者取其一就可以认为对serverTrust验证成功。 SecTrustEvaluate证书校验函数,在函数的内部递归地从叶节点证书到根证书验证。需要验证证书本身的合法性（验证签名完整性，验证证书有效期等);验证证书颁发者的合法性（查找颁发者的证书并检查其合法性，这个过程是递归的).而递归的终止条件是证书验证过程中遇到了锚点证书(锚点证书:嵌入到操作系统中的根证书,这个根证书是权威证书颁发机构颁发的自签名证书)。 AFSecurityPolicy的源码细节如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383/** 证书的验证类型 - AFSSLPinningModeNone: 不使用`pinned certificates`来验证证书 - AFSSLPinningModePublicKey: 使用`pinned certificates`来验证证书的公钥 - AFSSLPinningModeCertificate: 使用`pinned certificates`来验证整个证书 */typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate,&#125;;/** 获取指定证书的公钥 @param certificate 证书数据 @return 公钥 */static id AFPublicKeyForCertificate(NSData *certificate) &#123; id allowedPublicKey = nil; SecCertificateRef allowedCertificate; SecPolicyRef policy = nil; SecTrustRef allowedTrust = nil; SecTrustResultType result; //获取证书对象 allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate); __Require_Quiet(allowedCertificate != NULL, _out); //获取X.509的认证策略 policy = SecPolicyCreateBasicX509(); //获取allowedTrust对象的值 __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _out); __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out); //根据allowedTrust获取对应的公钥 allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);//C++的gumpto跳转，当前面的操作出错以后，直接跳入_out执行_out: if (allowedTrust) &#123; CFRelease(allowedTrust); &#125; if (policy) &#123; CFRelease(policy); &#125; if (allowedCertificate) &#123; CFRelease(allowedCertificate); &#125; //返回公钥 return allowedPublicKey;&#125;/** 在指定的证书和认证策略下，验证SecTrustRef对象是否是受信任的、合法的。 @param serverTrust SecTrustRef对象 @return 结果 */static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; //获取serverTrust的认证结果，调用`SecTrustEvaluate`表示通过系统的证书来比较认证 __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125;/** 根据`serverTrust`获取认证的证书链 @param serverTrust serverTrust对象 @return 认证证书链 */static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //获取认证链的总层次 CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; //获取每一级认证链，把获取的证书数据存入数组中 for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)]; &#125; //返回证书链数组 return [NSArray arrayWithArray:trustChain];&#125;/** 获取serverTrust对象的认证链的公钥数组 @param serverTrust serverTrust对象 @return 公钥数组 */static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //X.509标准的安全策略 SecPolicyRef policy = SecPolicyCreateBasicX509(); //获取证书链的证书数量 CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); SecCertificateRef someCertificates[] = &#123;certificate&#125;; CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL); SecTrustRef trust; //通过一个证书、认证策略新建一个SecTrustRef对象 __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _out); SecTrustResultType result; //验证SecTrustRef对象是否成功 __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _out); //把SecTrustRef对应的公钥加入数组中 [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)]; _out: if (trust) &#123; CFRelease(trust); &#125; if (certificates) &#123; CFRelease(certificates); &#125; continue; &#125; CFRelease(policy); return [NSArray arrayWithArray:trustChain];&#125;#pragma mark -@interface AFSecurityPolicy()//认证策略@property (readwrite, nonatomic, assign) AFSSLPinningMode SSLPinningMode;//公钥集合@property (readwrite, nonatomic, strong) NSSet *pinnedPublicKeys;@end@implementation AFSecurityPolicy/** 从MainBundle中获取所有证书 @param bundle 返回包含在bundle中的证书集合。如果AFNetworking使用的是静态库，我们必须通过这个方法来加载证书。并且通过`policyWithPinningMode:withPinnedCertificates`方法来指定认证类型。 @return 返回bundle里面的证书 */+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123; //获取项目里的所有.cer证书 NSArray *paths = [bundle pathsForResourcesOfType:@\"cer\" inDirectory:@\".\"]; NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]]; for (NSString *path in paths) &#123; //获取证书对应的NSData，并且加入集合中 NSData *certificateData = [NSData dataWithContentsOfFile:path]; [certificates addObject:certificateData]; &#125; //返回证书集合 return [NSSet setWithSet:certificates];&#125;/** 返回当前类所在bundle所在的证书集合 @return 证书集合 */+ (NSSet *)defaultPinnedCertificates &#123; static NSSet *_defaultPinnedCertificates = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //获取当前类所在bundle NSBundle *bundle = [NSBundle bundleForClass:[self class]]; _defaultPinnedCertificates = [self certificatesInBundle:bundle]; &#125;); return _defaultPinnedCertificates;&#125;/** 返回默认的安全认证策略,在这里是验证系统的证书。这个策略不允许非法证书、验证主机名、不验证证书内容和公钥 @return 返回认证策略 */+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125;/** 根据指定的认证策略和默认的证书列表初始化一个`AFSecurityPolicy`对象 @param pinningMode 认证策略 @return `AFSecurityPolicy`对象 */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123; return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];&#125;/** 通过制定的认证策略`pinningMode`和证书集合`pinnedCertificates`来初始化一个`AFSecurityPolicy`对象 @param pinningMode 认证模型 @param pinnedCertificates 证书集合 @return AFSecurityPolicy对象 */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = pinningMode; //设置`_pinnedCertificates`和`pinnedPublicKeys`属性，分别对应证书集合和公钥集合 [securityPolicy setPinnedCertificates:pinnedCertificates]; //返回初始化成功的`AFSecurityPolicy` return securityPolicy;&#125;- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; //默认是要认证主机名称 self.validatesDomainName = YES; return self;&#125;/**通过指定的证书结合获取到对应的公钥集合。然后赋值给`pinnedPublicKeys`属性 @param pinnedCertificates 证书集合 */- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123; _pinnedCertificates = pinnedCertificates; if (self.pinnedCertificates) &#123; NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]]; //迭代每一个证书 for (NSData *certificate in self.pinnedCertificates) &#123; //获取证书对应的公钥 id publicKey = AFPublicKeyForCertificate(certificate); if (!publicKey) &#123; continue; &#125; [mutablePinnedPublicKeys addObject:publicKey]; &#125; //赋值给对应的属性 self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys]; &#125; else &#123; self.pinnedPublicKeys = nil; &#125;&#125;#pragma mark -/** 为serverTrust对象指定认证策略，如果domain不为nil,则包括对主机名的认证。这个方法必须在接受到`authentication challenge`返回的时候调用。 SecTrustRef可以理解为桥接证书与认证策略的对象，他关联指定的证书与认证策略 @param serverTrust 服务器的X.509标准的证书数据 @param domain 认证服务器的主机名。如果是nil,则不会对主机名进行认证。 @return serverTrust是否通过认证 */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // \"Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors.\" NSLog(@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\"); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; //使用需要认证主机名的认证策略 [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; //使用默认的认证策略 [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; //给serverTrust对象指定认证策略 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; return NO; &#125; //根据证书验证策略、数字签名认证策略、其他认证策略来处理不同情况 switch (self.SSLPinningMode) &#123; case AFSSLPinningModeNone://不验证公钥和证书 default: return NO; case AFSSLPinningModeCertificate: &#123;//验证整个证书 NSMutableArray *pinnedCertificates = [NSMutableArray array]; //根据指定证书获取，获取对应的证书对象 for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; //把证书与serverTrust关联起来 SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA) //获取serverTrust证书链。直到根证书。 NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); //如果`pinnedCertificates`包含`serverTrust`对象对应的证书链的根证书。则返回true for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; return YES; &#125; &#125; return NO; &#125; case AFSSLPinningModePublicKey: &#123;//只验证证书里面的数字签名 NSUInteger trustedPublicKeyCount = 0; //根据serverTrust对象和SecPolicyCreateBasicX509认证策略，获取对应的公钥集合 NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); for (id trustChainPublicKey in publicKeys) &#123; //把获取的公钥和系统获取的默认公钥比较，如果相等，则通过认证 for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125;#pragma mark - NSKeyValueObserving+ (NSSet *)keyPathsForValuesAffectingPinnedPublicKeys &#123; return [NSSet setWithObject:@\"pinnedCertificates\"];&#125;#pragma mark - NSSecureCoding+ (BOOL)supportsSecureCoding &#123; return YES;&#125;- (instancetype)initWithCoder:(NSCoder *)decoder &#123; self = [self init]; if (!self) &#123; return nil; &#125; self.SSLPinningMode = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(SSLPinningMode))] unsignedIntegerValue]; self.allowInvalidCertificates = [decoder decodeBoolForKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; self.validatesDomainName = [decoder decodeBoolForKey:NSStringFromSelector(@selector(validatesDomainName))]; self.pinnedCertificates = [decoder decodeObjectOfClass:[NSArray class] forKey:NSStringFromSelector(@selector(pinnedCertificates))]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder &#123; [coder encodeObject:[NSNumber numberWithUnsignedInteger:self.SSLPinningMode] forKey:NSStringFromSelector(@selector(SSLPinningMode))]; [coder encodeBool:self.allowInvalidCertificates forKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; [coder encodeBool:self.validatesDomainName forKey:NSStringFromSelector(@selector(validatesDomainName))]; [coder encodeObject:self.pinnedCertificates forKey:NSStringFromSelector(@selector(pinnedCertificates))];&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFSecurityPolicy *securityPolicy = [[[self class] allocWithZone:zone] init]; securityPolicy.SSLPinningMode = self.SSLPinningMode; securityPolicy.allowInvalidCertificates = self.allowInvalidCertificates; securityPolicy.validatesDomainName = self.validatesDomainName; securityPolicy.pinnedCertificates = [self.pinnedCertificates copyWithZone:zone]; return securityPolicy;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"http://yoursite.com/tags/AFNetWorking原理/"},{"name":"Encryption","slug":"Encryption","permalink":"http://yoursite.com/tags/Encryption/"}]},{"title":"AFNetWorking原理(一) AFURLSessionManager解读","slug":"AFNetWorking原理","date":"2019-06-21T07:48:30.000Z","updated":"2019-06-25T03:19:09.896Z","comments":true,"path":"2019/06/21/AFNetWorking原理/","link":"","permalink":"http://yoursite.com/2019/06/21/AFNetWorking原理/","excerpt":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。","text":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。 AFNetworking由5个模块组成 NSURLSession：网络通信模块（核心模块） AFURLSessionManager 对NSURLSession的封装 AFHTTPSessionManager 是继承于 AFURLSessionmanager Security：网络通讯安全策略模块 AFSecurityPolicy Reachability：网络状态监听模块 AFNetworkReachabilityManager Seriaalization：网络通信信息序列化、反序列化模块 AFHTTPRequestSerializer AFURLResponseSerialization UIKit：对于iOS UIKit的扩展库 网络请求类 AFURLSessionManager声明.h文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226// AFURLSessionManager类实现了NSURLSession相关的众多协议，用于帮助我们进行数据的处理@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;// NSURLSession 作为一个实例变量，AFN发起的网络请求都是通过该session创建的task实现的@property (readonly, nonatomic, strong) NSURLSession *session;// NSURLSession delegate方法执行队列@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;// 响应序列化 不能为nil@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;// 安全策略，用于https等需要验证的地方@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;#if !TARGET_OS_WATCH（生成的代码将在Apple Watch操作系统下运行）///--------------------------------------/// @name Monitoring Network Reachability///--------------------------------------// 监测网络连通性，使用AFNetworkReachabilityManager@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;#endif///----------------------------/// @name Getting Session Tasks///----------------------------// session管理的data upload download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;// session管理的data task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;// session管理的upload task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;// session管理的download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;///-------------------------------/// @name Managing Callback Queues///-------------------------------// 完成网络请求后执行回调块的队列，如果为nil则使用主队列@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;// 完成网络请求后回调块的@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;///---------------------------------/// @name Working Around System Bugs///---------------------------------// background类型的session是否尝试重新创建上传任务@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;///---------------------/// @name Initialization///---------------------// 初始化函数，根据指定NSURLSessionConfiguration创建session- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;// 设置session无效，cancelPendingTasks标识是否取消session中正在执行的任务// 内部还是调用NSURLSession的invalidate方法- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;///-------------------------/// @name Running Data Tasks///-------------------------// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler DEPRECATED_ATTRIBUTE;// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///---------------------------/// @name Running Upload Tasks///---------------------------// 根据指定request fileURL等参数构造一个NSURLSessionUploadTask任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 根据指定request和data等参数构造一个上传任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 创建一个具有特定数据流的NSURLSessionUploadTask请求，上传的body使用的是request.HTTPBodyStream- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///-----------------------------/// @name Running Download Tasks///-----------------------------// 构造下载任务- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;/*构造下载任务 断点续传根据未下载完成的数据，创建一个NSURLSessionDownloadTask对象。resumeData：未完成的下载数据destination：决定下载文件的存放路径的block。block中有两个参数，目标路径和服务器的响应。同时返回文件下载的URLcompletionHandler：当任务完成后completionHandler的block会被调用progress：下载进度block。每当下载进度更新时就会执行这个block*/- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;///---------------------------------/// @name Getting Progress for Tasks///---------------------------------// 根据NSURLSessionTask获取对应的任务完成进度NSProgress- (nullable NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task;// 根据NSURLSessionTask获取对应下载任务的进度NSProgress- (nullable NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task;///-----------------------------------------/// @name Setting Session Delegate Callbacks///-----------------------------------------// 设置session无效时执行的回调块- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;// 设置session收到challenge时执行的回调块- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;///--------------------------------------/// @name Setting Task Delegate Callbacks///--------------------------------------// 设置session需要新的流时执行的回调块- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;// 设置session的任务需要执行重定向时执行的回调块- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * _Nullable (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;// 设置Block用于当一个session的task接收到证书验证时调用。实际上依赖由NSURLSessionTaskDelegate 的 URLSession:task:didReceiveChallenge:completionHandler:.方法处理- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;// 设置Block每隔一段时间调用用来跟踪上传进度，实际上依赖由NSURLSessionTaskDelegate的 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法实现- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;// 设置一个当task完成时调用的Block- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;///-------------------------------------------/// @name Setting Data Task Delegate Callbacks///-------------------------------------------// 设置一个当DataTask请求接收到响应时调用的block。交由NSURLSessionDataDelegate的URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;// 设置当一个dataTask转变成downloadTak时调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didBecomeDownloadTask:.方法处理- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;// 设置当一个dataTask接受到数据时就调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;// 设置当一个dataTask对请求结果的缓冲时的block。交由NSURLSessionDataDelegate 的 URLSession:dataTask:willCacheResponse:completionHandler:.方法处理- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;// 设置当session中所有消息都被发送时，调用的block。交由NSURLSessionDataDelegate的URLSessionDidFinishEventsForBackgroundURLSession：方法实现- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block AF_API_UNAVAILABLE(macos);///-----------------------------------------------/// @name Setting Download Task Delegate Callbacks///-----------------------------------------------// 设置一个当下载任务完成一个下载时调用的block。最终交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didFinishDownloadingToURL:.方法处理- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;// 设置每次追踪下载进度时调用的block，最终交由NSURLSessionDownloadDelegate的URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite：方法处理- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;// 设置一个block，当任务重新下载时调用。交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:.方式- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;@end///--------------------/// @name Notifications///--------------------FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidSuspendNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDidInvalidateNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseDataKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteAssetPathKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteErrorKey;NS_ASSUME_NONNULL_END 通过头文件可以发现，AFURLSessionManager是封装了NSURLSession并实现了其相关的所有协议，提供了一系列方法用于构造各种网络请求任务，并提供回调块进行处理，还提供了一系列设置代理方法执行时的执行回调块的方法，这样，我们也可以监听整个网络请求的过程，当然也可以忽略这些代理方法执行情况，提供了各种通知，通过头文件可以看出，主要目的还是为了封装NSURLSession从而提供更加便捷的方法来实现网络请求。 实现.m文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef NSFoundationVersionNumber_iOS_8_0#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11#else#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0#endif//C静态函数，GCD只执行一次，用于创建一个串行队列来执行各种网络请求任务的创建工作static dispatch_queue_t url_session_manager_creation_queue() &#123; static dispatch_queue_t af_url_session_manager_creation_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_creation_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.creation\", DISPATCH_QUEUE_SERIAL); &#125;); return af_url_session_manager_creation_queue;&#125;/*C静态函数，用于执行创建网络请求任务的block主要目的是为了解决ios8以下存在的一个block和task不匹配的bug上面那个队列也是为了解决这个bug才创建的具体可查看Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093*/static void url_session_manager_create_task_safely(dispatch_block_t block) &#123; if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123; dispatch_sync(url_session_manager_creation_queue(), block); &#125; else &#123; block(); &#125;&#125;//C静态函数，创建一个并发队列，用于在网络请求任务完成后处理数据的，并发队列实现多线程处理多个请求完成后的数据处理static dispatch_queue_t url_session_manager_processing_queue() &#123; static dispatch_queue_t af_url_session_manager_processing_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_processing_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.processing\", DISPATCH_QUEUE_CONCURRENT); &#125;); return af_url_session_manager_processing_queue;&#125;//C静态函数创建一个dispatch的组//但在接下来的源码中并没有使用这个组来实现notify等功能，仅仅是将block和组关联了，不太清楚具体用意//有明白的读者还请不吝赐教static dispatch_group_t url_session_manager_completion_group() &#123; static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_completion_group = dispatch_group_create(); &#125;); return af_url_session_manager_completion_group;&#125;//一系列通知名称的定义NSString * const AFNetworkingTaskDidResumeNotification = @\"com.alamofire.networking.task.resume\";NSString * const AFNetworkingTaskDidCompleteNotification = @\"com.alamofire.networking.task.complete\";NSString * const AFNetworkingTaskDidSuspendNotification = @\"com.alamofire.networking.task.suspend\";NSString * const AFURLSessionDidInvalidateNotification = @\"com.alamofire.networking.session.invalidate\";NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification = @\"com.alamofire.networking.session.download.file-manager-error\";NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey = @\"com.alamofire.networking.task.complete.serializedresponse\";NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey = @\"com.alamofire.networking.task.complete.responseserializer\";NSString * const AFNetworkingTaskDidCompleteResponseDataKey = @\"com.alamofire.networking.complete.finish.responsedata\";NSString * const AFNetworkingTaskDidCompleteErrorKey = @\"com.alamofire.networking.task.complete.error\";NSString * const AFNetworkingTaskDidCompleteAssetPathKey = @\"com.alamofire.networking.task.complete.assetpath\";//需要使用的NSLock锁的名称static NSString * const AFURLSessionManagerLockName = @\"com.alamofire.networking.session.manager.lock\";//background session重试创建上传任务次数static NSUInteger const AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = 3; 对于url_session_manager_create_task_safely这个有什么用？其实这个是被当做是一个在ios8以下，NSURLSessionDataTask出现的一个Bug。问题产生的原因就是当队列是并发的，这是当两个任务同时在不同的线程上创建任务的时候taskIdentifier可能是一样的。大致的意思就是当我们同时创建两个任务，返回了重复的taskIdentifier，这样的话第一个被创建的completionHandler就会被清空，被第二个任务的completionHandler给替换，如果第一个数据是早于第二个数据返回的，那么第一个数据返回之后就会去调用第二个任务的completionHandler。 12345678910111213141516171819202122typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session, NSError *error);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef NSURLRequest * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef void (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(NSURLSession *session);typedef NSInputStream * (^AFURLSessionTaskNeedNewBodyStreamBlock)(NSURLSession *session, NSURLSessionTask *task);typedef void (^AFURLSessionTaskDidSendBodyDataBlock)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);typedef void (^AFURLSessionTaskDidCompleteBlock)(NSURLSession *session, NSURLSessionTask *task, NSError *error);typedef NSURLSessionResponseDisposition (^AFURLSessionDataTaskDidReceiveResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response);typedef void (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask);typedef void (^AFURLSessionDataTaskDidReceiveDataBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data);typedef NSCachedURLResponse * (^AFURLSessionDataTaskWillCacheResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse);typedef NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);typedef void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);typedef void (^AFURLSessionDownloadTaskDidResumeBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);typedef void (^AFURLSessionTaskProgressBlock)(NSProgress *);typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response, id responseObject, NSError *error); 定义一些回调的block 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248//定义了一个类AFURLSessionManagerTaskDelegate并实现了NSURLSessionTask的相关协议//这个类是用于处理NSURLSessionTask相关代理方法的@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;//初始化构造函数，需要传入一个关联的task- (instancetype)initWithTask:(NSURLSessionTask *)task;//weak修饰的manager@property (nonatomic, weak) AFURLSessionManager *manager;//可变data用于存储获取到的网络数据@property (nonatomic, strong) NSMutableData *mutableData;//上传进度NSProgress@property (nonatomic, strong) NSProgress *uploadProgress;//下载进度NSProgress@property (nonatomic, strong) NSProgress *downloadProgress;//下载文件的NSURL@property (nonatomic, copy) NSURL *downloadFileURL;//下载完成的回调块@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;//上传进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;//下载进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;//网络请求完成的回调块@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;@end@implementation AFURLSessionManagerTaskDelegate//初始化构造函数- (instancetype)initWithTask:(NSURLSessionTask *)task &#123; self = [super init]; if (!self) &#123; return nil; &#125; _mutableData = [NSMutableData data]; _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; //遍历两个上传和下载NSProgress设置一些属性 __weak __typeof__(task) weakTask = task; for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ]) &#123; //初始化progress progress.totalUnitCount = NSURLSessionTransferSizeUnknown; progress.cancellable = YES; //设置取消进度的回调块，执行task的cancel方法 progress.cancellationHandler = ^&#123; [weakTask cancel]; &#125;; progress.pausable = YES; //设置暂停进度的回调块，执行task的suspend方法 progress.pausingHandler = ^&#123; [weakTask suspend]; &#125;; //设置重新开始的回调块，执行task的resume方法 if ([progress respondsToSelector:@selector(setResumingHandler:)]) &#123; progress.resumingHandler = ^&#123; [weakTask resume]; &#125;; &#125; //progress添加kvo，监听progress的进度fractionCompleted [progress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; &#125; return self;&#125;//析构函数- (void)dealloc &#123; //删除KVO [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];&#125;#pragma mark - NSProgress Tracking//KVO回调方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; //上次或下载进度有改变时，执行上传或下载进度回调块 if ([object isEqual:self.downloadProgress]) &#123; if (self.downloadProgressBlock) &#123; self.downloadProgressBlock(object); &#125; &#125; else if ([object isEqual:self.uploadProgress]) &#123; if (self.uploadProgressBlock) &#123; self.uploadProgressBlock(object); &#125; &#125;&#125;#pragma mark - NSURLSessionTaskDelegate//代理方法，网络请求完成或出错- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //manager用weak修饰，这里strong一下防止manager被释放 __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; //为userInfo字典设置响应序列化 userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 //赋值mutableData到data中，并释放mutableData NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; &#125; //如果downloadFileURL存在，即是下载任务就设置下载完成后的文件存储url到字典中 if (self.downloadFileURL) &#123; userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; &#125; else if (data) &#123; //否则就设置对应的NSData数据到字典中 userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; &#125; //如果网络请求有错误 if (error) &#123; //设置error信息到字典中 userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; /* 这个三目运算符需要解释一下，在其他语言中这么写很可能就是语法错误 这里的意思就是如果manager.completionGroup存在就使用它 不存在就使用url_session_manager_completion_group函数返回的group 后面的三目运算符同理 所以如果自己不设置manager的completionGroup或completionQueue就会使用默认提供的 */ //执行对应的completionHandler回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, error); &#125; //在主队列即主线程中发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125; else &#123; //如果网络任务成功完成，异步在并发队列中执行数据处理 dispatch_async(url_session_manager_processing_queue(), ^&#123; //序列化响应数据 NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; //如果是下载任务设置响应数据为文件的url if (self.downloadFileURL) &#123; responseObject = self.downloadFileURL; &#125; //如果响应对象序列化成功或是文件url就设置相关字典key-value if (responseObject) &#123; userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; &#125; //如果序列化出错，设置相关字典值 if (serializationError) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; &#125; //同理，在dispatch组中和特定队列执行回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; //主线程发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); &#125;&#125;#pragma mark - NSURLSessionDataDelegate//回调方法，收到数据- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive; self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived; //添加数据到mutableData [self.mutableData appendData:data];&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //设置上传进度的相关属性 self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.uploadProgress.completedUnitCount = task.countOfBytesSent;&#125;#pragma mark - NSURLSessionDownloadDelegate//下载任务的回调方法//由于NSURLSession的downloadTask直接将文件下载到磁盘沙盒中，所以不需要mutableData自行接收数据- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = totalBytesExpectedToWrite; self.downloadProgress.completedUnitCount = totalBytesWritten;&#125;//恢复下载任务的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = expectedTotalBytes; self.downloadProgress.completedUnitCount = fileOffset;&#125;//下载任务下载文件完成后的回调方法//location就是文件下载到磁盘沙盒目录的NSURL- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //设置downloadFileURL为nil self.downloadFileURL = nil; //如果有下载完成的回调块 if (self.downloadTaskDidFinishDownloading) &#123; //执行该回调块，这个回调块返回一个下载的文件保存的路径URL //默认保存在沙盒tmp文件中，可能会被删除，需要持久化时要自己设置一个目录存储 self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果需要移动文件的路径使用NSFileManaegr移动 if (self.downloadFileURL) &#123; NSError *fileManagerError = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123; //文件移动发生错误发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; &#125; &#125; &#125;&#125;@end AFURLSessionManagerTaskDelegate的源码，主要就是关联一个NSURLSessionTask并实现了相关任务的代理方法用于数据的获取、上传文件和下载文件。需要注意的是NSURLSessionTask的delegate属性是只读的，只能在使用session创建task的函数中传入代理对象，而且通过源码也没有发现相关代理的设置，所以AFURLSessionManagerTaskDelegate类实现相关代理是为了其他类手动调用相关方法，AFURLSessionManager也实现了这些代理，所以具体的调用是由AFURLSessionManger手动触发的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(theClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123; return class_addMethod(theClass, selector, method_getImplementation(method), method_getTypeEncoding(method));&#125;static NSString * const AFNSURLSessionTaskDidResumeNotification = @\"com.alamofire.networking.nsurlsessiontask.resume\";static NSString * const AFNSURLSessionTaskDidSuspendNotification = @\"com.alamofire.networking.nsurlsessiontask.suspend\";@interface _AFURLSessionTaskSwizzling : NSObject@end@implementation _AFURLSessionTaskSwizzling+ (void)load &#123; /** WARNING: Trouble Ahead https://github.com/AFNetworking/AFNetworking/pull/2702 */ if (NSClassFromString(@\"NSURLSessionTask\")) &#123; /** iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky. Many Unit Tests have been built to validate as much of this behavior has possible. Here is what we know: - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn't actually the type of class you will get back. - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there. - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`. - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`. - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled. - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled. - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there. Some Assumptions: - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we'd need to handle it. - No background task classes override `resume` or `suspend` The current solution: 1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task. 2) Grab a pointer to the original implementation of `af_resume` 3) Check to see if the current class has an implementation of resume. If so, continue to step 4. 4) Grab the super class of the current class. 5) Grab a pointer for the current class to the current implementation of `resume`. 6) Grab a pointer for the super class to the current implementation of `resume`. 7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods 8) Set the current class to the super class, and repeat steps 3-8 */ NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];#pragma GCC diagnostic push#pragma GCC diagnostic ignored \"-Wnonnull\" NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];#pragma clang diagnostic pop IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume))); Class currentClass = [localDataTask class]; while (class_getInstanceMethod(currentClass, @selector(resume))) &#123; Class superClass = [currentClass superclass]; IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume))); IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume))); if (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; [self swizzleResumeAndSuspendMethodForClass:currentClass]; &#125; currentClass = [currentClass superclass]; &#125; [localDataTask cancel]; [session finishTasksAndInvalidate]; &#125;&#125;+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123; Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume)); Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend)); if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123; af_swizzleSelector(theClass, @selector(resume), @selector(af_resume)); &#125; if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123; af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend)); &#125;&#125;- (NSURLSessionTaskState)state &#123; NSAssert(NO, @\"State method should never be called in the actual dummy class\"); return NSURLSessionTaskStateCanceling;&#125;- (void)af_resume &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_resume]; if (state != NSURLSessionTaskStateRunning) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self]; &#125;&#125;- (void)af_suspend &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_suspend]; if (state != NSURLSessionTaskStateSuspended) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self]; &#125;&#125;@end 这里用到了method-swizzling的技术，交换了 resume 和 suspend方法的实现，因为iOS7和iOS8中NSURLSessionTask的父类不同，需要做一些处理（发送task暂停、继续通知）。 123456789101112131415161718192021222324252627282930313233@interface AFURLSessionManager ()//管理的session运行模式，默认情况下使用默认运行模式，defaultConfiguration@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;/*NSOperation队列，代理方法执行的队列.h文件里是readonly，所以这里定义一个readwrite用于赋值*/@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;//管理的session，readwrite@property (readwrite, nonatomic, strong) NSURLSession *session;//可变字典，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;//只读属性，通过getter返回数据@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;//NSLock锁@property (readwrite, nonatomic, strong) NSLock *lock;//下面是一系列回调块@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;@end 延展里面定义了一些属性和响应的回调block。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation AFURLSessionManager//构造函数- (instancetype)init &#123; return [self initWithSessionConfiguration:nil];&#125;//构造函数- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; //如果没有指定session运行模式就使用默认的 if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; //创建代理方法执行的队列，最大并发数为1，即串行队列 //感觉这里设置为1是为了让回调一个个执行 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; //创建session，注意代理对象是self self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; //创建响应序列化器 self.responseSerializer = [AFJSONResponseSerializer serializer]; //设置默认安全策略 self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH //获取网络可达性manager self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; //创建锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* 获取session中的任务，并调用相关方法关联AFURLSessionManagerTaskDelegate 不太明白这里为什么要这么做，刚创建的session应该没有任何任务在执行 */ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self;&#125;//析构方法，移除所有通知监听- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 初始化方法里面有一个有一个不明白的点，创建完session之后就去获取它正在执行的任务，刚创建完session为何会有任务呢？这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。 1234567891011121314151617181920212223242526272829//taskDescriptionForSessionTasks属性的getter，返回地址的字符串形式数据，可以保证这个字符串是唯一的- (NSString *)taskDescriptionForSessionTasks &#123; return [NSString stringWithFormat:@\"%p\", self];&#125;//通知的回调方法，接下来的代码会添加相关通知- (void)taskDidResume:(NSNotification *)notification &#123; //发送通知的时候会将task添加进通知中 NSURLSessionTask *task = notification.object; //判断这个任务是否是当前manager管理的，如果是就发送相关通知 //task的taskDescription属性在下文的源码中会设置 if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task]; &#125;); &#125; &#125;&#125;//同上- (void)taskDidSuspend:(NSNotification *)notification &#123; NSURLSessionTask *task = notification.object; if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task]; &#125;); &#125; &#125;&#125; 上面的代码就是通知的回调方法，用于通知resume和suspend事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//根据task获取相关联的AFURLSessionManagerTaskDelegate对象- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123; //task不能为空 NSParameterAssert(task); //上锁，通过task的唯一taskIdentifier从字典中取值，这个唯一标识是在创建task的时候NSURLSessionTask为其设置的，不需要手动设置，保证唯一性 AFURLSessionManagerTaskDelegate *delegate = nil; [self.lock lock]; delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate;&#125;//为task设置关联的delegate- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; //task和delegate都不能为空 NSParameterAssert(task); NSParameterAssert(delegate); //上锁，向字典中添加key-value对 [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125;//重点方法，为dataTask创建一个关联的AFURLSessionManagerTaskDelegate对象- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; //创建AFURLSessionManagerTaskDelegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; //设置相关属性 delegate.manager = self; delegate.completionHandler = completionHandler; /* 设置task的taskDescription，注意和taskIdentifier区分 taskDescription是开发者自行设置的 taskIdentifier是NSURLSessionTask设置的，保证每一个task的id不同 这里设置的taskDescription就是AFURLSessionManager的地址 所以同一个manager创建的task的description都是一致的 设置这个值的目的就是为了区分task是否是当前manger创建的 */ dataTask.taskDescription = self.taskDescriptionForSessionTasks; //调用上面的方法将task-delegate键值对添加进字典中 [self setDelegate:delegate forTask:dataTask]; //设置回调块 delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//同上，创建上传任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; uploadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:uploadTask]; delegate.uploadProgressBlock = uploadProgressBlock;&#125;//同上，创建下载文件任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; /* 需要注意下，AFURLSessionManagerTaskDelegate中下载文件完成后会调用delegate.downloadTaskDidFinishDownloading回调块 来获取下载文件要移动到的目录URL 所以这里就是创建这个回调块，直接返回参数中的destination回调块 */ if (destination) &#123; delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123; return destination(location, task.response); &#125;; &#125; downloadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:downloadTask]; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//从字典中删除task对应的delegate的key-value对- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); [self.lock lock]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; 上面的代码就是对AFURLSessionManagerTaskDelegate的创建、添加进字典、删除、获取的操作，这样就实现了每一个NSURLSessionTask对应一个AFURLSessionManagerTaskDelegate对象，可能读者会有疑问，AFURLSessionManager既然已经实现了代理的方法，为什么不直接使用它来处理代理方法，为什么要创建一个类来专门处理，继续看完源码可能你就会明白了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//根据keyPath获取不同类型任务的集合- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray *tasks = nil; //创建一个信号量，值是0 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); //这个方法是异步的，所以为了同步返回结果，需要使用锁，信号量值设置为0或者1时就可以当锁来使用了 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks = dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks = uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks = downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@\"@unionOfArrays.self\"]; &#125; //signal通知信号量，信号量值加1 dispatch_semaphore_signal(semaphore); &#125;]; //等待信号量，直到值大于0，等待时间是forever dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125;//下面是tasks、dataTasks、uploadTasks、downloadTasks属性的getter，都是调用上述方法来获取对应类型的任务集合- (NSArray *)tasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)dataTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)uploadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)downloadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;#pragma mark -//设置session无效，根据参数判断是否需要取消正在执行的任务- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks &#123; //调用NSURLSession对应的方法来设置session无效，同时打破引用循环 if (cancelPendingTasks) &#123; [self.session invalidateAndCancel]; &#125; else &#123; [self.session finishTasksAndInvalidate]; &#125;&#125;#pragma mark -//responseSerializer的setter- (void)setResponseSerializer:(id &lt;AFURLResponseSerialization&gt;)responseSerializer &#123; NSParameterAssert(responseSerializer); _responseSerializer = responseSerializer;&#125;#pragma mark -//添加通知，taskDidResume、taskDidSuspend方法前面讲过了- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];&#125;//删除通知- (void)removeNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidSuspendNotification object:task]; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidResumeNotification object:task];&#125; 上面的方法是一些getter和setter，很简单，不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];&#125;//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; //为了解决iOS8一下的一个bug，调用一个串行队列来创建dataTask __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^&#123; //使用session来创建一个NSURLSessionDataTask对象 dataTask = [self.session dataTaskWithRequest:request]; &#125;); //为这个task创建一个AFURLSessionManagerTaskDelegate并关联加入字典中 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125;#pragma mark -//创建一个NSURLSessionUploadTask对象- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125;); // uploadTask may be nil on iOS7 because uploadTaskWithRequest:fromFile: may return nil despite being documented as nonnull (https://devforums.apple.com/message/926113#926113) //解决iOS7的一个bug按照配置的尝试次数创建上传任务，默认尝试3次 if (!uploadTask &amp;&amp; self.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; self.session.configuration.identifier) &#123; for (NSUInteger attempts = 0; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125; &#125; //创建关联的delegate并添加到字典中 [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;#pragma mark -//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithRequest:request]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125;//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithResumeData:resumeData]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125; 上面的方法就是AFURLSessionManager为我们提供的获取NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask的方法，上面这些方法主要目的就是传入进度或完成回调块，然后构造一个AFURLSessionManagerTaskDeleagte对象并关联，这样就不需要开发者自行实现和管理代理方法做相关数据处理，只需要在回调块中做处理即可。 接下来源码中是一系列回调块的setter方法，就不列下来了，读者可以自己看看。接下来就讲解重点的各种代理的回调方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//session无效后的回调方法- (void)URLSession:(NSURLSession *)sessiondidBecomeInvalidWithError:(NSError *)error&#123; //如果回调块存在就执行回调块 if (self.sessionDidBecomeInvalid) &#123; self.sessionDidBecomeInvalid(session, error); &#125; //发送对应通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];&#125;//收到服务端的challenge，例如https需要验证证书等- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; //如果有对应回调块就执行 if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; //处理https if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; 上面两个方法是NSURLSessionDelegate的方法，关于验证HTTPS的部分代码可以当做模板代码来写，具体内容不是本文讲解范畴，读者可自行查阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//要执行重定向的代理方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskwillPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler&#123; //套路就是执行用户自定义的回调块，执行完成回调块 NSURLRequest *redirectRequest = request; if (self.taskWillPerformHTTPRedirection) &#123; redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request); &#125; if (completionHandler) &#123; completionHandler(redirectRequest); &#125;&#125;//同前面一样，处理https链接- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (self.taskDidReceiveAuthenticationChallenge) &#123; disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential); &#125; else &#123; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125;//处理需要一个新的流- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler&#123; //调用用户自定义的回调块来获取，或者copy一个 NSInputStream *inputStream = nil; if (self.taskNeedNewBodyStream) &#123; inputStream = self.taskNeedNewBodyStream(session, task); &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123; inputStream = [task.originalRequest.HTTPBodyStream copy]; &#125; if (completionHandler) &#123; completionHandler(inputStream); &#125;&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //获取上传的总大小，如果数据不正确就从http首部中获取 int64_t totalUnitCount = totalBytesExpectedToSend; if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123; NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@\"Content-Length\"]; if(contentLength) &#123; totalUnitCount = (int64_t) [contentLength longLongValue]; &#125; &#125; //获取task关联的AFURLSessionManagerTaskDelegate对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; //如果代理对象存在，就调用代理对象的这个方法 if (delegate) &#123; [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend]; &#125; //如果用户自定义回调块存在，执行回调块 if (self.taskDidSendBodyData) &#123; self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount); &#125;&#125;//任务完成的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //同样的套路，获取关联的代理对象，手动调用代理对象的这个方法，执行用户自定义的回调块 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; &#125; if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error); &#125;&#125; 以上代码是NSURLSessionTaskDelegate的回调方法，通过上面的代码可以发现AFURLSessionManagerTaskDelegate的作用了，AFURLSessionManager的代理方法中会根据task获取到对应的delegate，如果需要提前处理一些数据就先处理，处理完成后手动触发delegate中的对应方法，然后具体的数据处理就交由AFURLSessionManagerTaskDelegate来处理。继续看其他代理方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//收到服务端响应的代理回调方法- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; //调用用户自定义回调块，执行完成回调块 NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; if (self.dataTaskDidReceiveResponse) &#123; disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; if (completionHandler) &#123; completionHandler(disposition); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; if (delegate) &#123; [self removeDelegateForTask:dataTask]; [self setDelegate:delegate forTask:downloadTask]; &#125; if (self.dataTaskDidBecomeDownloadTask) &#123; self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //获取代理，然后调用代理的这个方法，有自定义回调块就执行 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; [delegate URLSession:session dataTask:dataTask didReceiveData:data]; if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (self.dataTaskWillCacheResponse) &#123; cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse); &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125;- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123; if (self.didFinishEventsForBackgroundURLSession) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.didFinishEventsForBackgroundURLSession(session); &#125;); &#125;&#125; 上面的代码是NSURLSessionDataDelegate的代理方法，同样的，如果AFURLSessionManagerTaskDelegate能响应的关于数据处理的方法都会通过task找到对应delegate后调用其对应的方法，然后执行用户自定义的回调块，如果代理不能响应的方法就由AFURLSessionManager自行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//下载任务下载文件完成后的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //获取对应的代理对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果downloadTaskDidFinishDownloading回调块存在就执行它来获取一个保存文件的URL路径 if (self.downloadTaskDidFinishDownloading) &#123; NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果这个路径存在就通过NSFileManager来移动，移动失败发送通知 if (fileURL) &#123; delegate.downloadFileURL = fileURL; NSError *error = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo]; &#125; return; &#125; &#125; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location]; &#125;&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //通过task获取delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果delegate存在就调用其该方法 if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite]; &#125; //如果回调块存在就执行 if (self.downloadTaskDidWriteData) &#123; self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite); &#125;&#125;//同上套路- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes]; &#125; if (self.downloadTaskDidResume) &#123; self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes); &#125;&#125; 到现在为止，AFURLSessionManager所有源码都看完了，代码封装了NSURLSession并提供了简洁的创建NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask对象的方法，使用人员可以不需要考虑具体的数据处理过程，最简单的可以只通过回调块来获取网络请求的各种信息。在具体实现上，AFURLSessionManager通过定义AFURLSessionManagerTaskDelegate来做具体task的数据处理，而AFURLSessionManager只关注于通用部分的实现，并提供各种方法和回调块用于处理task，使得代码结构更清晰，AFURLSessionManager代理方法结构也更简单。 AFURLSessionManager个人总结 AFURLSessionManagerTaskDelegate 是为了对应每一个task，单独定义一个类，解耦合，代码逻辑更清晰 mutableData 在请求完成之后置位 nil，节省内存 dispatch_semaphore的使用，信号量线程同步 method swizzing巧妙监听 task 的 suspend 和 resume NSLock 安全加锁，避免字典中假如的 delegate 和 task不对应","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"http://yoursite.com/tags/AFNetWorking原理/"}]},{"title":"Github Blog With Hexo","slug":"hello-world","date":"2019-06-21T07:40:42.265Z","updated":"2019-06-24T10:16:01.754Z","comments":true,"path":"2019/06/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/21/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}