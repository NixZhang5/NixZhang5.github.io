{"meta":{"title":"Xinping's Blog","subtitle":"因为有了危机感，所以会义无反顾。","description":"积累 记录 传播 共进","author":"张新平","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-06-24T18:03:14.000Z","updated":"2019-06-24T10:25:07.974Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-24T18:08:50.000Z","updated":"2019-06-24T10:25:34.397Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AFNetWorking原理(二) AFSecurityPolicy","slug":"AFNetWorking原理二","date":"2019-06-25T11:31:07.000Z","updated":"2019-06-25T10:49:12.251Z","comments":true,"path":"2019/06/25/AFNetWorking原理二/","link":"","permalink":"http://yoursite.com/2019/06/25/AFNetWorking原理二/","excerpt":"AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。","text":"AFNetWorking 是靠着 AFSecurityPolicy 这个类保证数据安全的，AFSecurityPolicy 其实就是验证证书是否正确的。 AFSecurityPolicy 的校验选项 AFSSLPinningMode 有三种： AFSSLPinningModeNone 在与服务器建立安全连接时，并不会使用应用中已有的证书（也可能本就没有）对服务器传递的信息进行校验，此为默认选项 AFSSLPinningModePublicKey 使用应用中已有的公钥对服务器传递的信息进行校验 AFSSLPinningModeCertificate 使用应用中已有的数字证书对服务器传递的信息进行校验 HTPPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。 HTTPS连接建立 非对称加密、对称加密：客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有（各个受信任的证书机构）根证书，用这些根证书对服务端返回的证书进行验证，经验证如果证书（服务端返回的证书）是可信任的，就生成一个pre-master secret，用这个证书（服务端返回的证书）的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master secret，客户端也同样根据这种算法从pre-master secret生成master secret（非对称加密），随后双方的通信都用这个master secret对传输数据进行加密解密（对称加密）。 非对称加密： d(c(x))=x HTTP和HTTPS区别超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下四点： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 SSLSSL(Secure Sockets Layer安全套接层),及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL (Secure Socket Layer)为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。 SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。 SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 SSL协议提供的服务主要有哪些 认证用户和服务器，确保数据发送到正确的客户机和服务器 加密数据以防止数据中途被窃取 维护数据的完整性，确保数据在传输过程中不被改变。 SSL协议的工作流程 服务器认证阶段：客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 从SSL 协议所提供的服务及其工作流程可以看出，SSL协议运行的基础是商家对消费者信息保密的承诺，这就有利于商家而不利于消费者。在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。但随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的单一认证问题就越来越突出。虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务器双方的身份验证，但是SSL协议仍存在一些问题，比如，只能提供交易中客户与服务器间的双方认证，在涉及多方的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。在这种情况下，Visa和MasterCard两大信用卡公组织制定了SET协议，为网上信用卡支付提供了全球性的标准。 SSL协议加密方式SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。 对称加密速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 SSL证书包含的信息 证书版本号，不同版本的证书格式不同 Serial Number 序列号，同一身份验证机构签发的证书序列号唯一 Algorithm Identifier 签名算法，包括必要的参数Issuer 身份验证机构的标识信息 Period of Validity 有效期 Subject 证书持有人的标识信息 Subject’s Public Key 证书持有人的公钥 Signature 身份验证机构对证书的签名 证书的格式 认证中心所发放的证书均遵循X.509 V3 标准，其基本格式如下： 证书版本号（Certificate Format Version）含义：用来指定证书格式采用的X.509 版本号。 证书序列号（Certificate Serial Number）含义：用来指定证书的唯一序列号，以标识CA 发出的所有公钥证书。 签名（Signature）算法标识（Algorithm Identifier）含义：用来指定 CA 签发证书所用的签名算法。 签发此证书的 CA 名称（Issuer ）含义：用来指定签发证书的 CA 的X.500 唯一名称（DN，Distinguished Name）。 证书有效期（Validity Period）起始日期（notBefore） 终止日期（notAfter）含义：用来指定证书起始日期和终止日期。 用户名称（Subject）含义：用来指定证书用户的X.500 唯一名称（DN，Distinguished Name）。 用户公钥信息（Subject Public Key Information）算法（algorithm） 算法标识（Algorithm Identifier）用户公钥（subject Public Key）含义：用来标识公钥使用的算法，并包含公钥本身。 证书扩充部分（扩展域）（Extensions）含义：用来指定额外信息。 X.509 V3 证书的扩充部分（扩展域）及实现方法如下： CA 的公钥标识（Authority Key Identifier） 公钥标识（SET 未使用）（Key Identifier） 签发证书者证书的签发者的甄别名（Certificate Issuer） 签发证书者证书的序列号（Certificate Serial Number） X.509 V3 证书的扩充部分（扩展域）及实现CA 的公钥标识（Authority Key Identifier） 公钥标识（SET 未使用）（Key Identifier） 签发证书者证书的签发者的甄别名（Certificat签发证书者证书的序列号（Certificate Serial Number）含义：CA 签名证书所用的密钥对的唯一标识用户的公钥标识（Subject Key Identifier）含义：用来标识与证书中公钥相关的特定密钥进行解密。 证书中的公钥用途（Key Usage）含义：用来指定公钥用途。 用户的私钥有效期（Private Key Usage Period）起始日期（Note Before） 终止日期（Note After）含义：用来指定用户签名私钥的起始日期和终止日期。 CA 承认的证书政策列表（Certificate Policies）含义：用来指定用户证书所适用的政策，证书政策可由对象标识符表示。 用户的代用名（Substitutional Name）含义：用来指定用户的代用名。 CA 的代用名（Issuer Alt Name）含义：用来指定 CA 的代用名。 基本制约（Basic Constraints）含义：用来表明证书用户是最终用户还是CA。 在SET 系统中有一些私有扩充部分（扩展域）Hashed Root Key 含义：只在根证书中使用，用于证书更新时进行回溯。 证书类型（Certificate Type）含义：用来区别不同的实体。该项是必选的。 商户数据（Merchant Data）含义：包含支付网关需要的所有商户信息。 持卡人证书需求（Card Cert Required）含义：显示支付网关是否支持与没有证书的持卡人进行交易。 SET 扩展（SETExtensions）含义：列出支付网关支持的支付命令的 SET 信息扩展。 CRL 数据定义版本（Version）含义：显示 CRL 的版本号。 CRL 的签发者（Issuer）含义：指明签发 CRL 的CA 的甄别名。 CRL 发布时间（this Update）预计下一个 CRL 更新时间（Next Update）撤销证书信息目录（Revoked Certificates）CRL 扩展（CRL Extension）CA 的公钥标识（Authority Key Identifier）CRL 号（CRL Number） SSL证书种类：CFCA，GlobalSign，VeriSign ，Geotrust ，Thawte。 域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站； 企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高； 增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。 握手过程为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下： 客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。 服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 HTTPS的认证过程单向认证Https在建立Socket连接之前，需要进行握手，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 服务器将选择好的加密方案通过明文方式返回给客户端 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发型服务器证书的CA是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 验证客户端的证书，通过验证后，会获得客户端的公钥 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 AFSecurityPolicy和认证认证过程和原理AFN是靠着AFSecurityPolicy这个类保证数据安全的，调用下面方法用来验证是否信任服务器。 1[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host] 看一下AFN中的接口 123456789101112131415161718192021/*! @typedef SecTrustRef @abstract CFType used for performing X.509 certificate trust evaluations. // 执行X.509证书信任评估，其实就是一个容器，装了服务器端需要验证的证书的基本信息、 公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书， 这个客户端的证书，可以用来和服务端的证书去匹配验证的 */typedef struct CF_BRIDGED_TYPE(id) __SecTrust *SecTrustRef;/** Whether or not the specified server trust should be accepted, based on the security policy. This method should be used when responding to an authentication challenge from a server. @param serverTrust The X.509 certificate trust of the server. @param domain The domain of serverTrust. If `nil`, the domain will not be validated. // 服务器域名 @return Whether or not to trust the server. */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain; 根据安全策略是否接受指定的服务器信任。 响应来自服务器的身份验证质询时应使用此方法。 大家还记得这个代理方法吗？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; //挑战处理类型为 默认 /* NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理 NSURLSessionAuthChallengeUseCredential：使用指定的证书 NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战 */ NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; // sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战 if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; // 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust // 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。 // 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象 if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; // 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战 if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; // 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书） credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; // 确定挑战的方式 if (credential) &#123; //证书挑战 设计policy,none，则跑到这里 disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; //取消挑战 disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; //默认挑战方式 disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; //完成挑战 if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; 这个方法是如何进行接受挑战的 首先指定了HTTPS为默认的认证方式。 判断有没有自定义Block:sessionDidReceiveAuthenticationChallenge，有的话，使用我们自定义Block,生成一个认证方式，并且可以给credential赋值，即我们需要接受认证的证书。然后直接调用completionHandler，去根据这两个参数，执行系统的认证。 如果没有自定义Block，我们判断如果服务端的认证方法要求是NSURLAuthenticationMethodServerTrust，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现） 接着我们就执行了AFSecurityPolicy相关的上面的方法- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain，关于这个方法，AF默认的处理是，如果这行返回NO、说明AF内部认证失败，则取消HTTPS认证，即取消请求。返回YES则进入if块，用服务器返回的一个serverTrust去生成了一个认证证书。（注：这个serverTrust是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。最后调用completionHandler传递认证方式和要认证的证书，去做系统根证书验证。也可以这么理解：这里securityPolicy存在的作用就是，使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。如果通不过，则直接越过系统的验证，取消HTTPS的网络请求。否则，继续去走系统根证书的验证。 AFSecurityPolicy实例化先看一下该类的实例化 12345678AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125; 这里有一个很重要的属性就是SSLPinningMode，先看一下这个枚举 12345typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, //不验证 AFSSLPinningModePublicKey, //只验证公钥 AFSSLPinningModeCertificate, // 验证证书&#125;; 下面我们看一下类AFSecurityPolicy的几个属性 123456789101112131415161718192021222324252627/** The criteria by which server trust should be evaluated against the pinned SSL certificates. Defaults to `AFSSLPinningModeNone`. */// 验证模式 这个枚举值上面讲述过@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;/** The certificates used to evaluate server trust according to the SSL pinning mode. By default, this property is set to any (`.cer`) certificates included in the target compiling AFNetworking. Note that if you are using AFNetworking as embedded framework, no certificates will be pinned by default. Use `certificatesInBundle` to load certificates from your target, and then create a new policy by calling `policyWithPinningMode:withPinnedCertificates`. Note that if pinning is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches. */// 可以去匹配服务端证书验证的证书@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;/** Whether or not to trust servers with an invalid or expired SSL certificates. Defaults to `NO`. */// 是否支持非法的证书（例如自签名证书）@property (nonatomic, assign) BOOL allowInvalidCertificates;/** Whether or not to validate the domain name in the certificate's CN field. Defaults to `YES`. */// 是否去验证证书域名是否匹配@property (nonatomic, assign) BOOL validatesDomainName; AFNetWorking HTTPS请求示例自签名证书我们手动指定securityPolicy认证属性。通过12306证书来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//自建证书认证- (IBAction)buttion1:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://kyfw.12306.cn/otn/leftTicket/init\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // [request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定安全策略 manager.securityPolicy = [self ticketSecurityPolicy]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/** 12306的认证证书，他的认证证书是自签名的 @return 返回指定的认证策略 */-(AFSecurityPolicy*)ticketSecurityPolicy &#123; // /先导入证书 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"12306\" ofType:@\"cer\"];//证书的路径 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; &#125; // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO // 如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = YES; //validatesDomainName 是否需要验证域名，默认为YES； //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。 //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。 //如置为NO，建议自己添加对应域名的校验逻辑。 securityPolicy.validatesDomainName = NO; return securityPolicy;&#125; SSL信任证书我们手动指定securityPolicy认证属性。通过百度证书来实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//认证证书认证- (IBAction)button2:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.baidu.com\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //[request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定安全策略 manager.securityPolicy = [self baiduSecurityPolicy]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/**百度的的认证证书，他的认证证书是花钱买的，也就是不是自签名的证书。这种证书，如果我们要手动指定，pinmode只能是`AFSSLPinningModeNone` @return 返回指定的认证策略 */-(AFSecurityPolicy*)baiduSecurityPolicy &#123; // /先导入证书 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"baidu\" ofType:@\"cer\"];//证书的路径 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; //这里只能用AFSSLPinningModeNone才能成功，而且我系统的证书列表里面已经有百度的证书了 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate 使用证书验证模式。下面这个方法会默认使用项目里面的所有证书 securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone]; &#125; // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO // 如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = NO; //validatesDomainName 是否需要验证域名，默认为YES； //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。 //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。 //如置为NO，建议自己添加对应域名的校验逻辑。 securityPolicy.validatesDomainName = YES; return securityPolicy;&#125; SSL证书AFN默认处理这里我们不做任何额外的处理，直接使用AFN的默认证书处理机制。通过AFURLSessionManager的securityPolicy默认实现。它会和存在系统中的做对比来验证证书。 1234567891011121314//系统证书认证- (IBAction)button3:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.apple.com/\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //指定返回数据类型,默认是AFJSONResponseSerializer类型，犹豫这里不是JSON类型的返回数据，所以需要手动指定返回类型 AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125; AFSecurityPolicy源码解析AFSecurityPolicy分三种验证模式 AFSSLPinningModeNone:这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。 AFSSLPinningModeCertificate:这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。这里还没弄明白第一步的验证是怎么进行的，代码上跟去系统信任机构列表里验证一样调用了SecTrustEvaluate，只是这里的列表换成了客户端保存的那些证书列表。若要验证这个，是否应该把服务端证书的颁发机构根证书也放到客户端里？ AFSSLPinningModePublicKey:这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。 SecTrustRef这是一个需要验证的信任对象,包含待验证的证书和支持的验证方法等。 SecTrustResultType表示验证结果。其中 kSecTrustResultProceed表示serverTrust验证成功，且该验证得到了用户认可(例如在弹出的是否信任的alert框中选择always trust)。 kSecTrustResultUnspecified表示 serverTrust验证成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书。 两者取其一就可以认为对serverTrust验证成功。 SecTrustEvaluate证书校验函数,在函数的内部递归地从叶节点证书到根证书验证。需要验证证书本身的合法性（验证签名完整性，验证证书有效期等);验证证书颁发者的合法性（查找颁发者的证书并检查其合法性，这个过程是递归的).而递归的终止条件是证书验证过程中遇到了锚点证书(锚点证书:嵌入到操作系统中的根证书,这个根证书是权威证书颁发机构颁发的自签名证书)。 AFSecurityPolicy的源码细节如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383/** 证书的验证类型 - AFSSLPinningModeNone: 不使用`pinned certificates`来验证证书 - AFSSLPinningModePublicKey: 使用`pinned certificates`来验证证书的公钥 - AFSSLPinningModeCertificate: 使用`pinned certificates`来验证整个证书 */typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate,&#125;;/** 获取指定证书的公钥 @param certificate 证书数据 @return 公钥 */static id AFPublicKeyForCertificate(NSData *certificate) &#123; id allowedPublicKey = nil; SecCertificateRef allowedCertificate; SecPolicyRef policy = nil; SecTrustRef allowedTrust = nil; SecTrustResultType result; //获取证书对象 allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate); __Require_Quiet(allowedCertificate != NULL, _out); //获取X.509的认证策略 policy = SecPolicyCreateBasicX509(); //获取allowedTrust对象的值 __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _out); __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out); //根据allowedTrust获取对应的公钥 allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);//C++的gumpto跳转，当前面的操作出错以后，直接跳入_out执行_out: if (allowedTrust) &#123; CFRelease(allowedTrust); &#125; if (policy) &#123; CFRelease(policy); &#125; if (allowedCertificate) &#123; CFRelease(allowedCertificate); &#125; //返回公钥 return allowedPublicKey;&#125;/** 在指定的证书和认证策略下，验证SecTrustRef对象是否是受信任的、合法的。 @param serverTrust SecTrustRef对象 @return 结果 */static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; //获取serverTrust的认证结果，调用`SecTrustEvaluate`表示通过系统的证书来比较认证 __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125;/** 根据`serverTrust`获取认证的证书链 @param serverTrust serverTrust对象 @return 认证证书链 */static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //获取认证链的总层次 CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; //获取每一级认证链，把获取的证书数据存入数组中 for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)]; &#125; //返回证书链数组 return [NSArray arrayWithArray:trustChain];&#125;/** 获取serverTrust对象的认证链的公钥数组 @param serverTrust serverTrust对象 @return 公钥数组 */static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //X.509标准的安全策略 SecPolicyRef policy = SecPolicyCreateBasicX509(); //获取证书链的证书数量 CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); SecCertificateRef someCertificates[] = &#123;certificate&#125;; CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL); SecTrustRef trust; //通过一个证书、认证策略新建一个SecTrustRef对象 __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _out); SecTrustResultType result; //验证SecTrustRef对象是否成功 __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _out); //把SecTrustRef对应的公钥加入数组中 [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)]; _out: if (trust) &#123; CFRelease(trust); &#125; if (certificates) &#123; CFRelease(certificates); &#125; continue; &#125; CFRelease(policy); return [NSArray arrayWithArray:trustChain];&#125;#pragma mark -@interface AFSecurityPolicy()//认证策略@property (readwrite, nonatomic, assign) AFSSLPinningMode SSLPinningMode;//公钥集合@property (readwrite, nonatomic, strong) NSSet *pinnedPublicKeys;@end@implementation AFSecurityPolicy/** 从MainBundle中获取所有证书 @param bundle 返回包含在bundle中的证书集合。如果AFNetworking使用的是静态库，我们必须通过这个方法来加载证书。并且通过`policyWithPinningMode:withPinnedCertificates`方法来指定认证类型。 @return 返回bundle里面的证书 */+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123; //获取项目里的所有.cer证书 NSArray *paths = [bundle pathsForResourcesOfType:@\"cer\" inDirectory:@\".\"]; NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]]; for (NSString *path in paths) &#123; //获取证书对应的NSData，并且加入集合中 NSData *certificateData = [NSData dataWithContentsOfFile:path]; [certificates addObject:certificateData]; &#125; //返回证书集合 return [NSSet setWithSet:certificates];&#125;/** 返回当前类所在bundle所在的证书集合 @return 证书集合 */+ (NSSet *)defaultPinnedCertificates &#123; static NSSet *_defaultPinnedCertificates = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //获取当前类所在bundle NSBundle *bundle = [NSBundle bundleForClass:[self class]]; _defaultPinnedCertificates = [self certificatesInBundle:bundle]; &#125;); return _defaultPinnedCertificates;&#125;/** 返回默认的安全认证策略,在这里是验证系统的证书。这个策略不允许非法证书、验证主机名、不验证证书内容和公钥 @return 返回认证策略 */+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125;/** 根据指定的认证策略和默认的证书列表初始化一个`AFSecurityPolicy`对象 @param pinningMode 认证策略 @return `AFSecurityPolicy`对象 */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123; return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];&#125;/** 通过制定的认证策略`pinningMode`和证书集合`pinnedCertificates`来初始化一个`AFSecurityPolicy`对象 @param pinningMode 认证模型 @param pinnedCertificates 证书集合 @return AFSecurityPolicy对象 */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = pinningMode; //设置`_pinnedCertificates`和`pinnedPublicKeys`属性，分别对应证书集合和公钥集合 [securityPolicy setPinnedCertificates:pinnedCertificates]; //返回初始化成功的`AFSecurityPolicy` return securityPolicy;&#125;- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; //默认是要认证主机名称 self.validatesDomainName = YES; return self;&#125;/**通过指定的证书结合获取到对应的公钥集合。然后赋值给`pinnedPublicKeys`属性 @param pinnedCertificates 证书集合 */- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123; _pinnedCertificates = pinnedCertificates; if (self.pinnedCertificates) &#123; NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]]; //迭代每一个证书 for (NSData *certificate in self.pinnedCertificates) &#123; //获取证书对应的公钥 id publicKey = AFPublicKeyForCertificate(certificate); if (!publicKey) &#123; continue; &#125; [mutablePinnedPublicKeys addObject:publicKey]; &#125; //赋值给对应的属性 self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys]; &#125; else &#123; self.pinnedPublicKeys = nil; &#125;&#125;#pragma mark -/** 为serverTrust对象指定认证策略，如果domain不为nil,则包括对主机名的认证。这个方法必须在接受到`authentication challenge`返回的时候调用。 SecTrustRef可以理解为桥接证书与认证策略的对象，他关联指定的证书与认证策略 @param serverTrust 服务器的X.509标准的证书数据 @param domain 认证服务器的主机名。如果是nil,则不会对主机名进行认证。 @return serverTrust是否通过认证 */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // \"Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors.\" NSLog(@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\"); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; //使用需要认证主机名的认证策略 [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; //使用默认的认证策略 [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; //给serverTrust对象指定认证策略 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; return NO; &#125; //根据证书验证策略、数字签名认证策略、其他认证策略来处理不同情况 switch (self.SSLPinningMode) &#123; case AFSSLPinningModeNone://不验证公钥和证书 default: return NO; case AFSSLPinningModeCertificate: &#123;//验证整个证书 NSMutableArray *pinnedCertificates = [NSMutableArray array]; //根据指定证书获取，获取对应的证书对象 for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; //把证书与serverTrust关联起来 SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA) //获取serverTrust证书链。直到根证书。 NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); //如果`pinnedCertificates`包含`serverTrust`对象对应的证书链的根证书。则返回true for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; return YES; &#125; &#125; return NO; &#125; case AFSSLPinningModePublicKey: &#123;//只验证证书里面的数字签名 NSUInteger trustedPublicKeyCount = 0; //根据serverTrust对象和SecPolicyCreateBasicX509认证策略，获取对应的公钥集合 NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); for (id trustChainPublicKey in publicKeys) &#123; //把获取的公钥和系统获取的默认公钥比较，如果相等，则通过认证 for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125;#pragma mark - NSKeyValueObserving+ (NSSet *)keyPathsForValuesAffectingPinnedPublicKeys &#123; return [NSSet setWithObject:@\"pinnedCertificates\"];&#125;#pragma mark - NSSecureCoding+ (BOOL)supportsSecureCoding &#123; return YES;&#125;- (instancetype)initWithCoder:(NSCoder *)decoder &#123; self = [self init]; if (!self) &#123; return nil; &#125; self.SSLPinningMode = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(SSLPinningMode))] unsignedIntegerValue]; self.allowInvalidCertificates = [decoder decodeBoolForKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; self.validatesDomainName = [decoder decodeBoolForKey:NSStringFromSelector(@selector(validatesDomainName))]; self.pinnedCertificates = [decoder decodeObjectOfClass:[NSArray class] forKey:NSStringFromSelector(@selector(pinnedCertificates))]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder &#123; [coder encodeObject:[NSNumber numberWithUnsignedInteger:self.SSLPinningMode] forKey:NSStringFromSelector(@selector(SSLPinningMode))]; [coder encodeBool:self.allowInvalidCertificates forKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; [coder encodeBool:self.validatesDomainName forKey:NSStringFromSelector(@selector(validatesDomainName))]; [coder encodeObject:self.pinnedCertificates forKey:NSStringFromSelector(@selector(pinnedCertificates))];&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFSecurityPolicy *securityPolicy = [[[self class] allocWithZone:zone] init]; securityPolicy.SSLPinningMode = self.SSLPinningMode; securityPolicy.allowInvalidCertificates = self.allowInvalidCertificates; securityPolicy.validatesDomainName = self.validatesDomainName; securityPolicy.pinnedCertificates = [self.pinnedCertificates copyWithZone:zone]; return securityPolicy;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"http://yoursite.com/tags/AFNetWorking原理/"},{"name":"Encryption","slug":"Encryption","permalink":"http://yoursite.com/tags/Encryption/"}]},{"title":"AFNetWorking原理(一) AFURLSessionManager解读","slug":"AFNetWorking原理","date":"2019-06-21T15:48:30.000Z","updated":"2019-06-25T03:19:09.896Z","comments":true,"path":"2019/06/21/AFNetWorking原理/","link":"","permalink":"http://yoursite.com/2019/06/21/AFNetWorking原理/","excerpt":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。","text":"NSURLSession 是 iOS7 时推出的，为了取代 NSURLConnection（在iOS9废弃），AFNetWorking使用 NSURLSession 作为基础的网络请求类。NSURLSession 工作在在 OSI 七层模型 的会话层，会话层之下的所有工作，系统都已经帮我们做好了，所以 NSURLSession 可以理解为会话。 AFNetworking由5个模块组成 NSURLSession：网络通信模块（核心模块） AFURLSessionManager 对NSURLSession的封装 AFHTTPSessionManager 是继承于 AFURLSessionmanager Security：网络通讯安全策略模块 AFSecurityPolicy Reachability：网络状态监听模块 AFNetworkReachabilityManager Seriaalization：网络通信信息序列化、反序列化模块 AFHTTPRequestSerializer AFURLResponseSerialization UIKit：对于iOS UIKit的扩展库 网络请求类 AFURLSessionManager声明.h文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226// AFURLSessionManager类实现了NSURLSession相关的众多协议，用于帮助我们进行数据的处理@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;// NSURLSession 作为一个实例变量，AFN发起的网络请求都是通过该session创建的task实现的@property (readonly, nonatomic, strong) NSURLSession *session;// NSURLSession delegate方法执行队列@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;// 响应序列化 不能为nil@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;// 安全策略，用于https等需要验证的地方@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;#if !TARGET_OS_WATCH（生成的代码将在Apple Watch操作系统下运行）///--------------------------------------/// @name Monitoring Network Reachability///--------------------------------------// 监测网络连通性，使用AFNetworkReachabilityManager@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;#endif///----------------------------/// @name Getting Session Tasks///----------------------------// session管理的data upload download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;// session管理的data task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;// session管理的upload task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;// session管理的download task的集合@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;///-------------------------------/// @name Managing Callback Queues///-------------------------------// 完成网络请求后执行回调块的队列，如果为nil则使用主队列@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;// 完成网络请求后回调块的@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;///---------------------------------/// @name Working Around System Bugs///---------------------------------// background类型的session是否尝试重新创建上传任务@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;///---------------------/// @name Initialization///---------------------// 初始化函数，根据指定NSURLSessionConfiguration创建session- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;// 设置session无效，cancelPendingTasks标识是否取消session中正在执行的任务// 内部还是调用NSURLSession的invalidate方法- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;///-------------------------/// @name Running Data Tasks///-------------------------// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler DEPRECATED_ATTRIBUTE;// 根据指定的request创建一个NSURLSessionDataTask任务- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///---------------------------/// @name Running Upload Tasks///---------------------------// 根据指定request fileURL等参数构造一个NSURLSessionUploadTask任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 根据指定request和data等参数构造一个上传任务- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// 创建一个具有特定数据流的NSURLSessionUploadTask请求，上传的body使用的是request.HTTPBodyStream- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///-----------------------------/// @name Running Download Tasks///-----------------------------// 构造下载任务- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;/*构造下载任务 断点续传根据未下载完成的数据，创建一个NSURLSessionDownloadTask对象。resumeData：未完成的下载数据destination：决定下载文件的存放路径的block。block中有两个参数，目标路径和服务器的响应。同时返回文件下载的URLcompletionHandler：当任务完成后completionHandler的block会被调用progress：下载进度block。每当下载进度更新时就会执行这个block*/- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;///---------------------------------/// @name Getting Progress for Tasks///---------------------------------// 根据NSURLSessionTask获取对应的任务完成进度NSProgress- (nullable NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task;// 根据NSURLSessionTask获取对应下载任务的进度NSProgress- (nullable NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task;///-----------------------------------------/// @name Setting Session Delegate Callbacks///-----------------------------------------// 设置session无效时执行的回调块- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;// 设置session收到challenge时执行的回调块- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;///--------------------------------------/// @name Setting Task Delegate Callbacks///--------------------------------------// 设置session需要新的流时执行的回调块- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;// 设置session的任务需要执行重定向时执行的回调块- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * _Nullable (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;// 设置Block用于当一个session的task接收到证书验证时调用。实际上依赖由NSURLSessionTaskDelegate 的 URLSession:task:didReceiveChallenge:completionHandler:.方法处理- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;// 设置Block每隔一段时间调用用来跟踪上传进度，实际上依赖由NSURLSessionTaskDelegate的 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法实现- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;// 设置一个当task完成时调用的Block- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;///-------------------------------------------/// @name Setting Data Task Delegate Callbacks///-------------------------------------------// 设置一个当DataTask请求接收到响应时调用的block。交由NSURLSessionDataDelegate的URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;// 设置当一个dataTask转变成downloadTak时调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didBecomeDownloadTask:.方法处理- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;// 设置当一个dataTask接受到数据时就调用的block，交由NSURLSessionDataDelegate 的 URLSession:dataTask:didReceiveResponse:completionHandler:.方法处理- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;// 设置当一个dataTask对请求结果的缓冲时的block。交由NSURLSessionDataDelegate 的 URLSession:dataTask:willCacheResponse:completionHandler:.方法处理- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;// 设置当session中所有消息都被发送时，调用的block。交由NSURLSessionDataDelegate的URLSessionDidFinishEventsForBackgroundURLSession：方法实现- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block AF_API_UNAVAILABLE(macos);///-----------------------------------------------/// @name Setting Download Task Delegate Callbacks///-----------------------------------------------// 设置一个当下载任务完成一个下载时调用的block。最终交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didFinishDownloadingToURL:.方法处理- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;// 设置每次追踪下载进度时调用的block，最终交由NSURLSessionDownloadDelegate的URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite：方法处理- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;// 设置一个block，当任务重新下载时调用。交由NSURLSessionDownloadDelegate 的 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:.方式- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;@end///--------------------/// @name Notifications///--------------------FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidSuspendNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDidInvalidateNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseDataKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteAssetPathKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteErrorKey;NS_ASSUME_NONNULL_END 通过头文件可以发现，AFURLSessionManager是封装了NSURLSession并实现了其相关的所有协议，提供了一系列方法用于构造各种网络请求任务，并提供回调块进行处理，还提供了一系列设置代理方法执行时的执行回调块的方法，这样，我们也可以监听整个网络请求的过程，当然也可以忽略这些代理方法执行情况，提供了各种通知，通过头文件可以看出，主要目的还是为了封装NSURLSession从而提供更加便捷的方法来实现网络请求。 实现.m文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef NSFoundationVersionNumber_iOS_8_0#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11#else#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0#endif//C静态函数，GCD只执行一次，用于创建一个串行队列来执行各种网络请求任务的创建工作static dispatch_queue_t url_session_manager_creation_queue() &#123; static dispatch_queue_t af_url_session_manager_creation_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_creation_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.creation\", DISPATCH_QUEUE_SERIAL); &#125;); return af_url_session_manager_creation_queue;&#125;/*C静态函数，用于执行创建网络请求任务的block主要目的是为了解决ios8以下存在的一个block和task不匹配的bug上面那个队列也是为了解决这个bug才创建的具体可查看Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093*/static void url_session_manager_create_task_safely(dispatch_block_t block) &#123; if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123; dispatch_sync(url_session_manager_creation_queue(), block); &#125; else &#123; block(); &#125;&#125;//C静态函数，创建一个并发队列，用于在网络请求任务完成后处理数据的，并发队列实现多线程处理多个请求完成后的数据处理static dispatch_queue_t url_session_manager_processing_queue() &#123; static dispatch_queue_t af_url_session_manager_processing_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_processing_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.processing\", DISPATCH_QUEUE_CONCURRENT); &#125;); return af_url_session_manager_processing_queue;&#125;//C静态函数创建一个dispatch的组//但在接下来的源码中并没有使用这个组来实现notify等功能，仅仅是将block和组关联了，不太清楚具体用意//有明白的读者还请不吝赐教static dispatch_group_t url_session_manager_completion_group() &#123; static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_completion_group = dispatch_group_create(); &#125;); return af_url_session_manager_completion_group;&#125;//一系列通知名称的定义NSString * const AFNetworkingTaskDidResumeNotification = @\"com.alamofire.networking.task.resume\";NSString * const AFNetworkingTaskDidCompleteNotification = @\"com.alamofire.networking.task.complete\";NSString * const AFNetworkingTaskDidSuspendNotification = @\"com.alamofire.networking.task.suspend\";NSString * const AFURLSessionDidInvalidateNotification = @\"com.alamofire.networking.session.invalidate\";NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification = @\"com.alamofire.networking.session.download.file-manager-error\";NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey = @\"com.alamofire.networking.task.complete.serializedresponse\";NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey = @\"com.alamofire.networking.task.complete.responseserializer\";NSString * const AFNetworkingTaskDidCompleteResponseDataKey = @\"com.alamofire.networking.complete.finish.responsedata\";NSString * const AFNetworkingTaskDidCompleteErrorKey = @\"com.alamofire.networking.task.complete.error\";NSString * const AFNetworkingTaskDidCompleteAssetPathKey = @\"com.alamofire.networking.task.complete.assetpath\";//需要使用的NSLock锁的名称static NSString * const AFURLSessionManagerLockName = @\"com.alamofire.networking.session.manager.lock\";//background session重试创建上传任务次数static NSUInteger const AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = 3; 对于url_session_manager_create_task_safely这个有什么用？其实这个是被当做是一个在ios8以下，NSURLSessionDataTask出现的一个Bug。问题产生的原因就是当队列是并发的，这是当两个任务同时在不同的线程上创建任务的时候taskIdentifier可能是一样的。大致的意思就是当我们同时创建两个任务，返回了重复的taskIdentifier，这样的话第一个被创建的completionHandler就会被清空，被第二个任务的completionHandler给替换，如果第一个数据是早于第二个数据返回的，那么第一个数据返回之后就会去调用第二个任务的completionHandler。 12345678910111213141516171819202122typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session, NSError *error);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef NSURLRequest * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef void (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(NSURLSession *session);typedef NSInputStream * (^AFURLSessionTaskNeedNewBodyStreamBlock)(NSURLSession *session, NSURLSessionTask *task);typedef void (^AFURLSessionTaskDidSendBodyDataBlock)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);typedef void (^AFURLSessionTaskDidCompleteBlock)(NSURLSession *session, NSURLSessionTask *task, NSError *error);typedef NSURLSessionResponseDisposition (^AFURLSessionDataTaskDidReceiveResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response);typedef void (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask);typedef void (^AFURLSessionDataTaskDidReceiveDataBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data);typedef NSCachedURLResponse * (^AFURLSessionDataTaskWillCacheResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse);typedef NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);typedef void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);typedef void (^AFURLSessionDownloadTaskDidResumeBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);typedef void (^AFURLSessionTaskProgressBlock)(NSProgress *);typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response, id responseObject, NSError *error); 定义一些回调的block 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248//定义了一个类AFURLSessionManagerTaskDelegate并实现了NSURLSessionTask的相关协议//这个类是用于处理NSURLSessionTask相关代理方法的@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;//初始化构造函数，需要传入一个关联的task- (instancetype)initWithTask:(NSURLSessionTask *)task;//weak修饰的manager@property (nonatomic, weak) AFURLSessionManager *manager;//可变data用于存储获取到的网络数据@property (nonatomic, strong) NSMutableData *mutableData;//上传进度NSProgress@property (nonatomic, strong) NSProgress *uploadProgress;//下载进度NSProgress@property (nonatomic, strong) NSProgress *downloadProgress;//下载文件的NSURL@property (nonatomic, copy) NSURL *downloadFileURL;//下载完成的回调块@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;//上传进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;//下载进度的回调块@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;//网络请求完成的回调块@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;@end@implementation AFURLSessionManagerTaskDelegate//初始化构造函数- (instancetype)initWithTask:(NSURLSessionTask *)task &#123; self = [super init]; if (!self) &#123; return nil; &#125; _mutableData = [NSMutableData data]; _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; //遍历两个上传和下载NSProgress设置一些属性 __weak __typeof__(task) weakTask = task; for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ]) &#123; //初始化progress progress.totalUnitCount = NSURLSessionTransferSizeUnknown; progress.cancellable = YES; //设置取消进度的回调块，执行task的cancel方法 progress.cancellationHandler = ^&#123; [weakTask cancel]; &#125;; progress.pausable = YES; //设置暂停进度的回调块，执行task的suspend方法 progress.pausingHandler = ^&#123; [weakTask suspend]; &#125;; //设置重新开始的回调块，执行task的resume方法 if ([progress respondsToSelector:@selector(setResumingHandler:)]) &#123; progress.resumingHandler = ^&#123; [weakTask resume]; &#125;; &#125; //progress添加kvo，监听progress的进度fractionCompleted [progress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; &#125; return self;&#125;//析构函数- (void)dealloc &#123; //删除KVO [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];&#125;#pragma mark - NSProgress Tracking//KVO回调方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; //上次或下载进度有改变时，执行上传或下载进度回调块 if ([object isEqual:self.downloadProgress]) &#123; if (self.downloadProgressBlock) &#123; self.downloadProgressBlock(object); &#125; &#125; else if ([object isEqual:self.uploadProgress]) &#123; if (self.uploadProgressBlock) &#123; self.uploadProgressBlock(object); &#125; &#125;&#125;#pragma mark - NSURLSessionTaskDelegate//代理方法，网络请求完成或出错- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //manager用weak修饰，这里strong一下防止manager被释放 __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; //为userInfo字典设置响应序列化 userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 //赋值mutableData到data中，并释放mutableData NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; &#125; //如果downloadFileURL存在，即是下载任务就设置下载完成后的文件存储url到字典中 if (self.downloadFileURL) &#123; userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; &#125; else if (data) &#123; //否则就设置对应的NSData数据到字典中 userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; &#125; //如果网络请求有错误 if (error) &#123; //设置error信息到字典中 userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; /* 这个三目运算符需要解释一下，在其他语言中这么写很可能就是语法错误 这里的意思就是如果manager.completionGroup存在就使用它 不存在就使用url_session_manager_completion_group函数返回的group 后面的三目运算符同理 所以如果自己不设置manager的completionGroup或completionQueue就会使用默认提供的 */ //执行对应的completionHandler回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, error); &#125; //在主队列即主线程中发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125; else &#123; //如果网络任务成功完成，异步在并发队列中执行数据处理 dispatch_async(url_session_manager_processing_queue(), ^&#123; //序列化响应数据 NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; //如果是下载任务设置响应数据为文件的url if (self.downloadFileURL) &#123; responseObject = self.downloadFileURL; &#125; //如果响应对象序列化成功或是文件url就设置相关字典key-value if (responseObject) &#123; userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; &#125; //如果序列化出错，设置相关字典值 if (serializationError) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; &#125; //同理，在dispatch组中和特定队列执行回调块 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; //主线程发送通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); &#125;&#125;#pragma mark - NSURLSessionDataDelegate//回调方法，收到数据- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive; self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived; //添加数据到mutableData [self.mutableData appendData:data];&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //设置上传进度的相关属性 self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.uploadProgress.completedUnitCount = task.countOfBytesSent;&#125;#pragma mark - NSURLSessionDownloadDelegate//下载任务的回调方法//由于NSURLSession的downloadTask直接将文件下载到磁盘沙盒中，所以不需要mutableData自行接收数据- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = totalBytesExpectedToWrite; self.downloadProgress.completedUnitCount = totalBytesWritten;&#125;//恢复下载任务的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; //设置下载进度的相关属性 self.downloadProgress.totalUnitCount = expectedTotalBytes; self.downloadProgress.completedUnitCount = fileOffset;&#125;//下载任务下载文件完成后的回调方法//location就是文件下载到磁盘沙盒目录的NSURL- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //设置downloadFileURL为nil self.downloadFileURL = nil; //如果有下载完成的回调块 if (self.downloadTaskDidFinishDownloading) &#123; //执行该回调块，这个回调块返回一个下载的文件保存的路径URL //默认保存在沙盒tmp文件中，可能会被删除，需要持久化时要自己设置一个目录存储 self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果需要移动文件的路径使用NSFileManaegr移动 if (self.downloadFileURL) &#123; NSError *fileManagerError = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123; //文件移动发生错误发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; &#125; &#125; &#125;&#125;@end AFURLSessionManagerTaskDelegate的源码，主要就是关联一个NSURLSessionTask并实现了相关任务的代理方法用于数据的获取、上传文件和下载文件。需要注意的是NSURLSessionTask的delegate属性是只读的，只能在使用session创建task的函数中传入代理对象，而且通过源码也没有发现相关代理的设置，所以AFURLSessionManagerTaskDelegate类实现相关代理是为了其他类手动调用相关方法，AFURLSessionManager也实现了这些代理，所以具体的调用是由AFURLSessionManger手动触发的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(theClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123; return class_addMethod(theClass, selector, method_getImplementation(method), method_getTypeEncoding(method));&#125;static NSString * const AFNSURLSessionTaskDidResumeNotification = @\"com.alamofire.networking.nsurlsessiontask.resume\";static NSString * const AFNSURLSessionTaskDidSuspendNotification = @\"com.alamofire.networking.nsurlsessiontask.suspend\";@interface _AFURLSessionTaskSwizzling : NSObject@end@implementation _AFURLSessionTaskSwizzling+ (void)load &#123; /** WARNING: Trouble Ahead https://github.com/AFNetworking/AFNetworking/pull/2702 */ if (NSClassFromString(@\"NSURLSessionTask\")) &#123; /** iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky. Many Unit Tests have been built to validate as much of this behavior has possible. Here is what we know: - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn't actually the type of class you will get back. - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there. - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`. - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`. - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled. - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled. - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there. Some Assumptions: - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we'd need to handle it. - No background task classes override `resume` or `suspend` The current solution: 1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task. 2) Grab a pointer to the original implementation of `af_resume` 3) Check to see if the current class has an implementation of resume. If so, continue to step 4. 4) Grab the super class of the current class. 5) Grab a pointer for the current class to the current implementation of `resume`. 6) Grab a pointer for the super class to the current implementation of `resume`. 7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods 8) Set the current class to the super class, and repeat steps 3-8 */ NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];#pragma GCC diagnostic push#pragma GCC diagnostic ignored \"-Wnonnull\" NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];#pragma clang diagnostic pop IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume))); Class currentClass = [localDataTask class]; while (class_getInstanceMethod(currentClass, @selector(resume))) &#123; Class superClass = [currentClass superclass]; IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume))); IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume))); if (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; [self swizzleResumeAndSuspendMethodForClass:currentClass]; &#125; currentClass = [currentClass superclass]; &#125; [localDataTask cancel]; [session finishTasksAndInvalidate]; &#125;&#125;+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123; Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume)); Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend)); if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123; af_swizzleSelector(theClass, @selector(resume), @selector(af_resume)); &#125; if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123; af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend)); &#125;&#125;- (NSURLSessionTaskState)state &#123; NSAssert(NO, @\"State method should never be called in the actual dummy class\"); return NSURLSessionTaskStateCanceling;&#125;- (void)af_resume &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_resume]; if (state != NSURLSessionTaskStateRunning) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self]; &#125;&#125;- (void)af_suspend &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_suspend]; if (state != NSURLSessionTaskStateSuspended) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self]; &#125;&#125;@end 这里用到了method-swizzling的技术，交换了 resume 和 suspend方法的实现，因为iOS7和iOS8中NSURLSessionTask的父类不同，需要做一些处理（发送task暂停、继续通知）。 123456789101112131415161718192021222324252627282930313233@interface AFURLSessionManager ()//管理的session运行模式，默认情况下使用默认运行模式，defaultConfiguration@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;/*NSOperation队列，代理方法执行的队列.h文件里是readonly，所以这里定义一个readwrite用于赋值*/@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;//管理的session，readwrite@property (readwrite, nonatomic, strong) NSURLSession *session;//可变字典，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;//只读属性，通过getter返回数据@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;//NSLock锁@property (readwrite, nonatomic, strong) NSLock *lock;//下面是一系列回调块@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;@end 延展里面定义了一些属性和响应的回调block。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation AFURLSessionManager//构造函数- (instancetype)init &#123; return [self initWithSessionConfiguration:nil];&#125;//构造函数- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; //如果没有指定session运行模式就使用默认的 if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; //创建代理方法执行的队列，最大并发数为1，即串行队列 //感觉这里设置为1是为了让回调一个个执行 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; //创建session，注意代理对象是self self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; //创建响应序列化器 self.responseSerializer = [AFJSONResponseSerializer serializer]; //设置默认安全策略 self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH //获取网络可达性manager self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; //创建锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* 获取session中的任务，并调用相关方法关联AFURLSessionManagerTaskDelegate 不太明白这里为什么要这么做，刚创建的session应该没有任何任务在执行 */ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self;&#125;//析构方法，移除所有通知监听- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 初始化方法里面有一个有一个不明白的点，创建完session之后就去获取它正在执行的任务，刚创建完session为何会有任务呢？这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。 1234567891011121314151617181920212223242526272829//taskDescriptionForSessionTasks属性的getter，返回地址的字符串形式数据，可以保证这个字符串是唯一的- (NSString *)taskDescriptionForSessionTasks &#123; return [NSString stringWithFormat:@\"%p\", self];&#125;//通知的回调方法，接下来的代码会添加相关通知- (void)taskDidResume:(NSNotification *)notification &#123; //发送通知的时候会将task添加进通知中 NSURLSessionTask *task = notification.object; //判断这个任务是否是当前manager管理的，如果是就发送相关通知 //task的taskDescription属性在下文的源码中会设置 if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task]; &#125;); &#125; &#125;&#125;//同上- (void)taskDidSuspend:(NSNotification *)notification &#123; NSURLSessionTask *task = notification.object; if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task]; &#125;); &#125; &#125;&#125; 上面的代码就是通知的回调方法，用于通知resume和suspend事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//根据task获取相关联的AFURLSessionManagerTaskDelegate对象- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123; //task不能为空 NSParameterAssert(task); //上锁，通过task的唯一taskIdentifier从字典中取值，这个唯一标识是在创建task的时候NSURLSessionTask为其设置的，不需要手动设置，保证唯一性 AFURLSessionManagerTaskDelegate *delegate = nil; [self.lock lock]; delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate;&#125;//为task设置关联的delegate- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; //task和delegate都不能为空 NSParameterAssert(task); NSParameterAssert(delegate); //上锁，向字典中添加key-value对 [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125;//重点方法，为dataTask创建一个关联的AFURLSessionManagerTaskDelegate对象- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; //创建AFURLSessionManagerTaskDelegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; //设置相关属性 delegate.manager = self; delegate.completionHandler = completionHandler; /* 设置task的taskDescription，注意和taskIdentifier区分 taskDescription是开发者自行设置的 taskIdentifier是NSURLSessionTask设置的，保证每一个task的id不同 这里设置的taskDescription就是AFURLSessionManager的地址 所以同一个manager创建的task的description都是一致的 设置这个值的目的就是为了区分task是否是当前manger创建的 */ dataTask.taskDescription = self.taskDescriptionForSessionTasks; //调用上面的方法将task-delegate键值对添加进字典中 [self setDelegate:delegate forTask:dataTask]; //设置回调块 delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//同上，创建上传任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; uploadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:uploadTask]; delegate.uploadProgressBlock = uploadProgressBlock;&#125;//同上，创建下载文件任务的AFURLSessionManagerTaskDelegate对象，并加入到字典中- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; /* 需要注意下，AFURLSessionManagerTaskDelegate中下载文件完成后会调用delegate.downloadTaskDidFinishDownloading回调块 来获取下载文件要移动到的目录URL 所以这里就是创建这个回调块，直接返回参数中的destination回调块 */ if (destination) &#123; delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123; return destination(location, task.response); &#125;; &#125; downloadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:downloadTask]; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//从字典中删除task对应的delegate的key-value对- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); [self.lock lock]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; 上面的代码就是对AFURLSessionManagerTaskDelegate的创建、添加进字典、删除、获取的操作，这样就实现了每一个NSURLSessionTask对应一个AFURLSessionManagerTaskDelegate对象，可能读者会有疑问，AFURLSessionManager既然已经实现了代理的方法，为什么不直接使用它来处理代理方法，为什么要创建一个类来专门处理，继续看完源码可能你就会明白了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//根据keyPath获取不同类型任务的集合- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray *tasks = nil; //创建一个信号量，值是0 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); //这个方法是异步的，所以为了同步返回结果，需要使用锁，信号量值设置为0或者1时就可以当锁来使用了 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks = dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks = uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks = downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@\"@unionOfArrays.self\"]; &#125; //signal通知信号量，信号量值加1 dispatch_semaphore_signal(semaphore); &#125;]; //等待信号量，直到值大于0，等待时间是forever dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125;//下面是tasks、dataTasks、uploadTasks、downloadTasks属性的getter，都是调用上述方法来获取对应类型的任务集合- (NSArray *)tasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)dataTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)uploadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)downloadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;#pragma mark -//设置session无效，根据参数判断是否需要取消正在执行的任务- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks &#123; //调用NSURLSession对应的方法来设置session无效，同时打破引用循环 if (cancelPendingTasks) &#123; [self.session invalidateAndCancel]; &#125; else &#123; [self.session finishTasksAndInvalidate]; &#125;&#125;#pragma mark -//responseSerializer的setter- (void)setResponseSerializer:(id &lt;AFURLResponseSerialization&gt;)responseSerializer &#123; NSParameterAssert(responseSerializer); _responseSerializer = responseSerializer;&#125;#pragma mark -//添加通知，taskDidResume、taskDidSuspend方法前面讲过了- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];&#125;//删除通知- (void)removeNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidSuspendNotification object:task]; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidResumeNotification object:task];&#125; 上面的方法是一些getter和setter，很简单，不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];&#125;//创建并返回NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; //为了解决iOS8一下的一个bug，调用一个串行队列来创建dataTask __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^&#123; //使用session来创建一个NSURLSessionDataTask对象 dataTask = [self.session dataTaskWithRequest:request]; &#125;); //为这个task创建一个AFURLSessionManagerTaskDelegate并关联加入字典中 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125;#pragma mark -//创建一个NSURLSessionUploadTask对象- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125;); // uploadTask may be nil on iOS7 because uploadTaskWithRequest:fromFile: may return nil despite being documented as nonnull (https://devforums.apple.com/message/926113#926113) //解决iOS7的一个bug按照配置的尝试次数创建上传任务，默认尝试3次 if (!uploadTask &amp;&amp; self.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; self.session.configuration.identifier) &#123; for (NSUInteger attempts = 0; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125; &#125; //创建关联的delegate并添加到字典中 [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//同上- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;#pragma mark -//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithRequest:request]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125;//创建下载任务，同上- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithResumeData:resumeData]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125; 上面的方法就是AFURLSessionManager为我们提供的获取NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask的方法，上面这些方法主要目的就是传入进度或完成回调块，然后构造一个AFURLSessionManagerTaskDeleagte对象并关联，这样就不需要开发者自行实现和管理代理方法做相关数据处理，只需要在回调块中做处理即可。 接下来源码中是一系列回调块的setter方法，就不列下来了，读者可以自己看看。接下来就讲解重点的各种代理的回调方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//session无效后的回调方法- (void)URLSession:(NSURLSession *)sessiondidBecomeInvalidWithError:(NSError *)error&#123; //如果回调块存在就执行回调块 if (self.sessionDidBecomeInvalid) &#123; self.sessionDidBecomeInvalid(session, error); &#125; //发送对应通知 [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];&#125;//收到服务端的challenge，例如https需要验证证书等- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; //如果有对应回调块就执行 if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; //处理https if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; 上面两个方法是NSURLSessionDelegate的方法，关于验证HTTPS的部分代码可以当做模板代码来写，具体内容不是本文讲解范畴，读者可自行查阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//要执行重定向的代理方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskwillPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler&#123; //套路就是执行用户自定义的回调块，执行完成回调块 NSURLRequest *redirectRequest = request; if (self.taskWillPerformHTTPRedirection) &#123; redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request); &#125; if (completionHandler) &#123; completionHandler(redirectRequest); &#125;&#125;//同前面一样，处理https链接- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (self.taskDidReceiveAuthenticationChallenge) &#123; disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential); &#125; else &#123; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125;//处理需要一个新的流- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler&#123; //调用用户自定义的回调块来获取，或者copy一个 NSInputStream *inputStream = nil; if (self.taskNeedNewBodyStream) &#123; inputStream = self.taskNeedNewBodyStream(session, task); &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123; inputStream = [task.originalRequest.HTTPBodyStream copy]; &#125; if (completionHandler) &#123; completionHandler(inputStream); &#125;&#125;//上传任务的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //获取上传的总大小，如果数据不正确就从http首部中获取 int64_t totalUnitCount = totalBytesExpectedToSend; if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123; NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@\"Content-Length\"]; if(contentLength) &#123; totalUnitCount = (int64_t) [contentLength longLongValue]; &#125; &#125; //获取task关联的AFURLSessionManagerTaskDelegate对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; //如果代理对象存在，就调用代理对象的这个方法 if (delegate) &#123; [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend]; &#125; //如果用户自定义回调块存在，执行回调块 if (self.taskDidSendBodyData) &#123; self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount); &#125;&#125;//任务完成的回调方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //同样的套路，获取关联的代理对象，手动调用代理对象的这个方法，执行用户自定义的回调块 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; &#125; if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error); &#125;&#125; 以上代码是NSURLSessionTaskDelegate的回调方法，通过上面的代码可以发现AFURLSessionManagerTaskDelegate的作用了，AFURLSessionManager的代理方法中会根据task获取到对应的delegate，如果需要提前处理一些数据就先处理，处理完成后手动触发delegate中的对应方法，然后具体的数据处理就交由AFURLSessionManagerTaskDelegate来处理。继续看其他代理方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//收到服务端响应的代理回调方法- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; //调用用户自定义回调块，执行完成回调块 NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; if (self.dataTaskDidReceiveResponse) &#123; disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; if (completionHandler) &#123; completionHandler(disposition); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; if (delegate) &#123; [self removeDelegateForTask:dataTask]; [self setDelegate:delegate forTask:downloadTask]; &#125; if (self.dataTaskDidBecomeDownloadTask) &#123; self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //获取代理，然后调用代理的这个方法，有自定义回调块就执行 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; [delegate URLSession:session dataTask:dataTask didReceiveData:data]; if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (self.dataTaskWillCacheResponse) &#123; cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse); &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125;- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123; if (self.didFinishEventsForBackgroundURLSession) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.didFinishEventsForBackgroundURLSession(session); &#125;); &#125;&#125; 上面的代码是NSURLSessionDataDelegate的代理方法，同样的，如果AFURLSessionManagerTaskDelegate能响应的关于数据处理的方法都会通过task找到对应delegate后调用其对应的方法，然后执行用户自定义的回调块，如果代理不能响应的方法就由AFURLSessionManager自行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//下载任务下载文件完成后的回调方法- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //获取对应的代理对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果downloadTaskDidFinishDownloading回调块存在就执行它来获取一个保存文件的URL路径 if (self.downloadTaskDidFinishDownloading) &#123; NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //如果这个路径存在就通过NSFileManager来移动，移动失败发送通知 if (fileURL) &#123; delegate.downloadFileURL = fileURL; NSError *error = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo]; &#125; return; &#125; &#125; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location]; &#125;&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //通过task获取delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //如果delegate存在就调用其该方法 if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite]; &#125; //如果回调块存在就执行 if (self.downloadTaskDidWriteData) &#123; self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite); &#125;&#125;//同上套路- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes]; &#125; if (self.downloadTaskDidResume) &#123; self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes); &#125;&#125; 到现在为止，AFURLSessionManager所有源码都看完了，代码封装了NSURLSession并提供了简洁的创建NSURLSessionDataTask、NSURLSessionUploadTask和NSURLSessionDownloadTask对象的方法，使用人员可以不需要考虑具体的数据处理过程，最简单的可以只通过回调块来获取网络请求的各种信息。在具体实现上，AFURLSessionManager通过定义AFURLSessionManagerTaskDelegate来做具体task的数据处理，而AFURLSessionManager只关注于通用部分的实现，并提供各种方法和回调块用于处理task，使得代码结构更清晰，AFURLSessionManager代理方法结构也更简单。 AFURLSessionManager个人总结 AFURLSessionManagerTaskDelegate 是为了对应每一个task，单独定义一个类，解耦合，代码逻辑更清晰 mutableData 在请求完成之后置位 nil，节省内存 dispatch_semaphore的使用，信号量线程同步 method swizzing巧妙监听 task 的 suspend 和 resume NSLock 安全加锁，避免字典中假如的 delegate 和 task不对应","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"AFNetWorking原理","slug":"AFNetWorking原理","permalink":"http://yoursite.com/tags/AFNetWorking原理/"}]},{"title":"Github Blog With Hexo","slug":"hello-world","date":"2019-06-21T07:40:42.265Z","updated":"2019-06-24T10:16:01.754Z","comments":true,"path":"2019/06/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/21/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}