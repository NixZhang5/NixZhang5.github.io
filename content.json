{"meta":{"title":"Xinping's Blog","subtitle":"å› ä¸ºæœ‰äº†å±æœºæ„Ÿï¼Œæ‰€ä»¥æ‰ä¼šä¹‰æ— åé¡¾ã€‚","description":"ç§¯ç´¯ è®°å½• ä¼ æ’­ å…±è¿›","author":"å¼ æ–°å¹³","url":"https://nixzhang5.github.io","root":"/"},"pages":[{"title":"åˆ†ç±»","date":"2019-06-24T10:03:14.000Z","updated":"2019-06-24T10:25:07.974Z","comments":true,"path":"categories/index.html","permalink":"https://nixzhang5.github.io/categories/index.html","excerpt":"","text":""},{"title":"æ ‡ç­¾","date":"2019-06-24T10:08:50.000Z","updated":"2019-06-24T10:25:34.397Z","comments":true,"path":"tags/index.html","permalink":"https://nixzhang5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AFNetWorkingåŸç†ä¸‰ AFURLRequestSerialization","slug":"AFNetWorkingåŸç†ä¸‰","date":"2019-06-27T03:28:59.000Z","updated":"2019-06-27T10:41:03.556Z","comments":true,"path":"AFNetWorkingåŸç†ä¸‰.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorkingåŸç†ä¸‰.html","excerpt":"AFURLRequestSerializationåŒ…å«äº†å››ä¸ªéƒ¨åˆ†ï¼š å…¨å±€æ–¹æ³•:AFPercentEscapedStringFromStringå’ŒAFQueryStringFromParametersã€‚ åè®®AFURLRequestSerializationæä¾›äº†ä¸€ä¸ªåºåˆ—åŒ–parameterså‚æ•°çš„æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥æŠŠå‚æ•°è½¬æ¢ä¸ºæŸ¥è¯¢å­—ç¬¦ä¸²ã€HTTPè¯·æ±‚ä½“ã€è®¾ç½®æ°å½“çš„è¯·æ±‚å¤´ç­‰ã€‚ AFHTTPRequestSerializerç»§æ‰¿è‡ªAFURLRequestSerializationåè®®ã€‚æä¾›äº†æŸ¥è¯¢å­—ç¬¦ä¸²/URLæ ¼å¼çš„å‚æ•°åºåˆ—åŒ–ã€é»˜è®¤è¯·æ±‚å¤´å¤„ç†ã€‚åŒæ—¶ä»¥æä¾›HTTPçŠ¶æ€ç å’Œè¿”å›æ•°æ®çš„éªŒè¯ç­‰å·¥ä½œã€‚_ AFMultipartFormDataåè®®ã€‚ä¸»è¦ç”¨äºæ·»åŠ multipart/form-dataè¯·æ±‚çš„Content-Disposition: file; filename=#{generated filename}; name=#{name}â€ å’Œ Content-Type: #{generated mimeType}çš„è¯·æ±‚ä½“åŸŸã€‚ ç±»å‹AFJSONRequestSerializerå’ŒAFPropertyListRequestSerializerã€‚ä¸»è¦é’ˆå¯¹JSONå’ŒPlistç±»å‹çš„åºåˆ—åŒ–ä¼˜åŒ–ã€‚","text":"AFURLRequestSerializationåŒ…å«äº†å››ä¸ªéƒ¨åˆ†ï¼š å…¨å±€æ–¹æ³•:AFPercentEscapedStringFromStringå’ŒAFQueryStringFromParametersã€‚ åè®®AFURLRequestSerializationæä¾›äº†ä¸€ä¸ªåºåˆ—åŒ–parameterså‚æ•°çš„æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥æŠŠå‚æ•°è½¬æ¢ä¸ºæŸ¥è¯¢å­—ç¬¦ä¸²ã€HTTPè¯·æ±‚ä½“ã€è®¾ç½®æ°å½“çš„è¯·æ±‚å¤´ç­‰ã€‚ AFHTTPRequestSerializerç»§æ‰¿è‡ªAFURLRequestSerializationåè®®ã€‚æä¾›äº†æŸ¥è¯¢å­—ç¬¦ä¸²/URLæ ¼å¼çš„å‚æ•°åºåˆ—åŒ–ã€é»˜è®¤è¯·æ±‚å¤´å¤„ç†ã€‚åŒæ—¶ä»¥æä¾›HTTPçŠ¶æ€ç å’Œè¿”å›æ•°æ®çš„éªŒè¯ç­‰å·¥ä½œã€‚_ AFMultipartFormDataåè®®ã€‚ä¸»è¦ç”¨äºæ·»åŠ multipart/form-dataè¯·æ±‚çš„Content-Disposition: file; filename=#{generated filename}; name=#{name}â€ å’Œ Content-Type: #{generated mimeType}çš„è¯·æ±‚ä½“åŸŸã€‚ ç±»å‹AFJSONRequestSerializerå’ŒAFPropertyListRequestSerializerã€‚ä¸»è¦é’ˆå¯¹JSONå’ŒPlistç±»å‹çš„åºåˆ—åŒ–ä¼˜åŒ–ã€‚ å·¥å…·å‡½æ•°AFPercentEscapedStringFromStringæŠŠå­—ç¬¦ä¸²è½¬åŒ–æˆç¬¦åˆæ ‡å‡†çš„URLç¼–ç å­—ç¬¦ä¸²ï¼Œä¸»è¦æ˜¯é€šè¿‡ä¸€ä¸ªå­—ç¬¦é›†NSMutableCharacterSetæ¥å®šä¹‰éœ€è¦è¿›è¡Œè½¬ç çš„å­—ç¬¦ï¼Œå†é€šè¿‡-[NSString stringByAddingPercentEncodingWithAllowedCharacters]æ–¹æ³•æ¥è¿›è¡Œè½¬ç ã€‚ 1234567891011121314151617181920212223242526272829303132333435AFURLRequestSerialization.hFOUNDATION_EXPORT NSString * AFPercentEscapedStringFromString(NSString *string);AFURLRequestSerialization.mNSString * AFPercentEscapedStringFromString(NSString *string) &#123; // does not include \"?\" or \"/\" due to RFC 3986 - Section 3.4 static NSString * const kAFCharactersGeneralDelimitersToEncode = @\":#[]@\"; static NSString * const kAFCharactersSubDelimitersToEncode = @\"!$&amp;'()*+,;=\"; NSMutableCharacterSet * allowedCharacterSet = [[NSCharacterSet URLQueryAllowedCharacterSet] mutableCopy]; [allowedCharacterSet removeCharactersInString:[kAFCharactersGeneralDelimitersToEncode stringByAppendingString:kAFCharactersSubDelimitersToEncode]]; static NSUInteger const batchSize = 50; NSUInteger index = 0; NSMutableString *escaped = @\"\".mutableCopy; while (index &lt; string.length) &#123; NSUInteger length = MIN(string.length - index, batchSize); NSRange range = NSMakeRange(index, length); // To avoid breaking up character sequences such as ğŸ‘´ğŸ»ğŸ‘®ğŸ½ range = [string rangeOfComposedCharacterSequencesForRange:range]; NSString *substring = [string substringWithRange:range]; NSString *encoded = [substring stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet]; [escaped appendString:encoded]; index += range.length; &#125; return escaped;&#125; AFQueryStringFromParametersæŠŠå­—å…¸è½¬åŒ–ä¸º&amp;æ‹¼æ¥çš„å‚æ•°ï¼Œé€šè¿‡AFQueryStringPairç±»æ¥å®ç°çš„ã€‚ AFQueryStringPairæ¥å­˜å–æ¯ä¸€ä¸ªæŸ¥è¯¢å±æ€§ï¼Œå°†æŸ¥è¯¢çš„é”®å€¼ä¿æŒèµ·æ¥ï¼Œç„¶åé€šè¿‡URLEncodedStringValueæ–¹æ³•åœ¨éœ€è¦æ—¶è¿›è¡Œæ‹¼æ¥ï¼Œå¹¶ä¸”ä½¿ç”¨äº†ä¸Šé¢æ‰€è¿°çš„AFPercentEscapedStringFromStringæ–¹æ³•è¿›è¡Œäº†URLEncodeã€‚å…¶ä¸­æœ€ä¸»è¦çš„æ–¹æ³•æ˜¯AFQueryStringPairsFromKeyAndValueï¼Œå®ƒå°†å­—å…¸çš„æ¯ä¸€ä¸ªé”®å€¼å¯¹ç”Ÿæˆçš„å¯¹åº”çš„AFQueryStringPairå¯¹è±¡ï¼Œä¾‹å¦‚å°†machine:[iphone, mac]è½¬æ¢ä¸ºURLEncodedStringValueå€¼æ˜¯machine[]=iphoneå’Œmachine[]=macçš„ä¸¤ä¸ªAFQueryStringPairå¯¹è±¡ã€‚ä¹‹åAFQueryStringFromParametersæ–¹æ³•å†ä»¥â€™&amp;â€™ç¬¦å·å¯¹å®ƒä»¬è¿›è¡Œæ‹¼æ¥ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788AFURLRequestSerialization.hFOUNDATION_EXPORT NSString * AFQueryStringFromParameters(NSDictionary *parameters);AFURLRequestSerialization.m@interface AFQueryStringPair : NSObject@property (readwrite, nonatomic, strong) id field;@property (readwrite, nonatomic, strong) id value;- (instancetype)initWithField:(id)field value:(id)value;- (NSString *)URLEncodedStringValue;@end@implementation AFQueryStringPair- (instancetype)initWithField:(id)field value:(id)value &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.field = field; self.value = value; return self;&#125;- (NSString *)URLEncodedStringValue &#123; if (!self.value || [self.value isEqual:[NSNull null]]) &#123; return AFPercentEscapedStringFromString([self.field description]); &#125; else &#123; return [NSString stringWithFormat:@\"%@=%@\", AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])]; &#125;&#125;@end#pragma mark -FOUNDATION_EXPORT NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary);FOUNDATION_EXPORT NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value);NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123; NSMutableArray *mutablePairs = [NSMutableArray array]; for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123; [mutablePairs addObject:[pair URLEncodedStringValue]]; &#125; return [mutablePairs componentsJoinedByString:@\"&amp;\"];&#125;NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123; return AFQueryStringPairsFromKeyAndValue(nil, dictionary);&#125;NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123; NSMutableArray *mutableQueryStringComponents = [NSMutableArray array]; NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"description\" ascending:YES selector:@selector(compare:)]; if ([value isKindOfClass:[NSDictionary class]]) &#123; NSDictionary *dictionary = value; // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123; id nestedValue = dictionary[nestedKey]; if (nestedValue) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@\"%@[%@]\", key, nestedKey] : nestedKey), nestedValue)]; &#125; &#125; &#125; else if ([value isKindOfClass:[NSArray class]]) &#123; NSArray *array = value; for (id nestedValue in array) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@\"%@[]\", key], nestedValue)]; &#125; &#125; else if ([value isKindOfClass:[NSSet class]]) &#123; NSSet *set = value; for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)]; &#125; &#125; else &#123; [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]]; &#125; return mutableQueryStringComponents;&#125; AFURLRequestSerializationå…ˆå£°æ˜äº†ä¸€ä¸ªåè®®AFURLRequestSerializationç»§æ‰¿äº†NSSecureCodingå’ŒNSCopyingæ¥ä¿è¯æ‰€æœ‰å®ç°è¿™ä¸ªåºåˆ—åŒ–åè®®çš„åºåˆ—åŒ–å™¨ç±»éƒ½æœ‰å®‰å…¨ç¼–ç å’Œå¤åˆ¶çš„èƒ½åŠ›ã€‚åè®®ä¹Ÿå®šä¹‰äº†åºåˆ—åŒ–çš„è§„èŒƒæ–¹æ³•ã€‚ï¼ˆåè®®ï¼Œæœ‰åˆ©äºæ‰©å±•ï¼‰ 1234567891011121314/** AFURLRequestSerializationåè®®å¯ä»¥è¢«ä¸€ä¸ªç¼–ç ç‰¹å®šhttpè¯·æ±‚çš„å¯¹è±¡å®ç°ã€‚ è¯·æ±‚åºåˆ—åŒ–å™¨ï¼ˆRequest serializerï¼‰å¯ä»¥ç¼–ç æŸ¥è¯¢è¯­å¥ã€HTTPè¯·æ±‚ä½“ï¼Œå¦‚æœå¿…é¡»çš„è¯ï¼Œå¯ä»¥è‡ªè¡Œè®¾ç½®åˆé€‚çš„HTTPè¯·æ±‚ä½“å†…å®¹ï¼ˆå¦‚ï¼šAgent:iOSï¼‰ã€‚ ä¾‹å¦‚ï¼Œä¸€ä¸ªJSONè¯·æ±‚åºåˆ—åŒ–å™¨ä¼šæŠŠè¯·æ±‚ä½“Content-Typeè®¾ç½®ä¸ºapplication/jsonã€‚*/@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;/** è¿”å›ä¸€ä¸ªä½¿ç”¨äº†æŒ‡å®šå‚æ•°ç¼–ç çš„è¯·æ±‚çš„æ‹·è´ã€‚*/- (nullable NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;@end AFHTTPRequestSerializerç¼“å­˜ç­–ç•¥1234567891011121314151617181920212223242526272829typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; /** é»˜è®¤ç¼“å­˜ç­–ç•¥ã€‚å…·ä½“å·¥ä½œï¼šå¦‚æœä¸€ä¸ªNSCachedURLResponseå¯¹äºè¯·æ±‚å¹¶ä¸å­˜åœ¨ï¼Œæ•°æ®å°†ä¼šä»æºç«¯è·å–ã€‚å¦‚æœè¯·æ±‚æ‹¥æœ‰ä¸€ä¸ªç¼“å­˜çš„å“åº”ï¼Œé‚£ä¹ˆURLåŠ è½½ç³»ç»Ÿä¼šæ£€æŸ¥è¿™ä¸ªå“åº”æ¥å†³å®šï¼Œå¦‚æœå®ƒæŒ‡å®šå†…å®¹å¿…é¡»é‡æ–°ç”Ÿæ•ˆçš„è¯ã€‚å‡å¦‚å†…å®¹å¿…é¡»é‡æ–°ç”Ÿæ•ˆï¼Œå°†å»ºç«‹ä¸€ä¸ªè¿å‘æºç«¯çš„è¿æ¥æ¥æŸ¥çœ‹å†…å®¹æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚å‡å¦‚å†…å®¹æ²¡æœ‰å˜åŒ–ï¼Œé‚£ä¹ˆå“åº”å°±ä»æœ¬åœ°ç¼“å­˜è¿”å›æ•°æ®ã€‚å¦‚æœå†…å®¹å˜åŒ–äº†ï¼Œé‚£ä¹ˆæ•°æ®å°†ä»æºç«¯è·å– */ NSURLRequestUseProtocolCachePolicy = 0, /** URLåº”è¯¥åŠ è½½æºç«¯æ•°æ®ï¼Œä¸ä½¿ç”¨æœ¬åœ°ç¼“å­˜æ•°æ® */ NSURLRequestReloadIgnoringLocalCacheData = 1, /** æœ¬åœ°ç¼“å­˜æ•°æ®ã€ä»£ç†å’Œå…¶ä»–ä¸­ä»‹éƒ½è¦å¿½è§†ä»–ä»¬çš„ç¼“å­˜ï¼Œç›´æ¥åŠ è½½æºæ•°æ® */ NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, /** æŒ‡å®šå·²å­˜çš„ç¼“å­˜æ•°æ®åº”è¯¥ç”¨æ¥å“åº”è¯·æ±‚ï¼Œä¸ç®¡å®ƒçš„ç”Ÿå‘½æ—¶é•¿å’Œè¿‡æœŸæ—¶é—´ã€‚å¦‚æœåœ¨ç¼“å­˜ä¸­æ²¡æœ‰å·²å­˜æ•°æ®æ¥å“åº”è¯·æ±‚çš„è¯ï¼Œæ•°æ®ä»æºç«¯åŠ è½½ã€‚ */ NSURLRequestReturnCacheDataElseLoad = 2, /** æŒ‡å®šå·²å­˜çš„ç¼“å­˜æ•°æ®ç”¨æ¥æ»¡è¶³è¯·æ±‚ï¼Œä¸ç®¡ç”Ÿå‘½æ—¶é•¿å’Œè¿‡æœŸæ—¶é—´ã€‚å¦‚æœåœ¨ç¼“å­˜ä¸­æ²¡æœ‰å·²å­˜æ•°æ®æ¥å“åº”URLåŠ è½½è¯·æ±‚çš„è¯ï¼Œä¸å»å°è¯•ä»æºæ®µåŠ è½½æ•°æ®ï¼Œæ­¤æ—¶è®¤ä¸ºåŠ è½½è¯·æ±‚å¤±è´¥ã€‚è¿™ä¸ªå¸¸é‡æŒ‡å®šäº†ä¸€ä¸ªç±»ä¼¼äºç¦»çº¿æ¨¡å¼çš„è¡Œä¸º */ NSURLRequestReturnCacheDataDontLoad = 3, /** æŒ‡å®šå¦‚æœå·²å­˜çš„ç¼“å­˜æ•°æ®è¢«æä¾›å®ƒçš„æºæ®µç¡®è®¤ä¸ºæœ‰æ•ˆåˆ™å…è®¸ä½¿ç”¨ç¼“å­˜æ•°æ®å“åº”è¯·æ±‚ï¼Œå¦åˆ™ä»æºæ®µåŠ è½½æ•°æ®ã€‚ */ NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;; NSURLRequestReturnCacheDataDontLoadæ˜¯ç”¨äºç¦»çº¿æ¨¡å¼çš„ï¼Œæˆ‘ä¸ºäº†èƒ½è®©ç”¨æˆ·åœ¨ç¦»çº¿ä¸‹é¢é˜…è¯»ï¼Œæˆ‘å°±è®¾è®¡äº†å½“æ²¡æœ‰ç½‘ç»œçš„æ—¶å€™çš„ç­–ç•¥ä¸ºNSURLRequestReturnCacheDataDontLoadã€‚ åˆ›å»ºæ™®é€šNSMutableURLRequestè¯·æ±‚å¯¹è±¡å£°æ˜HTTPåºåˆ—åŒ–å™¨ç±»AFHTTPRequestSerializerï¼Œå®ç°äº†AFURLRequestSerializationåè®®ï¼Œå¹¶å‚è€ƒäº†NSMutableURLRequestç±»å£°æ˜äº†å¾ˆå¤šè¯·æ±‚è®¾ç½®ç›¸å…³å±æ€§ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** AFHTTPRequestSerializerå®ç°äº†AFURLRequestSerializationåè®®ï¼Œä¸ºæŸ¥è¯¢è¯­å¥ã€URLè¡¨å•ç¼–ç å‚æ•°çš„åºåˆ—åŒ–æä¾›ä¸€ä¸ªå…·ä½“çš„å®ç°å’Œé»˜è®¤çš„è¯·æ±‚å¤´ï¼Œä»¥åŠçŠ¶æ€ç å’Œå†…å®¹ç±»å‹çš„æ ¡éªŒã€‚ æ‰€æœ‰çš„requestå’Œresponseéƒ½è¢«é¼“åŠ±å»ç»§æ‰¿AFHTTPRequestSerializerç±»ï¼Œä»¥ç¡®ä¿é»˜è®¤æ–¹æ³•å’Œå±æ€§çš„ä¸€è‡´æ€§ã€‚*/@interface AFHTTPRequestSerializer : NSObject &lt;AFURLRequestSerialization&gt;/** å­—ç¬¦ä¸²ç¼–ç æ–¹å¼ï¼Œé»˜è®¤ä¸ºNSUTF8StringEncoding*/@property (nonatomic, assign) NSStringEncoding stringEncoding;/** æ˜¯å¦å…è®¸æ‰‹æœºè®¿é—®ï¼Œé»˜è®¤ä¸ºYES */@property (nonatomic, assign) BOOL allowsCellularAccess;/** ç¼“å­˜ç­–ç•¥ã€‚é»˜è®¤ä¸ºNSURLRequestUseProtocolCachePolicy å‚è€ƒNSMutableURLRequest -setCachePolicy:*/@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;/** æ˜¯å¦ç”¨cookieæ¥å¤„ç†åˆ›å»ºçš„è¯·æ±‚ã€‚é»˜è®¤ä¸ºYES å‚è€ƒNSMutableURLRequest -setHTTPShouldHandleCookies*/@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;/** åˆ›å»ºçš„è¯·æ±‚åœ¨æ”¶åˆ°ä¸Šä¸ªä¼ è¾“ï¼ˆtransmissionï¼‰å“åº”ä¹‹å‰æ˜¯å¦ç»§ç»­å‘é€æ•°æ®ã€‚ é»˜è®¤ä¸ºNO(å³ç­‰å¾…ä¸Šæ¬¡ä¼ è¾“å®Œæˆåå†è¯·æ±‚) å‚è€ƒNSMutableURLRequest -setHTTPShouldUsePipelining:*/@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;/** è¯·æ±‚çš„ç½‘ç»œæœåŠ¡ç±»å‹ã€‚ è¿™ä¸ªæœåŠ¡ç±»å‹å‘æ•´ä¸ªç½‘ç»œä¼ è¾“å±‚æ¬¡æä¾›äº†ä¸€ä¸ªå…³äºè¯¥è¯·æ±‚ç›®çš„çš„æç¤ºã€‚ ï¼ˆThe service type is used to provide the networking layers a hint of the purpose of the request.ï¼‰ é»˜è®¤ä¸ºNSURLNetworkServiceTypeDefault å‚è€ƒNSMutableURLRequest -setNetworkServiceType:*/@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;/** è¯·æ±‚çš„è¶…æ—¶é—´éš”ï¼Œå•ä½ç§’ã€‚é»˜è®¤ä¸º60ç§’ å‚è€ƒNSMutableURLRequest -setTimeoutInterval:*/@property (nonatomic, assign) NSTimeInterval timeoutInterval;///---------------------------------------/// @name Configuring HTTP Request Headers///---------------------------------------/** åºåˆ—è¯·æ±‚çš„é»˜è®¤è¯·æ±‚å¤´ã€‚é»˜è®¤å€¼åŒ…æ‹¬ 'Accept-Languageâ€™ å†…å®¹ä¸º 'NSLocale +preferredLanguagesâ€™ æ–¹æ³•è·å–çš„è¯­éŸ³ 'User-Agentâ€™ å†…å®¹ä¸ºå„ç§bundleçš„æ ‡å¿—å·²ç»ç³»ç»Ÿä¿¡æ¯ å¯ä»¥ä½¿ç”¨'setValue:forHTTPHeaderField:â€™æ–¹æ³•æ·»åŠ æˆ–åˆ é™¤è¯·æ±‚å¤´*/@property (readonly, nonatomic, strong) NSDictionary &lt;NSString *, NSString *&gt; *HTTPRequestHeaders;/** ç±»æ–¹æ³•åˆ›å»ºå®ä¾‹å¯¹è±¡ */+ (instancetype)serializer;/** è®¾ç½®HTTPHeader */- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;/** è·å–HTTPHeader fieldå¯¹åº”çš„ä¿¡æ¯ */- (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;/** è®¾ç½®èº«ä»½ä¿¡æ¯header */- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username password:(NSString *)password;/** æ¸…é™¤èº«ä»½è®¤è¯ä¿¡æ¯header */- (void)clearAuthorizationHeader;///-------------------------------------------------------/// @name Configuring Query String Parameter Serialization///-------------------------------------------------------/** å“ªäº›HTTPè¯·æ±‚æ–¹æ³•ä¼šå°†å‚æ•°ç¼–ç æˆæŸ¥è¯¢å­—ç¬¦ä¸²ï¼ˆå¦‚:name=xgb&amp;gender=1ï¼‰ã€‚é»˜è®¤ä¸ºGET, HEADå’ŒDELETEã€‚*/@property (nonatomic, strong) NSSet &lt;NSString *&gt; *HTTPMethodsEncodingParametersInURI;/** æŸ¥è¯¢å‚æ•°çš„è½¬ä¹‰æ ·å¼.(ç›®å‰åªæœ‰ä¸€ç§) */- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style;/** è‡ªå®šä¹‰å‚æ•°çš„è½¬ä¹‰æ–¹å¼ */- (void)setQueryStringSerializationWithBlock:(nullable NSString * (^)(NSURLRequest *request, id parameters, NSError * __autoreleasing *error))block;///-------------------------------/// @name Creating Request Objects///-------------------------------/** å¦‚æœè¯·æ±‚æ–¹å¼ä¸ºGET`, `HEAD`, or `DELETEæ—¶ã€å‚æ•°ä¼šè¢«æ‹¼æ¥åˆ°URLä¸­ã€å¦åˆ™å½“åšbodyå¤„ç† */- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error;@end åˆ›å»ºæ™®é€šNSMutableURLRequestè¯·æ±‚å¯¹è±¡å®ç°123456789static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123; static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))]; &#125;); return _AFHTTPRequestSerializerObservedKeyPaths;&#125; AFHTTPRequestSerializerObservedKeyPathsæ–¹æ³•å®šä¹‰å¯ä»¥éœ€è¦è¢«è§‚å¯Ÿçš„å±æ€§ï¼ˆè¿™äº›å±æ€§ä¸ºå…¬å¼€çš„å±æ€§ï¼Œå¯èƒ½è¢«ç”¨æˆ·ä¿®æ”¹ï¼‰ï¼ŒåŒ…æ‹¬cachePolicyã€HTTPShouldHandleCookiesã€HTTPShouldUsePipeliningã€networkServiceTypeå’ŒtimeoutIntervalã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332@interface AFHTTPRequestSerializer ()/** ä¿å­˜ç”¨æˆ·ä¿®æ”¹è¿‡çš„å±æ€§ï¼ŒåŒ…æ‹¬AFHTTPRequestSerializerObservedKeyPathsåŒ…å«çš„å±æ€§ã€‚ å½“ç”¨æˆ·ä¿®æ”¹è¿™äº›å±æ€§å€¼æ—¶è®°å½•èµ·æ¥ï¼Œåˆ›å»ºRequestæ—¶ä½¿ç”¨ï¼Œæ²¡ä¿®æ”¹çš„ä½¿ç”¨é»˜è®¤å€¼ã€‚*/@property (readwrite, nonatomic, strong) NSMutableSet *mutableObservedChangedKeyPaths;/** çœŸæ­£å­˜å‚¨Headerçš„å±æ€§ã€‚ */@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableHTTPRequestHeaders;/** ç”¨ä¸€ä¸ªä¸²è¡Œçº¿ç¨‹æ¥ç»Ÿä¸€å¤„ç†Headerçš„ä¿®æ”¹ï¼Œé¿å…å¤šçº¿ç¨‹é€ æˆçš„çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚*/@property (readwrite, nonatomic, strong) dispatch_queue_t requestHeaderModificationQueue;/** ç›®å‰åªæœ‰ä¸€ä¸ªå€¼ */@property (readwrite, nonatomic, assign) AFHTTPRequestQueryStringSerializationStyle queryStringSerializationStyle;/** ç”¨äºè‡ªå®šä¹‰æŸ¥è¯¢å­—ç¬¦ä¸²çš„æ‹¼æ¥ã€‚ å› ä¸ºAFURLRequestSerializationåè®®å®šä¹‰çš„æ–¹æ³•-requestBySerializingRequest:withParameters:error:ä¼ å…¥çš„parametersæ˜¯ä»¥å­—å…¸çš„å½¢å¼ä¼ å…¥ï¼Œæ‰€ä»¥éœ€è¦å°†å­—å…¸æ‹¼æ¥æˆæŸ¥è¯¢å­—ç¬¦ä¸²ï¼Œé»˜è®¤æ˜¯ä½¿ç”¨AFQueryStringFromParametersæ–¹æ³•æ‹¼æ¥ã€‚*/@property (readwrite, nonatomic, copy) AFQueryStringSerializationBlock queryStringSerialization;@end@implementation AFHTTPRequestSerializer+ (instancetype)serializer &#123; return [[self alloc] init];&#125;/** åˆå§‹åŒ–æ–¹æ³•ä¸»è¦æ˜¯å¯¹ä¸€äº›å±æ€§åˆå§‹åŒ–ï¼Œä»¥åŠå°†HTTPå¤´éƒ¨æŒ‰ç…§w3cæ ‡å‡†è¿›è¡Œäº†å°è£…ï¼Œæ ¹æ®AFHTTPRequestSerializerObservedKeyPathsæ–¹æ³•å¯¹ä¸€äº›å¿…è¦çš„å±æ€§ä½¿ç”¨KVOè¿›è¡Œäº†ç›‘å¬ã€‚åœ¨è¿™äº›è¢«ç›‘å¬çš„å±æ€§çš„setteré‡Œé¢æ‰‹åŠ¨åœ°å‘é€é€šçŸ¥ï¼Œé¿å…å‡ºç°å¥‡æ€ªçš„å¼‚å¸¸*/- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.stringEncoding = NSUTF8StringEncoding; self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary]; self.requestHeaderModificationQueue = dispatch_queue_create(\"requestHeaderModificationQueue\", DISPATCH_QUEUE_CONCURRENT); // Accept-Language HTTP Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4 NSMutableArray *acceptLanguagesComponents = [NSMutableArray array]; [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; float q = 1.0f - (idx * 0.1f); [acceptLanguagesComponents addObject:[NSString stringWithFormat:@\"%@;q=%0.1g\", obj, q]]; *stop = q &lt;= 0.5f; &#125;]; [self setValue:[acceptLanguagesComponents componentsJoinedByString:@\", \"] forHTTPHeaderField:@\"Accept-Language\"]; NSString *userAgent = nil;#if TARGET_OS_IOS // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@\"%@/%@ (%@; iOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];#elif TARGET_OS_WATCH // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@\"%@/%@ (%@; watchOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[WKInterfaceDevice currentDevice] model], [[WKInterfaceDevice currentDevice] systemVersion], [[WKInterfaceDevice currentDevice] screenScale]];#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED) userAgent = [NSString stringWithFormat:@\"%@/%@ (Mac OS X %@)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]];#endif if (userAgent) &#123; if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123; NSMutableString *mutableUserAgent = [userAgent mutableCopy]; if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@\"Any-Latin; Latin-ASCII; [:^ASCII:] Remove\", false)) &#123; userAgent = mutableUserAgent; &#125; &#125; [self setValue:userAgent forHTTPHeaderField:@\"User-Agent\"]; &#125; // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@\"GET\", @\"HEAD\", @\"DELETE\", nil]; self.mutableObservedChangedKeyPaths = [NSMutableSet set]; for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123; [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext]; &#125; &#125; return self;&#125;- (void)dealloc &#123; for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123; [self removeObserver:self forKeyPath:keyPath context:AFHTTPRequestSerializerObserverContext]; &#125; &#125;&#125;#pragma mark -// Workarounds for crashing behavior using Key-Value Observing with XCTest// See https://github.com/AFNetworking/AFNetworking/issues/2523- (void)setAllowsCellularAccess:(BOOL)allowsCellularAccess &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(allowsCellularAccess))]; _allowsCellularAccess = allowsCellularAccess; [self didChangeValueForKey:NSStringFromSelector(@selector(allowsCellularAccess))];&#125;- (void)setCachePolicy:(NSURLRequestCachePolicy)cachePolicy &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(cachePolicy))]; _cachePolicy = cachePolicy; [self didChangeValueForKey:NSStringFromSelector(@selector(cachePolicy))];&#125;- (void)setHTTPShouldHandleCookies:(BOOL)HTTPShouldHandleCookies &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldHandleCookies))]; _HTTPShouldHandleCookies = HTTPShouldHandleCookies; [self didChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldHandleCookies))];&#125;- (void)setHTTPShouldUsePipelining:(BOOL)HTTPShouldUsePipelining &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldUsePipelining))]; _HTTPShouldUsePipelining = HTTPShouldUsePipelining; [self didChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldUsePipelining))];&#125;- (void)setNetworkServiceType:(NSURLRequestNetworkServiceType)networkServiceType &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(networkServiceType))]; _networkServiceType = networkServiceType; [self didChangeValueForKey:NSStringFromSelector(@selector(networkServiceType))];&#125;- (void)setTimeoutInterval:(NSTimeInterval)timeoutInterval &#123; [self willChangeValueForKey:NSStringFromSelector(@selector(timeoutInterval))]; _timeoutInterval = timeoutInterval; [self didChangeValueForKey:NSStringFromSelector(@selector(timeoutInterval))];&#125;#pragma mark -- (NSDictionary *)HTTPRequestHeaders &#123; NSDictionary __block *value; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; value = [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders]; &#125;); return value;&#125;- (void)setValue:(NSString *)valueforHTTPHeaderField:(NSString *)field&#123; dispatch_barrier_async(self.requestHeaderModificationQueue, ^&#123; [self.mutableHTTPRequestHeaders setValue:value forKey:field]; &#125;);&#125;- (NSString *)valueForHTTPHeaderField:(NSString *)field &#123; NSString __block *value; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; value = [self.mutableHTTPRequestHeaders valueForKey:field]; &#125;); return value;&#125;//é€šè¿‡è´¦å·å¯†ç è®¾ç½®æˆæƒè¯·æ±‚å¤´- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username password:(NSString *)password&#123; NSData *basicAuthCredentials = [[NSString stringWithFormat:@\"%@:%@\", username, password] dataUsingEncoding:NSUTF8StringEncoding]; NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0]; [self setValue:[NSString stringWithFormat:@\"Basic %@\", base64AuthCredentials] forHTTPHeaderField:@\"Authorization\"];&#125;//æ¸…é™¤æˆæƒç”¨è¯·æ±‚å¤´- (void)clearAuthorizationHeader &#123; dispatch_barrier_async(self.requestHeaderModificationQueue, ^&#123; [self.mutableHTTPRequestHeaders removeObjectForKey:@\"Authorization\"]; &#125;);&#125;#pragma mark -//è®¾ç½®æŸ¥è¯¢å‚æ•°çš„ç¼–ç æ–¹å¼- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style &#123; self.queryStringSerializationStyle = style; self.queryStringSerialization = nil;&#125;//è®¾ç½®æŸ¥è¯¢å‚æ•°è‡ªå®šä¹‰ç¼–ç çš„block- (void)setQueryStringSerializationWithBlock:(NSString *(^)(NSURLRequest *, id, NSError *__autoreleasing *))block &#123; self.queryStringSerialization = block;&#125;#pragma mark -//é€šè¿‡è¯·æ±‚æ–¹å¼ã€URLã€å‚æ•°å­—å…¸ç”Ÿæˆè¯·æ±‚- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(URLString); NSURL *url = [NSURL URLWithString:URLString]; NSParameterAssert(url); NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url]; mutableRequest.HTTPMethod = method; //å¦‚æœæŸä¸ªå…³é”®å±æ€§è¢«è‡ªä¸»è®¾ç½®è¿‡ã€åˆ™ç”¨æ–°çš„ã€‚ä¸ç„¶ç›´æ¥ç”¨æ¨¡æ¿ç”Ÿæˆçš„`NSMutableURLRequest`å³å¯ for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123; [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath]; &#125; &#125; //å¯¹reqè¿›ä¸€æ­¥è®¾ç½®(æ‹¼æ¥URLã€è¯·æ±‚ä½“ã€è¯·æ±‚å¤´) mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy]; return mutableRequest;&#125;#pragma mark - AFURLRequestSerialization- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; //è®¾ç½®è¯·æ±‚å¤´ [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; //æ ¹æ®å‚æ•°parametersè®¾ç½®æŸ¥è¯¢å­—æ®µ NSString *query = nil; if (parameters) &#123; if (self.queryStringSerialization) &#123; NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) &#123; if (error) &#123; *error = serializationError; &#125; return nil; &#125; &#125; else &#123; switch (self.queryStringSerializationStyle) &#123; case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; &#125; &#125; &#125; // åˆ¤æ–­å‚æ•°æ˜¯æ‹¼åˆ°urlè¿˜æ˜¯æ”¾åˆ°HTTPBody if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; if (query &amp;&amp; query.length &gt; 0) &#123; mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @\"&amp;%@\" : @\"?%@\", query]]; &#125; &#125; else &#123; // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) &#123; query = @\"\"; &#125; if (![mutableRequest valueForHTTPHeaderField:@\"Content-Type\"]) &#123; [mutableRequest setValue:@\"application/x-www-form-urlencoded\" forHTTPHeaderField:@\"Content-Type\"]; &#125; [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; &#125; return mutableRequest;&#125;#pragma mark - NSKeyValueObserving// å¯ä»¥å†³å®šæ˜¯å¦å‘é€KVOé€šçŸ¥+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123; if ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) &#123; return NO; &#125; return [super automaticallyNotifiesObserversForKey:key];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(__unused id)object change:(NSDictionary *)change context:(void *)context&#123; if (context == AFHTTPRequestSerializerObserverContext) &#123; if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123; //å¦‚æœæ²¡æœ‰æ–°å€¼ã€åˆ™æ¸…ç©ºæ‰€å±ç›‘å¬ [self.mutableObservedChangedKeyPaths removeObject:keyPath]; &#125; else &#123; [self.mutableObservedChangedKeyPaths addObject:keyPath]; &#125; &#125;&#125;#pragma mark - NSSecureCoding+ (BOOL)supportsSecureCoding &#123; return YES;&#125;- (instancetype)initWithCoder:(NSCoder *)decoder &#123; self = [self init]; if (!self) &#123; return nil; &#125; self.mutableHTTPRequestHeaders = [[decoder decodeObjectOfClass:[NSDictionary class] forKey:NSStringFromSelector(@selector(mutableHTTPRequestHeaders))] mutableCopy]; self.queryStringSerializationStyle = (AFHTTPRequestQueryStringSerializationStyle)[[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(queryStringSerializationStyle))] unsignedIntegerValue]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder &#123; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; [coder encodeObject:self.mutableHTTPRequestHeaders forKey:NSStringFromSelector(@selector(mutableHTTPRequestHeaders))]; &#125;); [coder encodeInteger:self.queryStringSerializationStyle forKey:NSStringFromSelector(@selector(queryStringSerializationStyle))];&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFHTTPRequestSerializer *serializer = [[[self class] allocWithZone:zone] init]; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; serializer.mutableHTTPRequestHeaders = [self.mutableHTTPRequestHeaders mutableCopyWithZone:zone]; &#125;); serializer.queryStringSerializationStyle = self.queryStringSerializationStyle; serializer.queryStringSerialization = self.queryStringSerialization; return serializer;&#125;@end å®ç°é‡Œé¢ç”¨åˆ°äº† KVO å’Œ GCDKVOå¾ˆå·§å¦™çš„æŠŠå‡ ä¸ªå±æ€§å€¼çš„æ›´æ”¹ç»Ÿä¸€å¤„ç†ï¼Œä»£ç æ¸…æ™°ã€ç®€æ´GCDæ …æ å‡½æ•° AFMultipartFormDataåè®®ä¸Šä¼ å›¾ç‰‡æˆ–è€…å…¶ä»–æ–‡ä»¶çš„ åˆå§‹åŒ–è¾¹ç•Œ bodyå¤´ body ç»“æŸè¾¹ç•Œ åè®®ï¼š 1234567891011121314151617181920212223242526272829- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name error:(NSError * _Nullable __autoreleasing *)error;- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType error:(NSError * _Nullable __autoreleasing *)error;- (void)appendPartWithInputStream:(nullable NSInputStream *)inputStream name:(NSString *)name fileName:(NSString *)fileName length:(int64_t)length mimeType:(NSString *)mimeType;- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType;- (void)appendPartWithFormData:(NSData *)data name:(NSString *)name;- (void)appendPartWithHeaders:(nullable NSDictionary &lt;NSString *, NSString *&gt; *)headers body:(NSData *)body;- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes delay:(NSTimeInterval)delay; Bodyéƒ¨åˆ†ï¼š 12345678910111213141516171819202122232425262728@interface AFHTTPBodyPart : NSObject// ç¼–ç æ–¹å¼@property (nonatomic, assign) NSStringEncoding stringEncoding;// å¤´@property (nonatomic, strong) NSDictionary *headers;// è¾¹ç•Œ@property (nonatomic, copy) NSString *boundary;// ä¸»ä½“@property (nonatomic, strong) id body;// ä¸»é¢˜å†…å®¹é•¿åº¦@property (nonatomic, assign) unsigned long long bodyContentLength;// æµ@property (nonatomic, strong) NSInputStream *inputStream;// æ˜¯å¦æœ‰åˆå§‹è¾¹ç•Œ@property (nonatomic, assign) BOOL hasInitialBoundary;// æ˜¯å¦æœ‰ç»“æŸè¾¹ç•Œ@property (nonatomic, assign) BOOL hasFinalBoundary;// æ˜¯å¦æœ‰å¯ç”¨å­—èŠ‚ï¼Œæ˜¯å¦ä¸ºnil@property (readonly, nonatomic, assign, getter = hasBytesAvailable) BOOL bytesAvailable;// é•¿åº¦@property (readonly, nonatomic, assign) unsigned long long contentLength;// è¯»å–æ•°æ®- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length;@end AFHTTPBodyPartç±»å±æ€§å¯ä»¥çœ‹å‡ºï¼Œå·²ç»åŒ…å«äº†å››å¤§ç»„æˆéƒ¨åˆ† 1234567891011121314151617181920212223typedef enum &#123; AFEncapsulationBoundaryPhase = 1, AFHeaderPhase = 2, AFBodyPhase = 3, AFFinalBoundaryPhase = 4,&#125; AFHTTPBodyPartReadPhase;@interface AFHTTPBodyPart () &lt;NSCopying&gt; &#123; // ä½¿ç”¨æšä¸¾ åŒ…è£…body4å¤§ç»„æˆéƒ¨åˆ† AFHTTPBodyPartReadPhase _phase; // è¾“å…¥æµ NSInputStream *_inputStream; // æ¯ä¸ªç»„æˆéƒ¨åˆ†çš„ä½ç½® unsigned long long _phaseReadOffset;&#125;// è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªé˜¶æ®µ- (BOOL)transitionToNextPhase;// è¯»å–æ•°æ®- (NSInteger)readData:(NSData *)data intoBuffer:(uint8_t *)buffer maxLength:(NSUInteger)length;@end å¯¹AFHTTPBodyPartçš„æ‰©å±•éƒ¨åˆ†ï¼Œå¯ä»¥çœ‹å‡ºæ›¾åŠ äº†ä¸‰ä¸ªå±æ€§ã€ä¸¤ä¸ªæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// AFHTTPBodyPart å®ç°éƒ¨åˆ†@implementation AFHTTPBodyPart// åˆå§‹åŒ–- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; [self transitionToNextPhase]; return self;&#125;- (void)dealloc &#123; if (_inputStream) &#123; [_inputStream close]; _inputStream = nil; &#125;&#125;// bodyå¯èƒ½æœ‰å¥½å‡ ç§ç±»å‹ï¼Œæ ¹æ®ä¸åŒçš„ç±»å‹è¿”å›ä¸åŒæ–¹æ³•åˆ›å»ºçš„NSInputStream ã€‚- (NSInputStream *)inputStream &#123; if (!_inputStream) &#123; if ([self.body isKindOfClass:[NSData class]]) &#123; _inputStream = [NSInputStream inputStreamWithData:self.body]; &#125; else if ([self.body isKindOfClass:[NSURL class]]) &#123; _inputStream = [NSInputStream inputStreamWithURL:self.body]; &#125; else if ([self.body isKindOfClass:[NSInputStream class]]) &#123; _inputStream = self.body; &#125; else &#123; _inputStream = [NSInputStream inputStreamWithData:[NSData data]]; &#125; &#125; return _inputStream;&#125;// æ ¹æ®headerå­—å…¸æ‹¼bodyå¤´- (NSString *)stringForHeaders &#123; NSMutableString *headerString = [NSMutableString string]; for (NSString *field in [self.headers allKeys]) &#123; [headerString appendString:[NSString stringWithFormat:@\"%@: %@%@\", field, [self.headers valueForKey:field], kAFMultipartFormCRLF]]; &#125; [headerString appendString:kAFMultipartFormCRLF]; return [NSString stringWithString:headerString];&#125;// è·å–bodyçš„å¤§å° ç”¨åˆ°å‡ ä¸ªå‡½æ•°- (unsigned long long)contentLength &#123; unsigned long long length = 0; // åˆå§‹åŒ–è¾¹ç•Œ NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; length += [encapsulationBoundaryData length]; // å¤´ NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; length += [headersData length]; // ä¸»ä½“ length += _bodyContentLength; // ç»“æŸè¾¹ç•Œ NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); length += [closingBoundaryData length]; return length;&#125;// åˆ¤æ–­æ˜¯å¦è¿˜æœ‰æ•°æ®- (BOOL)hasBytesAvailable &#123; // Allows `read:maxLength:` to be called again if `AFMultipartFormFinalBoundary` doesn't fit into the available buffer if (_phase == AFFinalBoundaryPhase) &#123; return YES; &#125; switch (self.inputStream.streamStatus) &#123; case NSStreamStatusNotOpen: case NSStreamStatusOpening: case NSStreamStatusOpen: case NSStreamStatusReading: case NSStreamStatusWriting: return YES; case NSStreamStatusAtEnd: case NSStreamStatusClosed: case NSStreamStatusError: default: return NO; &#125;&#125;// ä¸‹é¢è¿™ä¸¤ä¸ªæ–¹æ³•æ˜¯æŠŠbodyæ•°æ®å†™å…¥åˆ°bufferä¸­ã€‚é€šè¿‡è§‚å¯Ÿç€è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œå¯å¾—çŸ¥ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•è‚¯å®šåœ¨å…¶ä»–çš„ä»£ç ä¸­çš„æŸä¸ªå¾ªç¯ä¸­è¢«è°ƒç”¨ï¼Œç›®çš„æ˜¯å¾—åˆ°æƒ³è¦çš„æ•°æ®æ ¼å¼- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; NSInteger totalNumberOfBytesRead = 0; if (_phase == AFEncapsulationBoundaryPhase) &#123; NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFHeaderPhase) &#123; NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFBodyPhase) &#123; NSInteger numberOfBytesRead = 0; numberOfBytesRead = [self.inputStream read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; if (numberOfBytesRead == -1) &#123; return -1; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if ([self.inputStream streamStatus] &gt;= NSStreamStatusAtEnd) &#123; [self transitionToNextPhase]; &#125; &#125; &#125; if (_phase == AFFinalBoundaryPhase) &#123; NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; return totalNumberOfBytesRead;&#125;- (NSInteger)readData:(NSData *)data intoBuffer:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; // æ¯”è¾ƒæ•°æ®å’Œå…è®¸çš„æœ€å¤§é•¿åº¦ é€‰å–æ¯”è¾ƒå°çš„é‚£ä¸ª NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length] - ((NSUInteger)_phaseReadOffset), length)); // copy dataä¸­rangeçš„æ•°æ®åˆ°buffer [data getBytes:buffer range:range]; _phaseReadOffset += range.length; if (((NSUInteger)_phaseReadOffset) &gt;= [data length]) &#123; [self transitionToNextPhase]; &#125; return (NSInteger)range.length;&#125;- (BOOL)transitionToNextPhase &#123; // ä¿è¯ä¸»çº¿ç¨‹æ‰§è¡Œä»£ç  if (![[NSThread currentThread] isMainThread]) &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; [self transitionToNextPhase]; &#125;); return YES; &#125; switch (_phase) &#123; case AFEncapsulationBoundaryPhase: _phase = AFHeaderPhase; break; case AFHeaderPhase: // æ‰“å¼€æµï¼Œå‡†å¤‡æ¥æ”¶æ•°æ® [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; [self.inputStream open]; _phase = AFBodyPhase; break; case AFBodyPhase: // å…³é—­æµ [self.inputStream close]; _phase = AFFinalBoundaryPhase; break; case AFFinalBoundaryPhase: default: _phase = AFEncapsulationBoundaryPhase; break; &#125; // é‡ç½®offset _phaseReadOffset = 0; return YES;&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFHTTPBodyPart *bodyPart = [[[self class] allocWithZone:zone] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = self.headers; bodyPart.bodyContentLength = self.bodyContentLength; bodyPart.body = self.body; bodyPart.boundary = self.boundary; return bodyPart;&#125;@end å…¶å®AFHTTPBodyPartå°±åƒæ˜¯ä¸€ä¸ªä¸ªå…·ä½“çš„æ•°æ®ä¸€æ ·ï¼Œè€ŒAFMultipartBodyStreamæ›´åƒæ˜¯ä¸€ä¸ªç®¡é“ï¼Œå’Œbodyç›¸è¿ï¼Œæ•°æ®ä»bodyæ²¿ç€ç®¡é“æµå…¥requestä¸­å»ã€‚ è¿™å±‚æŠ½è±¡çš„æ¦‚å¿µè¿˜æ˜¯è›®é‡è¦çš„ã€‚å†è®¾è®¡ä¹‹åˆï¼Œè¿™ä¸¤ä¸ªæŠ½è±¡ç±»å°±åº”è¯¥å„è‡ªå®Œæˆå„è‡ªçš„ä»»åŠ¡ï¼Œå³ä½¿bodyä¸­ä¹Ÿæœ‰stream ä½†é‚£ä¹Ÿåªå±äºbodyè‡ªèº«çš„ä¸šåŠ¡ã€‚ 1234567891011121314151617// AFHTTPBodyPartå°±åƒæ˜¯ä¸€ä¸ªä¸ªå…·ä½“çš„æ•°æ®ä¸€æ ·ï¼Œè€ŒAFMultipartBodyStreamæ›´åƒæ˜¯ä¸€ä¸ªç®¡é“@interface AFMultipartBodyStream : NSInputStream &lt;NSStreamDelegate&gt;// è¯»å–åŒ…çš„å¤§å°@property (nonatomic, assign) NSUInteger numberOfBytesInPacket;// å»¶æ—¶@property (nonatomic, assign) NSTimeInterval delay;// è¾“å…¥æµ@property (nonatomic, strong) NSInputStream *inputStream;// å†…å®¹å¤§å°@property (readonly, nonatomic, assign) unsigned long long contentLength;// æ˜¯å¦ä¸ºç©º@property (readonly, nonatomic, assign, getter = isEmpty) BOOL empty;- (instancetype)initWithStringEncoding:(NSStringEncoding)encoding;- (void)setInitialAndFinalBoundaries;- (void)appendHTTPBodyPart:(AFHTTPBodyPart *)bodyPart;@end å®ƒæ˜¯ç»§æ‰¿è‡ªNSInputStreamçš„ï¼Œæ•°æ®æœ€ç»ˆæ˜¯é€šè¿‡setHTTPBodySteamæ–¹æ³•ä¼ é€’ç»™Requestçš„ã€‚æ˜¯ä¸€ä¸ªNSInputStreamç±»å‹ï¼Œå› æ­¤AFMultipartBodyStream ç»§æ‰¿è‡ªNSInputStream 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - NSInputStream- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; if ([self streamStatus] == NSStreamStatusClosed) &#123; return 0; &#125; NSInteger totalNumberOfBytesRead = 0; // éå†è¯»å–æ•°æ® while ((NSUInteger)totalNumberOfBytesRead &lt; MIN(length, self.numberOfBytesInPacket)) &#123; // å¦‚æœå½“å‰è¯»å–çš„bodyä¸å­˜åœ¨æˆ–è€…bodyæ²¡æœ‰å¯è¯»å­—èŠ‚ if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) &#123; // æŠŠä¸‹ä¸€ä¸ªbodyèµ‹å€¼ç»™å½“å‰çš„body å¦‚æœä¸‹ä¸€ä¸ªä¸ºnil å°±é€€å‡ºå¾ªç¯ if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator nextObject])) &#123; break; &#125; &#125; else &#123; // å½“å‰bodyå­˜åœ¨ // å‰©ä½™å¯è¯»æ–‡ä»¶çš„å¤§å° NSUInteger maxLength = MIN(length, self.numberOfBytesInPacket) - (NSUInteger)totalNumberOfBytesRead; // æŠŠå½“å‰çš„bodyçš„æ•°æ®è¯»å…¥åˆ°bufferä¸­ NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; if (numberOfBytesRead == -1) &#123; self.streamError = self.currentHTTPBodyPart.inputStream.streamError; break; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if (self.delay &gt; 0.0f) &#123; [NSThread sleepForTimeInterval:self.delay]; &#125; &#125; &#125; &#125; return totalNumberOfBytesRead;&#125; è¿™ä¸ªæ–¹æ³•æ˜¯AFMultipartBodyStreamé€šè¿‡bodyè¯»å–æ•°æ®çš„æ ¸å¿ƒæ–¹æ³•ã€‚ä¸‹é¢é€šè¿‡ä¸¾ä¸€ä¸ªä¾‹å­æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•ç©¶ç«Ÿæ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Ÿ å‡å¦‚æˆ‘ä»¬ä¸Šä¼ ä¸€å¼ å›¾ç‰‡img.png ä»–çš„å¤§å°ä¸º80000ï¼Œä¹Ÿå°±æ˜¯å·®ä¸å¤š80kå§ã€‚ é€šè¿‡AFMultipartBodyStreamè¯»å–æ•°æ®ï¼Œä¼šé¦–å…ˆè°ƒç”¨ä¸Šè¾¹çš„æ–¹æ³•ã€‚è¯»å–æ•°æ®å¹¶ä¸æ˜¯ä¸€æ¬¡æ€§è¯»å–çš„ï¼Œè€Œæ˜¯åˆ†æ‰¹åˆ†æ¬¡è¯»å–çš„ï¼Œè¿™è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæ¯æ¬¡è¯»å–çš„å¤§å°ä¸º32kï¼Œä¹Ÿå°±æ˜¯32*1024 = 32768çš„å¤§å°ã€‚ ç¬¬ä¸€æ¬¡è°ƒç”¨åself.currentHTTPBodyPart æŒ‡å‘æˆ‘ä»¬çš„img.png é€šè¿‡NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; æ–¹æ³•åœ¨bodyä¸­è¯»å–äº†32768å¤§å°çš„æ•°æ®ä¿å­˜åˆ°äº†ç¼“å­˜bufferä¸­ã€‚ ç”±äºæ•´ä¸ªå›¾ç‰‡å¤§å°æ˜¯80000 ä¸€æ¬¡è°ƒç”¨åªè¯»å–äº†32768 è¿˜æœ‰æ•°æ®æ²¡è¯»å®Œï¼Œä¸€æ¬¡è¿™ä¸ªæ–¹æ³•è¿˜ä¼šå†æ¬¡è¢«è°ƒç”¨ã€‚ ç¬¬äºŒæ¬¡è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œç”±äº[self.currentHTTPBodyPart hasBytesAvailable]è¿˜æœ‰æ•°æ®ï¼Œæ‰€ä»¥è¿˜æ˜¯ä¼šèµ°åˆ°elseçš„æ–¹æ³•ä¸­ï¼Œself.currentHTTPBodyPartå¹¶æ²¡æœ‰æŒ‡å‘åˆ«çš„bodyã€‚å› æ­¤ç»§ç»­æ‰§è¡Œ 3.çš„æ–¹æ³•ã€‚ è‡³äºä¸ºä»€ä¹ˆèƒ½æ¥ç€ä»ä¸Šæ¬¡çš„å·²è¯»å–çš„æ•°æ®å¼€å§‹è¯»æ•°æ®ï¼Œè¿™ä¸ªæ˜¯bodyå†…éƒ¨å°è£…å®ç°çš„ï¼Œå¯å‚è€ƒæœ¬æ–‡ä¸Šè¾¹å…³äºbodyçš„ä»‹ç»ã€‚ é‡å¤ 3 4 5 çš„æ­¥éª¤ï¼Œç›´åˆ°æ²¡æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œstreamå°±ä¼šå…³é—­æµã€‚åˆ°æ­¤æˆ‘ä»¬çš„çªå˜æ•°æ®å°±ä»¥æµçš„å½¢å¼ä¸Šä¼ åˆ°æœåŠ¡å™¨äº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(![method isEqualToString:@\"GET\"] &amp;&amp; ![method isEqualToString:@\"HEAD\"]); NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error]; __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (parameters) &#123; for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123; NSData *data = nil; if ([pair.value isKindOfClass:[NSData class]]) &#123; data = pair.value; &#125; else if ([pair.value isEqual:[NSNull null]]) &#123; data = [NSData data]; &#125; else &#123; data = [[pair.value description] dataUsingEncoding:self.stringEncoding]; &#125; if (data) &#123; [formData appendPartWithFormData:data name:[pair.field description]]; &#125; &#125; &#125; if (block) &#123; block(formData); &#125; return [formData requestByFinalizingMultipartFormData];&#125;// setHTTPBodyStreamæ–¹æ³• éœ€è¦è®¾ç½®NSInputStreamç±»å‹çš„å¯¹è±¡- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; [self.request setHTTPBodyStream:self.bodyStream]; [self.request setValue:[NSString stringWithFormat:@\"multipart/form-data; boundary=%@\", self.boundary] forHTTPHeaderField:@\"Content-Type\"]; [self.request setValue:[NSString stringWithFormat:@\"%llu\", [self.bodyStream contentLength]] forHTTPHeaderField:@\"Content-Length\"]; return self.request;&#125; ä¸Šä¼ å¤šä¸ªæ–‡ä»¶çš„æ—¶å€™å›ç”¨åˆ°è¿™ä¸ªæ–¹æ³•ï¼Œé‡Œé¢æœ‰ä¸€ä¸ªæ¥å—AFMultipartFormDataåè®®çš„å¯¹è±¡ï¼ŒAFNæ²¡æœ‰è®©AFMultipartBodyStreamæ¥å—è¿™ä¸ªåè®®æ¥å¤„ç†ã€‚è€Œæ˜¯ç”¨å¦å¤–ä¸€ä¸ªç±»AFStreamingMultipartFormDataæ¥æ¥å—è¿™ä¸ªåè®®ï¼Œå°±æ˜¯ä¸ºäº†æŠŠåŠŸèƒ½å’Œä¸šåŠ¡ä»£ç é€»è¾‘åˆ†å¼€ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187@interface AFStreamingMultipartFormData ()@property (readwrite, nonatomic, copy) NSMutableURLRequest *request;@property (readwrite, nonatomic, assign) NSStringEncoding stringEncoding;@property (readwrite, nonatomic, copy) NSString *boundary;@property (readwrite, nonatomic, strong) AFMultipartBodyStream *bodyStream;@end@interface AFStreamingMultipartFormData : NSObject &lt;AFMultipartFormData&gt;- (instancetype)initWithURLRequest:(NSMutableURLRequest *)urlRequest stringEncoding:(NSStringEncoding)encoding;- (NSMutableURLRequest *)requestByFinalizingMultipartFormData;@end@implementation AFStreamingMultipartFormData- (instancetype)initWithURLRequest:(NSMutableURLRequest *)urlRequest stringEncoding:(NSStringEncoding)encoding&#123; self = [super init]; if (!self) &#123; return nil; &#125; self.request = urlRequest; self.stringEncoding = encoding; self.boundary = AFCreateMultipartFormBoundary(); self.bodyStream = [[AFMultipartBodyStream alloc] initWithStringEncoding:encoding]; return self;&#125;- (void)setRequest:(NSMutableURLRequest *)request&#123; _request = [request mutableCopy];&#125;- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name error:(NSError * __autoreleasing *)error&#123; NSParameterAssert(fileURL); NSParameterAssert(name); NSString *fileName = [fileURL lastPathComponent]; NSString *mimeType = AFContentTypeForPathExtension([fileURL pathExtension]); return [self appendPartWithFileURL:fileURL name:name fileName:fileName mimeType:mimeType error:error];&#125;- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType error:(NSError * __autoreleasing *)error&#123; NSParameterAssert(fileURL); NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); if (![fileURL isFileURL]) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@\"Expected URL to be a file URL\", @\"AFNetworking\", nil)&#125;; if (error) &#123; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo]; &#125; return NO; &#125; else if ([fileURL checkResourceIsReachableAndReturnError:error] == NO) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@\"File URL not reachable.\", @\"AFNetworking\", nil)&#125;; if (error) &#123; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo]; &#125; return NO; &#125; NSDictionary *fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:[fileURL path] error:error]; if (!fileAttributes) &#123; return NO; &#125; NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\", name, fileName] forKey:@\"Content-Disposition\"]; [mutableHeaders setValue:mimeType forKey:@\"Content-Type\"]; AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = mutableHeaders; bodyPart.boundary = self.boundary; bodyPart.body = fileURL; bodyPart.bodyContentLength = [fileAttributes[NSFileSize] unsignedLongLongValue]; [self.bodyStream appendHTTPBodyPart:bodyPart]; return YES;&#125;- (void)appendPartWithInputStream:(NSInputStream *)inputStream name:(NSString *)name fileName:(NSString *)fileName length:(int64_t)length mimeType:(NSString *)mimeType&#123; NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\", name, fileName] forKey:@\"Content-Disposition\"]; [mutableHeaders setValue:mimeType forKey:@\"Content-Type\"]; AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = mutableHeaders; bodyPart.boundary = self.boundary; bodyPart.body = inputStream; bodyPart.bodyContentLength = (unsigned long long)length; [self.bodyStream appendHTTPBodyPart:bodyPart];&#125;- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType&#123; NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\", name, fileName] forKey:@\"Content-Disposition\"]; [mutableHeaders setValue:mimeType forKey:@\"Content-Type\"]; [self appendPartWithHeaders:mutableHeaders body:data];&#125;- (void)appendPartWithFormData:(NSData *)data name:(NSString *)name&#123; NSParameterAssert(name); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@\"form-data; name=\\\"%@\\\"\", name] forKey:@\"Content-Disposition\"]; [self appendPartWithHeaders:mutableHeaders body:data];&#125;- (void)appendPartWithHeaders:(NSDictionary *)headers body:(NSData *)body&#123; NSParameterAssert(body); AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = headers; bodyPart.boundary = self.boundary; bodyPart.bodyContentLength = [body length]; bodyPart.body = body; [self.bodyStream appendHTTPBodyPart:bodyPart];&#125;- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes delay:(NSTimeInterval)delay&#123; self.bodyStream.numberOfBytesInPacket = numberOfBytes; self.bodyStream.delay = delay;&#125;- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; [self.request setHTTPBodyStream:self.bodyStream]; [self.request setValue:[NSString stringWithFormat:@\"multipart/form-data; boundary=%@\", self.boundary] forHTTPHeaderField:@\"Content-Type\"]; [self.request setValue:[NSString stringWithFormat:@\"%llu\", [self.bodyStream contentLength]] forHTTPHeaderField:@\"Content-Length\"]; return self.request;&#125;@end å®šä¹‰AFStreamingMultipartFormDataï¼Œæ¥å—AFMultipartFormDataï¼Œå®ç°åè®®æ–¹æ³•ï¼ŒæŠŠæ–‡ä»¶å°è£…æˆbodyPartå¯¹è±¡å­˜å‚¨åˆ°AFStreamingMultipartFormDataå¯¹è±¡çš„å±æ€§bodyStreamçš„æ•°ç»„ä¸­ã€‚é€šè¿‡read maxLengthè¯»å–æ•°æ®ã€‚ AFJSONRequestSerializerå’ŒAFPropertyListRequestSerializerè¿™ä¸¤ä¸ªç±»ç»§æ‰¿è‡ªAFHTTPRequestSerializerã€‚ä»–ä»¬çš„åŸºæœ¬å®ç°éƒ½æ˜¯ç»§æ‰¿è‡ªçˆ¶ç±»ã€‚ä½†æ˜¯ä¹Ÿæ ¹æ®è‡ªèº«ä¸åŒæƒ…å†µï¼Œåšäº†å¤„ç†ã€‚å¯¹äºAFJSONRequestSerializerã€‚éœ€è¦æŠŠContent-TypeæŒ‡å®šä¸ºâ€application/jsonã€‚åŒæ—¶HTTPBodyéœ€è¦ä½¿ç”¨JSONåºåˆ—åŒ–ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); /* å¯¹äº`GET`,`HEAD`,`DELETE`ç­‰æ–¹æ³•ä¸­ã€‚ç›´æ¥ä½¿ç”¨çˆ¶ç±»çš„å¤„ç†æ–¹å¼ */ if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; return [super requestBySerializingRequest:request withParameters:parameters error:error]; &#125; NSMutableURLRequest *mutableRequest = [request mutableCopy]; //æŠŠ`HTTPRequestHeaders`ä¸­çš„å€¼æ·»åŠ è¿›å…¥è¯·æ±‚å¤´ä¸­ã€‚ [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; if (parameters) &#123; //è®¾ç½®è¯·æ±‚å¤´çš„`Content-Type`ç±»å‹ if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123; [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; &#125; if (![NSJSONSerialization isValidJSONObject:parameters]) &#123; if (error) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@&quot;The `parameters` argument is not valid JSON.&quot;, @&quot;AFNetworking&quot;, nil)&#125;; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo]; &#125; return nil; &#125; //æŠŠparametersè½¬æ¢ä¸ºJSONåºåˆ—åŒ–çš„data NSData *jsonData = [NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]; if (!jsonData) &#123; return nil; &#125; //JSONåºåˆ—åŒ–çš„æ•°æ®è®¾ç½®ä¸ºhttpbody [mutableRequest setHTTPBody:jsonData]; &#125; return mutableRequest;&#125; å¯¹äºAFPropertyListRequestSerializerä¹Ÿæ˜¯åŒæ ·çš„é“ç†ï¼š 123456789101112131415161718192021222324252627282930313233- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); /* å¯¹äº`GET`,`HEAD`,`DELETE`ç­‰æ–¹æ³•ä¸­ã€‚ç›´æ¥ä½¿ç”¨çˆ¶ç±»çš„å¤„ç†æ–¹å¼ */ if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; return [super requestBySerializingRequest:request withParameters:parameters error:error]; &#125; NSMutableURLRequest *mutableRequest = [request mutableCopy]; //æŠŠ`HTTPRequestHeaders`ä¸­çš„å€¼æ·»åŠ è¿›å…¥è¯·æ±‚å¤´ä¸­ã€‚ [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; if (parameters) &#123; //è®¾ç½®è¯·æ±‚å¤´çš„`Content-Type`ç±»å‹ if (![mutableRequest valueForHTTPHeaderField:@\"Content-Type\"]) &#123; [mutableRequest setValue:@\"application/x-plist\" forHTTPHeaderField:@\"Content-Type\"]; &#125; //æŠŠparametersè½¬æ¢ä¸ºPliståºåˆ—åŒ–çš„data NSData *plistData = [NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]; if (!plistData) &#123; return nil; &#125; //Pliståºåˆ—åŒ–çš„æ•°æ®è®¾ç½®ä¸ºhttpbody [mutableRequest setHTTPBody:plistData]; &#125; return mutableRequest;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorkingåŸç†","slug":"AFNetWorkingåŸç†","permalink":"https://nixzhang5.github.io/tags/AFNetWorkingåŸç†/"}]},{"title":"Appç­¾ååŸç†","slug":"Appç­¾ååŸç†","date":"2019-06-26T03:29:11.000Z","updated":"2019-06-27T03:24:35.971Z","comments":true,"path":"Appç­¾ååŸç†.html","link":"","permalink":"https://nixzhang5.github.io/Appç­¾ååŸç†.html","excerpt":"Appç­¾åæ˜¯ä¸ºäº†ä¿è¯æ¯ä¸ªAppéƒ½æ˜¯ç»è¿‡è‹¹æœå…¬å¸å®˜æ–¹è®¤è¯çš„ã€‚iPhoneå’Œç³»ç»Ÿéƒ½æ˜¯è‹¹æœå…¬å¸ç”Ÿäº§çš„ï¼Œæ‰€ä»¥è‹¹æœå…¬å¸å¯ä»¥åœ¨æ‰‹æœºä¸Šå†…ç½®å…¬é’¥ï¼ŒApp Storeä¸Šå†…ç½®ç§é’¥ã€‚","text":"Appç­¾åæ˜¯ä¸ºäº†ä¿è¯æ¯ä¸ªAppéƒ½æ˜¯ç»è¿‡è‹¹æœå…¬å¸å®˜æ–¹è®¤è¯çš„ã€‚iPhoneå’Œç³»ç»Ÿéƒ½æ˜¯è‹¹æœå…¬å¸ç”Ÿäº§çš„ï¼Œæ‰€ä»¥è‹¹æœå…¬å¸å¯ä»¥åœ¨æ‰‹æœºä¸Šå†…ç½®å…¬é’¥ï¼ŒApp Storeä¸Šå†…ç½®ç§é’¥ã€‚ è‹¹æœç­¾åéœ€æ±‚ï¼š ä¸ºäº†ä¿è¯ç³»ç»Ÿçš„å®‰å…¨æ€§ï¼Œæ‰€æœ‰iPhoneä¸Šå®‰è£…çš„åº”ç”¨å¿…é¡»æ˜¯ç»è¿‡è‹¹æœæˆæƒçš„ å®‰è£…åŒ…ä¸éœ€è¦ä¸Šä¼ åˆ°App Storeä¹Ÿèƒ½è¢«å®‰è£… ï¼ˆå¼€å‘è°ƒè¯• ä¼ä¸šç°åº¦ï¼‰ é˜²æ­¢è¯ä¹¦æƒé™æ»¥ç”¨ï¼šè®¾å¤‡é™åˆ¶ã€æŒ‡å®šAPPã€iCloud/PUSH/åå°è¿è¡Œç­‰é™„åŠ æƒé™æ§åˆ¶ ä¸‹è½½Appç­¾åç­¾ååŸç†ï¼š Appä¸Šä¼ åˆ°App Storeæ—¶ï¼Œè‹¹æœå…¬å¸æ‹¿åˆ°Appçš„HASH(MD5,SHAç­‰)å€¼ï¼Œç„¶åç”¨ç§é’¥è¿›è¡ŒåŠ å¯†(ç­¾å)ï¼Œè¿™æ—¶å€™åªæœ‰æ‰‹æœºä¸Šçš„å…¬é’¥æ‰å¯ä»¥è§£å¯†ï¼› æ‰‹æœºä¸‹è½½åº”ç”¨å®‰è£…Appæ—¶ï¼Œå…ˆç”¨å…¬é’¥è§£å¯†(éªŒè¯ç­¾å)ï¼Œæ‹¿åˆ°HASHå€¼ï¼Œç„¶åå°†æ­¤HASHå€¼ï¼Œä¸è¦å®‰è£…çš„Appçš„HASHå€¼è¿›è¡Œæ ¡éªŒï¼Œå¦‚æœAppæœ‰è¢«ä¿®æ”¹è¿‡ï¼Œåˆ™æ ¡éªŒå¤±è´¥ã€‚è¿™æ ·å°±å¯ä»¥æœ‰æ•ˆçš„ä¿è¯æ¯ä¸ªAppéƒ½æ˜¯ç»è¿‡è‹¹æœå…¬å¸å®˜æ–¹è®¤è¯çš„ã€‚ åŒå±‚ç­¾åçœŸæœºè°ƒè¯•ï¼Œä¼ä¸šåŒ…ä¸Šé¢çš„ç­¾åæ–¹å¼å°±ä¸é€‚åˆäº†ã€‚è¿™æ—¶å€™éœ€è¦åŒå±‚ç­¾åï¼š åœ¨Macç³»ç»Ÿä¸­ç”Ÿæˆä¸€å¯¹éå¯¹ç§°åŠ å¯†ç®—æ³•çš„å…¬ç§é’¥Mï¼ˆkeychain é‡Œçš„ ä»è¯ä¹¦é¢å‘æœºæ„è¯·æ±‚è¯ä¹¦ï¼Œä¿å­˜çš„CertificateSigningRequestå°±åŒ…å«å…¬é’¥Mï¼Œç§é’¥ä¿å­˜åœ¨æœ¬åœ°ï¼‰ã€‚ è‹¹æœè‡ªå·±æœ‰å›ºå®šçš„ä¸€å¯¹å…¬ç§é’¥ï¼šç§é’¥Aåœ¨è‹¹æœåå°ï¼Œå…¬é’¥Aåœ¨æ¯ä¸ªiOSç³»ç»Ÿçš„æ‰‹æœºä¸­ã€‚ ç”³è¯·è¯ä¹¦ï¼ŒæŠŠCertificateSigningRequest.certSigningRequestæ–‡ä»¶ï¼ˆåŒ…å«å…¬é’¥Mï¼Œä»¥åŠä¸€äº›å¼€å‘è€…ä¿¡æ¯ï¼‰å‘é€ç»™è‹¹æœåå°ï¼Œç”¨è‹¹æœåå°çš„ç§é’¥Aå¯¹å…¬é’¥Mç­¾åï¼Œå¾—åˆ°ä¸€ä»½åŒ…å«å…¬é’¥Mä»¥åŠå…¶ç­¾åç»“æœçš„æ•°æ®å°±æ˜¯è¯ä¹¦ã€‚ ç”Ÿæˆçš„è¯ä¹¦ä¸‹è½½ä¸‹æ¥ï¼Œkeychainä¼šæŠŠè¿™ä¸¤ä¸ªè¯ä¹¦å…³è”èµ·æ¥ï¼Œå› ä¸ºå…¬ç§é’¥æ˜¯å¯¹åº”çš„ã€‚è¿™ä¸ªç§é’¥åªæœ‰è¿™å°ç”µè„‘æœ‰ï¼Œå›¢é˜Ÿå¼€å‘éœ€è¦æŠŠè¿™ä¸ªç§é’¥å¯¼å‡º.p12ç»™å…¶ä»–Mac. é…ç½® AppID / æƒé™ / è®¾å¤‡ç­‰ï¼Œæœ€åä¸‹è½½ Provisioning Profile æ–‡ä»¶ï¼ˆåŒ…å«è®¾å¤‡IDs,AppID,Entitlements(æƒåŠ›æ–‡ä»¶åŒ…å«æ˜¯å¦å¯è°ƒè¯•ï¼Œæ¨é€ï¼Œåå°è¿è¡Œç­‰ä¿¡æ¯)ï¼‰ã€‚ XCode ä¼šé€šè¿‡ç¬¬3æ­¥ä¸‹è½½å›æ¥çš„è¯ä¹¦ï¼ˆå­˜ç€å…¬é’¥ï¼‰ï¼Œåœ¨æœ¬åœ°æ‰¾åˆ°å¯¹åº”çš„ç§é’¥ï¼ˆç¬¬1æ­¥ç”Ÿæˆçš„ï¼‰ï¼Œç”¨æœ¬åœ°ç§é’¥å»ç­¾å Appï¼Œå¹¶æŠŠ Provisioning Profile æ–‡ä»¶å‘½åä¸º embedded.mobileprovision ä¸€èµ·æ‰“åŒ…è¿›å»ã€‚ æ‰“åŒ…è¿‡ç¨‹ç”¨ç§é’¥Må¯¹Appçš„HASHå€¼è¿›è¡ŒåŠ å¯†(ç­¾å)ï¼Œè¿™æ—¶çš„APPå†…éƒ¨å®é™…åŒ…å«äº†APPçš„ç­¾å(ç§é’¥MåŠ å¯†Appçš„HASHå€¼)ã€ç¬¬3æ­¥ç”Ÿæˆçš„è¯ä¹¦æ–‡ä»¶(åŒ…å«å…¬é’¥Må’Œå…¬é’¥Mçš„HASHå€¼)ã€Provision Profile(æè¿°æ–‡ä»¶)ï¼ŒAppå¯æ‰§è¡Œæ–‡ä»¶ä»¥åŠå…¶ä»–ä¿¡æ¯ è§£å¯†ï¼š iPhoneæ‰‹æœºæ‹¿åˆ°è¯ä¹¦æ–‡ä»¶(åŒ…å«å…¬é’¥Må’Œå…¬é’¥Mçš„HASHå€¼)ï¼Œå› ä¸ºæ‰‹æœºé‡Œæœ‰å…¬é’¥Aï¼Œæ‰€ä»¥èƒ½è§£å¯†è¯ä¹¦æ–‡ä»¶ï¼Œå¾—åˆ°å…¬é’¥Må’Œå…¬é’¥Mçš„HASHå€¼ï¼Œå…ˆéªŒè¯å…¬é’¥Mç”Ÿæˆçš„HASHå€¼(MD5,SHAç­‰)æ˜¯ä¸æ˜¯å’Œè¯ä¹¦æ–‡ä»¶é‡Œçš„å…¬é’¥Mçš„HASHå€¼ä¸€è‡´ï¼Œç¡®ä¿è¯ä¹¦æ²¡æœ‰è¢«ä¿®æ”¹ï¼› éªŒè¯ä¸€è‡´åï¼Œå°±å¯ä»¥ç”¨å…¬é’¥Mæ¥è§£å¯†ç¬¬2æ­¥çš„APPçš„ç­¾åï¼ŒåŒæ ·é“ç†å¯ä»¥éªŒè¯Appæ˜¯å¦è¢«ä¿®æ”¹è¿‡ã€‚ å› ä¸ºåœ¨å¼€å‘é˜¶æ®µAppä¼šç»å¸¸ä¿®æ”¹ï¼Œæ‰€ä»¥Appå°±ç®—æ˜¯ä¿®æ”¹è¿‡ï¼Œä¹Ÿèƒ½å®‰è£…ã€‚ç¬¬4æ­¥ä¸»è¦æ˜¯éªŒè¯è¯ä¹¦æ˜¯ä¸æ˜¯è‹¹æœè®¤è¯çš„ï¼Œåªè¦è¯ä¹¦å¯¹å°±å¯ä»¥å®‰è£…è¿è¡Œã€‚ åŠ å¯†è§£å¯†ï¼š macç”µè„‘ï¼šç§é’¥Må’Œå…¬é’¥M(ç”µè„‘ç”Ÿæˆ) è‹¹æœæœåŠ¡å™¨ï¼šç§é’¥A iPhoneæ‰‹æœºï¼šå…¬é’¥A .ipaåŒ…å«çš„ä¿¡æ¯ï¼š èµ„æºæ–‡ä»¶ï¼Œä¾‹å¦‚å›¾ç‰‡ã€htmlã€ç­‰ç­‰ã€‚ _CodeSignature/CodeResourcesã€‚è¿™æ˜¯ä¸€ä¸ªplistæ–‡ä»¶ï¼Œå¯ç”¨æ–‡æœ¬æŸ¥çœ‹ï¼Œå…¶ä¸­çš„å†…å®¹å°±æ˜¯æ˜¯ç¨‹åºåŒ…ä¸­ï¼ˆä¸åŒ…æ‹¬Frameworksï¼‰æ‰€æœ‰æ–‡ä»¶çš„ç­¾åã€‚æ³¨æ„è¿™é‡Œæ˜¯æ‰€æœ‰æ–‡ä»¶ã€‚æ„å‘³ç€ä½ çš„ç¨‹åºä¸€æ—¦ç­¾åï¼Œå°±ä¸èƒ½æ›´æ”¹å…¶ä¸­ä»»ä½•çš„ä¸œè¥¿ï¼ŒåŒ…æ‹¬èµ„æºæ–‡ä»¶å’Œå¯æ‰§è¡Œæ–‡ä»¶æœ¬èº«ã€‚iOSç³»ç»Ÿä¼šæ£€æŸ¥è¿™äº›ç­¾åã€‚ å¯æ‰§è¡Œæ–‡ä»¶ã€‚æ­¤æ–‡ä»¶è·Ÿèµ„æºæ–‡ä»¶ä¸€æ ·éœ€è¦ç­¾åã€‚ ä¸€ä¸ªmobileprovisionæ–‡ä»¶.æ‰“åŒ…çš„æ—¶å€™ä½¿ç”¨çš„ï¼Œä»MCä¸Šç”Ÿæˆçš„ã€‚ Frameworksã€‚ç¨‹åºå¼•ç”¨çš„éç³»ç»Ÿè‡ªå¸¦çš„Frameworksï¼Œæ¯ä¸ªFrameworkså…¶å®å°±æ˜¯ä¸€ä¸ªappï¼Œå…¶ä¸­çš„ç»“æ„åº”è¯¥å’Œappå·®ä¸å¤šï¼Œä¹ŸåŒ…å«ç­¾åä¿¡æ¯CodeResourcesæ–‡ä»¶ã€‚ ç­¾ååŸç†å›¾ï¼š ç­¾ååŸç†å›¾","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"Encryption","slug":"Encryption","permalink":"https://nixzhang5.github.io/tags/Encryption/"}]},{"title":"åŠ å¯†","slug":"åŠ å¯†","date":"2019-06-26T02:27:44.000Z","updated":"2019-06-26T03:25:10.730Z","comments":true,"path":"åŠ å¯†.html","link":"","permalink":"https://nixzhang5.github.io/åŠ å¯†.html","excerpt":"åŠ å¯†æ˜¯ä¸ºäº†ä¿è¯æˆ‘ä»¬çš„æ•°æ®å®‰å…¨ï¼Œå³ä¸è¢«ä»–äººç¯¡æ”¹æˆ–æˆªå–åˆ°æœ‰ç”¨çš„ä¿¡æ¯çš„æ“ä½œã€‚iOSä¸€ç›´ä»¥å®‰å…¨è‘—ç§°ï¼Œä½†æ˜¯ä»Xcodeçš„Ghostäº‹ä»¶ä¹‹åï¼ŒiOSå®‰å…¨ä¸å¯æ‘§çš„ç¥è¯ä¼¼ä¹å·²ç»è¢«æ‰“ç ´ã€‚äº‹å®è¯æ˜ï¼Œæ— è®ºæ˜¯Androidè¿˜æ˜¯iOSï¼Œè¯¥åŠ å¯†å¤„ç†çš„è¿˜æ˜¯éœ€è¦åŠ å¯†å¤„ç†ï¼Œè°ä¹Ÿä¸èƒ½ä¿è¯è‡ªå·±ä¸€å®šæ˜¯å®‰å…¨çš„ã€‚","text":"åŠ å¯†æ˜¯ä¸ºäº†ä¿è¯æˆ‘ä»¬çš„æ•°æ®å®‰å…¨ï¼Œå³ä¸è¢«ä»–äººç¯¡æ”¹æˆ–æˆªå–åˆ°æœ‰ç”¨çš„ä¿¡æ¯çš„æ“ä½œã€‚iOSä¸€ç›´ä»¥å®‰å…¨è‘—ç§°ï¼Œä½†æ˜¯ä»Xcodeçš„Ghostäº‹ä»¶ä¹‹åï¼ŒiOSå®‰å…¨ä¸å¯æ‘§çš„ç¥è¯ä¼¼ä¹å·²ç»è¢«æ‰“ç ´ã€‚äº‹å®è¯æ˜ï¼Œæ— è®ºæ˜¯Androidè¿˜æ˜¯iOSï¼Œè¯¥åŠ å¯†å¤„ç†çš„è¿˜æ˜¯éœ€è¦åŠ å¯†å¤„ç†ï¼Œè°ä¹Ÿä¸èƒ½ä¿è¯è‡ªå·±ä¸€å®šæ˜¯å®‰å…¨çš„ã€‚ å¯¹ç§°åŠ å¯†Aä¸ B ä¹‹é—´ä¹‹é—´çš„é€šè®¯æ•°æ®éƒ½ç”¨åŒä¸€å¥—çš„å¯†é’¥æ¥è¿›è¡ŒåŠ å¯†è§£å¯†ã€‚ ä¼˜ç‚¹ç®€å•å¿«æ·ï¼Œå¯†é’¥è¾ƒçŸ­ï¼Œä¸”ç ´è¯‘å›°éš¾ã€‚ ç¼ºç‚¹å¦‚æœç”¨æˆ·ä¸€æ—¦å¤šçš„è¯ï¼Œç®¡ç†å¯†é’¥ä¹Ÿæ˜¯ä¸€ç§å›°éš¾ã€‚ä¸æ–¹ä¾¿ç›´æ¥æ²Ÿé€šçš„ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´æ€ä¹ˆç¡®å®šå¯†é’¥ä¹Ÿéœ€è¦è€ƒè™‘ï¼Œè¿™å…¶ä¸­å°±ä¼šæœ‰å¯†é’¥æ³„éœ²çš„é£é™©ï¼Œä»¥åŠå­˜åœ¨æ›´æ¢å¯†é’¥çš„éœ€æ±‚ã€‚ å¯¹ç§°åŠ å¯†é€šå¸¸æœ‰ AES, DES, IDEA, 3DES åŠ å¯†ç®—æ³•ã€‚ éå¯¹ç§°åŠ å¯†ç”¨å…¬é’¥å’Œç§é’¥æ¥åŠ è§£å¯†çš„ç®—æ³•ã€‚æ‰“ä¸ªæ¯”æ–¹ï¼ŒA çš„å…¬é’¥åŠ å¯†è¿‡çš„ä¸œè¥¿åªèƒ½é€šè¿‡ A çš„ç§é’¥æ¥è§£å¯†ï¼›åŒç†ï¼ŒA çš„ç§é’¥åŠ å¯†è¿‡çš„ä¸œè¥¿åªèƒ½é€šè¿‡ A çš„å…¬é’¥æ¥è§£å¯†ã€‚é¡¾åæ€ä¹‰ï¼Œå…¬é’¥æ˜¯å…¬å¼€çš„ï¼Œåˆ«äººå¯ä»¥è·å–çš„åˆ°ï¼›ç§é’¥æ˜¯ç§æœ‰çš„ï¼Œåªèƒ½è‡ªå·±æ‹¥æœ‰ã€‚ ç¼ºç‚¹åŠ è§£å¯†æ¯”å¯¹ç§°åŠ å¯†è€—æ—¶. ä¼˜ç‚¹æ¯”å¯¹ç§°åŠ å¯†å®‰å…¨. ä½†æ˜¯éå¯¹ç§°åŠ å¯†ä¹Ÿæ˜¯å­˜åœ¨æ¼æ´ï¼Œå› ä¸ºå…¬é’¥æ˜¯å…¬å¼€çš„ï¼Œå¦‚æœæœ‰ C å†’å…… B çš„èº«ä»½åˆ©ç”¨ A çš„å…¬é’¥ç»™ A å‘æ¶ˆæ¯ï¼Œè¿™æ ·å°±ä¹±å¥—äº†ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥å°±é‡‡ç”¨éå¯¹ç§°åŠ å¯†+æ‘˜è¦ç®—æ³•+æ•°å­—ç­¾åçš„æœºåˆ¶æ¥ç¡®ä¿ä¼ è¾“å®‰å…¨ã€‚ å¸¸è§çš„éå¯¹ç§°åŠ å¯†ç®—æ³•æœ‰ï¼šRSAã€ECCï¼ˆç§»åŠ¨è®¾å¤‡ç”¨ï¼‰ã€Diffie-Hellmanã€El Gamalã€DSAï¼ˆæ•°å­—ç­¾åç”¨ï¼‰ Hashç®—æ³•ï¼ˆæ‘˜è¦ç®—æ³•ï¼‰Hashç®—æ³•çš„ç‰¹ç‚¹æ˜¯å•å‘ä¸å¯è¿˜åŸï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡hashç®—æ³•å¯¹ç›®æ ‡ä¿¡æ¯ç”Ÿæˆä¸€æ®µç‰¹å®šé•¿åº¦çš„å”¯ä¸€hashå€¼ï¼Œå´ä¸èƒ½é€šè¿‡è¿™ä¸ªhashå€¼é‡æ–°è·å¾—ç›®æ ‡ä¿¡æ¯ã€‚å› æ­¤Hashç®—æ³•å¸¸ç”¨åœ¨ä¸å¯è¿˜åŸçš„å¯†ç å­˜å‚¨ã€ä¿¡æ¯å®Œæ•´æ€§æ ¡éªŒç­‰ã€‚åªè¦æºæ•°æ®ä¸åŒï¼Œç®—æ³•å¾—åˆ°çš„æ‘˜è¦å¿…å®šä¸åŒã€‚ å¸¸è§çš„Hashç®—æ³•æœ‰MD2ã€MD4ã€MD5ã€HAVALã€SHA æ•°å­—ç­¾åæ•°å­—ç­¾åç”¨æ¥ï¼Œä¿è¯ä¿¡æ¯ä¼ è¾“çš„å®Œæ•´æ€§ã€å‘é€è€…çš„èº«ä»½è®¤è¯ã€é˜²æ­¢äº¤æ˜“ä¸­çš„æŠµèµ–å‘ç”Ÿã€‚ æ•°å­—ç­¾åæ˜¯ Aå°†åŸå§‹æ˜æ–‡é€šè¿‡ hash ç®—æ³•å¾—åˆ°æ‘˜è¦ï¼Œè¿™ä¸ªæ‘˜è¦æ˜¯ä¸å¯é€†çš„ï¼›å°†æ˜æ–‡åŠ å¯†ï¼Œè¿åŒæ‘˜è¦ä¸€èµ·å‘é€ç»™Bï¼›Bæ¥æ”¶åˆ°åè§£å¯†ï¼Œå¾—åˆ°è¿™ä¸ªæ‘˜è¦ a å’ŒåŠ å¯†çš„æ˜æ–‡ï¼Œå†å°†åŠ å¯†æ˜æ–‡è§£å¯†å¾—åˆ°åŸå§‹æ˜æ–‡ï¼Œç„¶åé€šè¿‡åŒä¸€ hash ç®—æ³•å¾—åˆ°æ–°çš„æ‘˜è¦ bï¼Œæ¯”è¾ƒ a ä¸ b å°±å¯å¾—çŸ¥åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­æ˜¯å¦è¢«æ›´æ”¹è¿‡ã€‚ å› æ­¤æ•°å­—ç­¾åèƒ½å¤ŸéªŒè¯ä¿¡æ¯çš„å®Œæ•´æ€§ã€‚å¦‚æœä¸­é€”æ•°æ®è¢«çº‚æ”¹æˆ–è€…ä¸¢å¤±ã€‚é‚£ä¹ˆå¯¹æ–¹å°±å¯ä»¥æ ¹æ®æ•°å­—ç­¾åæ¥è¾¨åˆ«æ˜¯å¦æ˜¯æ¥è‡ªå¯¹æ–¹çš„ç¬¬ä¸€æ‰‹ä¿¡æ¯æ•°æ®ã€‚ å®Œæ•´çš„éå¯¹ç§°åŠ å¯†è¿‡ç¨‹å‡å¦‚ç°åœ¨ ä½ å‘æ”¯ä»˜å® è½¬è´¦ï¼ˆæœ¯è¯­æ•°æ®ä¿¡æ¯ï¼‰ï¼Œä¸ºäº†ä¿è¯ä¿¡æ¯ä¼ é€çš„ä¿å¯†æ€§ã€çœŸå®æ€§ã€å®Œæ•´æ€§å’Œä¸å¯å¦è®¤æ€§ï¼Œéœ€è¦å¯¹ä¼ é€çš„ä¿¡æ¯è¿›è¡Œæ•°å­—åŠ å¯†å’Œç­¾åï¼Œå…¶ä¼ é€è¿‡ç¨‹ä¸ºï¼š é¦–å…ˆä½ è¦ç¡®è®¤æ˜¯å¦æ˜¯æ”¯ä»˜å®çš„æ•°å­—è¯ä¹¦ï¼Œå¦‚æœç¡®è®¤ä¸ºæ”¯ä»˜å®èº«ä»½åï¼Œåˆ™å¯¹æ–¹çœŸå®å¯ä¿¡ã€‚å¯ä»¥å‘å¯¹æ–¹ä¼ é€ä¿¡æ¯ï¼Œ ä½ å‡†å¤‡å¥½è¦ä¼ é€çš„æ•°å­—ä¿¡æ¯ï¼ˆæ˜æ–‡ï¼‰è®¡ç®—è¦è½¬çš„å¤šå°‘é’±ï¼Œå¯¹æ–¹æ”¯ä»˜å®è´¦å·ç­‰ï¼› ä½  å¯¹æ•°å­—ä¿¡æ¯è¿›è¡Œå“ˆå¸Œè¿ç®—ï¼Œå¾—åˆ°ä¸€ä¸ªä¿¡æ¯æ‘˜è¦ï¼ˆå®¢æˆ·ç«¯ä¸»è¦èŒè´£ï¼‰ï¼› ä½  ç”¨è‡ªå·±çš„ç§é’¥å¯¹ä¿¡æ¯æ‘˜è¦è¿›è¡ŒåŠ å¯†å¾—åˆ° ä½  çš„æ•°å­—ç­¾åï¼Œå¹¶å°†å…¶é™„åœ¨æ•°å­—ä¿¡æ¯ä¸Šï¼› ä½  éšæœºäº§ç”Ÿä¸€ä¸ªåŠ å¯†å¯†é’¥ï¼Œå¹¶ç”¨æ­¤å¯†ç å¯¹è¦å‘é€çš„ä¿¡æ¯è¿›è¡ŒåŠ å¯†ï¼ˆå¯†æ–‡ï¼‰ï¼› ä½ ç”¨ æ”¯ä»˜å®çš„å…¬é’¥å¯¹åˆšæ‰éšæœºäº§ç”Ÿçš„åŠ å¯†å¯†é’¥è¿›è¡ŒåŠ å¯†ï¼Œå°†åŠ å¯†åçš„ DES å¯†é’¥è¿åŒå¯†æ–‡ä¸€èµ·ä¼ é€ç»™æ”¯ä»˜å®ï¼› æ”¯ä»˜å®æ”¶åˆ° ä½  ä¼ é€æ¥çš„å¯†æ–‡å’ŒåŠ å¯†è¿‡çš„ DES å¯†é’¥ï¼Œå…ˆç”¨è‡ªå·±çš„ç§é’¥å¯¹åŠ å¯†çš„ DES å¯†é’¥è¿›è¡Œè§£å¯†ï¼Œå¾—åˆ° ä½ éšæœºäº§ç”Ÿçš„åŠ å¯†å¯†é’¥ï¼› æ”¯ä»˜å® ç„¶åç”¨éšæœºå¯†é’¥å¯¹æ”¶åˆ°çš„å¯†æ–‡è¿›è¡Œè§£å¯†ï¼Œå¾—åˆ°æ˜æ–‡çš„æ•°å­—ä¿¡æ¯ï¼Œç„¶åå°†éšæœºå¯†é’¥æŠ›å¼ƒï¼› æ”¯ä»˜å® ç”¨ä½  çš„å…¬é’¥å¯¹ ä½ çš„çš„æ•°å­—ç­¾åè¿›è¡Œè§£å¯†ï¼Œå¾—åˆ°ä¿¡æ¯æ‘˜è¦ï¼› æ”¯ä»˜å®ç”¨ç›¸åŒçš„å“ˆå¸Œç®—æ³•å¯¹æ”¶åˆ°çš„æ˜æ–‡å†è¿›è¡Œä¸€æ¬¡å“ˆå¸Œè¿ç®—ï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„ä¿¡æ¯æ‘˜è¦ï¼› æ”¯ä»˜å®å°†æ”¶åˆ°çš„ä¿¡æ¯æ‘˜è¦å’Œæ–°äº§ç”Ÿçš„ä¿¡æ¯æ‘˜è¦è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœä¸€è‡´ï¼Œè¯´æ˜æ”¶åˆ°çš„ä¿¡æ¯æ²¡æœ‰è¢«ä¿®æ”¹è¿‡ã€‚ ç¡®å®šæ”¶åˆ°ä¿¡æ¯ï¼Œç„¶åè¿›è¡Œå‘å¯¹æ–¹è¿›è¡Œä»˜æ¬¾äº¤æ˜“ï¼Œä¸€æ¬¡éå¯¹ç§°å¯†è¿‡ç¨‹ç»“æŸã€‚åœ¨è¿™åé¢çš„æµç¨‹å°±ä¸å±äºæœ¬æ¬¡éå¯¹ç§°åŠ å¯†çš„èŒƒç•´ï¼Œç®—æ”¯ä»˜å®ä¸ªäººçš„è‡ªæˆ‘æµç¨‹ï¼Œä¹Ÿå°±æ˜¯å¾ªç¯ä»¥ä¸Šè¿‡ç¨‹ã€‚ iOSå¸¸ç”¨çš„åŠ å¯†æ–¹å¼Base64åŠ å¯†ã€MD5åŠ å¯†ã€AESåŠ å¯†ã€RSAåŠ å¯† Base64åŠ å¯†Base64ç¼–ç çš„æ€æƒ³æ˜¯ï¼šé‡‡ç”¨64ä¸ªåŸºæœ¬çš„ASCIIç å­—ç¬¦å¯¹æ•°æ®è¿›è¡Œé‡æ–°ç¼–ç ã€‚å®ƒå°†éœ€è¦ç¼–ç çš„æ•°æ®æ‹†åˆ†æˆå­—èŠ‚æ•°ç»„ï¼Œä»¥3ä¸ªå­—èŠ‚ä¸ºä¸€ç»„ï¼ŒæŒ‰é¡ºåºæ’åˆ—24ä½æ•°æ®ï¼Œå†æŠŠè¿™24ä½æ•°æ®åˆ†æˆ4ç»„ï¼Œå³æ¯ç»„6ä½ï¼›å†åœ¨æ¯ç»„çš„çš„æœ€é«˜ä½å‰è¡¥ä¸¤ä¸ª0å‡‘è¶³ä¸€ä¸ªå­—èŠ‚ï¼Œè¿™æ ·å°±æŠŠä¸€ä¸ª3å­—èŠ‚ä¸ºä¸€ç»„çš„æ•°æ®é‡æ–°ç¼–ç æˆäº†4ä¸ªå­—èŠ‚ï¼›å½“æ‰€è¦ç¼–ç çš„æ•°æ®çš„å­—èŠ‚æ•°ä¸æ˜¯3çš„æ•´å€æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨åˆ†ç»„æ—¶æœ€åä¸€ç»„ä¸å¤Ÿ3ä¸ªå­—èŠ‚ï¼Œè¿™æ—¶åœ¨æœ€åä¸€ç»„å¡«å……1åˆ°2ä¸ª0å­—èŠ‚ï¼Œå¹¶åœ¨æœ€åç¼–ç å®Œæˆååœ¨ç»“å°¾æ·»åŠ 1åˆ°2ä¸ª=å·ã€‚ä¾‹å¦‚ï¼šå°†å¯¹ABCè¿›è¡ŒBase64ç¼–ç é¦–å…ˆå–ABCå¯¹åº”çš„ASCIIç å€¼ï¼ŒA : 65ã€B : 66ã€C : 67ï¼Œå†å–äºŒè¿›åˆ¶å€¼A : 01000001ã€B : 01000010ã€C : 01000011ï¼Œç„¶åæŠŠè¿™ä¸‰ä¸ªå­—èŠ‚çš„äºŒè¿›åˆ¶ç æ¥èµ·æ¥010000010100001001000011ï¼Œå†ä»¥6ä½ä¸ºå•ä½åˆ†æˆ4ä¸ªæ•°æ®å—å¹¶åœ¨æœ€é«˜ä½å¡«å……ä¸¤ä¸ª0åå½¢æˆ4ä¸ªå­—èŠ‚çš„ç¼–ç åçš„å€¼00010000ã€00010100ã€00001001ã€00000011ï¼›å†æŠŠè¿™4ä¸ªå­—èŠ‚æ•°æ®è½¬åŒ–æˆ10è¿›åˆ¶æ•°å¾—16ã€20ã€19ã€3ï¼›æœ€åæ ¹æ®Base64ç»™å‡ºçš„64ä¸ªåŸºæœ¬å­—ç¬¦è¡¨ï¼ŒæŸ¥å‡ºå¯¹åº”çš„ASCIIç å­—ç¬¦Qã€Uã€Jã€Dï¼Œè¿™é‡Œçš„å€¼å®é™…å°±æ˜¯æ•°æ®åœ¨å­—ç¬¦è¡¨ä¸­çš„ç´¢å¼•ã€‚è§£ç è¿‡ç¨‹å°±æ˜¯æŠŠ4ä¸ªå­—èŠ‚å†è¿˜åŸæˆ3ä¸ªå­—èŠ‚å†æ ¹æ®ä¸åŒçš„æ•°æ®å½¢å¼æŠŠå­—èŠ‚æ•°ç»„é‡æ–°æ•´ç†æˆæ•°æ®ã€‚æ³¨ï¼šBase64å­—ç¬¦è¡¨ï¼ŒåŒ…æ‹¬å¤§å†™A-Zå°å†™a-zæ•°å­—0-9å’Œ+ä»¥åŠ/ã€‚Base64åŠ å¯†åŸåˆ™ï¼š6bitï¼ˆåŸ8bitï¼‰ä¸€ä¸ªå­—èŠ‚ï¼Œä¸è¶³çš„ä½æ•°ç”¨0è¡¥é½ï¼Œä¸¤ä¸ª0ç”¨ä¸€ä¸ª=è¡¨ç¤ºã€‚Base64åŠ å¯†ç‰¹ç‚¹ï¼š æ•°æ®åŠ å¯†ä¹‹åï¼Œæ•°æ®é‡ä¼šå˜å¤§ï¼Œå˜å¤§1/3å·¦å³ã€‚ å¯è¿›è¡Œåå‘è§£å¯†ã€‚ ç¼–ç åæœ‰ä¸ªéå¸¸æ˜¾è‘—çš„ç‰¹ç‚¹ï¼Œæœ«å°¾æœ‰ä¸ª=å·ã€‚ å…¶å®Base64ä¸ç®—æ˜¯åŠ å¯†ï¼Œåªæ˜¯ä¸€ç§ç¼–ç æ ¼å¼ã€‚ åœ¨iOSä¸­Base64åŠ è§£å¯†ä½¿ç”¨æ–¹æ³•ä»‹ç»ï¼ˆæœ¬ä¾‹ä½¿ç”¨ç³»ç»ŸAPIï¼Œä»…æ”¯æŒiOS7åŠä»¥åçš„ç³»ç»Ÿç‰ˆæœ¬ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/****************************Base64.mç±»å®ç°æ–‡ä»¶å†…å®¹****************************/+ (NSString *)base64EncodedStringWithData:(NSData *)data&#123; //åˆ¤æ–­æ˜¯å¦ä¼ å…¥éœ€è¦åŠ å¯†æ•°æ®å‚æ•° if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; //åˆ¤æ–­è®¾å¤‡ç³»ç»Ÿæ˜¯å¦æ»¡è¶³æ¡ä»¶ if ([[[UIDevice currentDevice] systemVersion] doubleValue] &lt;= 6.9) &#123; return nil; &#125; //ä½¿ç”¨ç³»ç»Ÿçš„APIè¿›è¡ŒBase64åŠ å¯†æ“ä½œ NSDataBase64EncodingOptions options; options = NSDataBase64EncodingEndLineWithLineFeed; return [data base64EncodedStringWithOptions:options];&#125;+ (NSData *)base64DecodeDataWithString:(NSString *)string&#123; //åˆ¤æ–­æ˜¯å¦ä¼ å…¥éœ€è¦åŠ å¯†æ•°æ®å‚æ•° if ((string == nil) || (string == NULL)) &#123; return nil; &#125; else if (![string isKindOfClass:[NSString class]]) &#123; return nil; &#125; //åˆ¤æ–­è®¾å¤‡ç³»ç»Ÿæ˜¯å¦æ»¡è¶³æ¡ä»¶ if ([[[UIDevice currentDevice] systemVersion] doubleValue] &lt;= 6.9) &#123; return nil; &#125; //ä½¿ç”¨ç³»ç»Ÿçš„APIè¿›è¡ŒBase64è§£å¯†æ“ä½œ NSDataBase64DecodingOptions options; options = NSDataBase64DecodingIgnoreUnknownCharacters; return [[NSData alloc] initWithBase64EncodedString:string options:options];&#125;/*****************************************************************************///ä½¿ç”¨Base64æ–‡ä»¶è¿›è¡ŒBase64åŠ å¯†å’Œè§£å¯†/*********************************ä½¿ç”¨Base64ç±»*********************************///ä½¿ç”¨Base64æ‰§è¡ŒåŠ å¯†æ“ä½œNSString *string = @\"abcdefghijklmnopqrstuvwxyz\";NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];NSString *encodeString = [Base64 base64EncodedStringWithData:data];NSLog(@\"encodeString : %@\", encodeString);//ä½¿ç”¨Base64æ‰§è¡Œè§£å¯†æ“ä½œNSString *decodeString = nil;NSData *decodeData = [Base64 base64DecodeDataWithString:encodeString];decodeString = [[NSString alloc] initWithData:decodeData encoding:NSUTF8StringEncoding];NSLog(@\"decodeString : %@\", decodeString);/******************************************************************************/ MD5åŠ å¯†ï¼ˆMD5æ˜¯ä¸€ç§æ‘˜è¦ï¼Œè€ŒéåŠ å¯†ï¼Œåªæ˜¯ç»å¸¸ä¸åŠ å¯†é…åˆä½¿ç”¨ï¼‰MD5çš„å…¨ç§°æ˜¯Message-DigestAlgorithm 5ï¼ŒMessage-Digestæ³›æŒ‡å­—èŠ‚ä¸²(Message)çš„Hashå˜æ¢ï¼Œå°±æ˜¯æŠŠä¸€ä¸ªä»»æ„é•¿åº¦çš„å­—èŠ‚ä¸²å˜æ¢æˆä¸€å®šé•¿çš„å¤§æ•´æ•°ã€‚è¯·æ³¨æ„æˆ‘ä½¿ç”¨äº†å­—èŠ‚ä¸²è€Œä¸æ˜¯å­—ç¬¦ä¸²è¿™ä¸ªè¯ï¼Œæ˜¯å› ä¸ºè¿™ç§å˜æ¢åªä¸å­—èŠ‚çš„å€¼æœ‰å…³ï¼Œä¸å­—ç¬¦é›†æˆ–ç¼–ç æ–¹å¼æ— å…³ã€‚MD5å°†ä»»æ„é•¿åº¦çš„å­—èŠ‚ä¸²å˜æ¢æˆä¸€ä¸ª128bitçš„å¤§æ•´æ•°ï¼Œå¹¶ä¸”å®ƒæ˜¯ä¸€ä¸ªä¸å¯é€†çš„å­—ç¬¦ä¸²å˜æ¢ç®—æ³•ï¼Œæ¢å¥è¯è¯´å°±æ˜¯ï¼Œå³ä½¿ä½ çœ‹åˆ°æºç¨‹åºå’Œç®—æ³•æè¿°ï¼Œä¹Ÿæ— æ³•å°†ä¸€ä¸ªMD5çš„å€¼å˜æ¢å›åŸå§‹çš„å­—ç¬¦ä¸²ï¼Œä»æ•°å­¦åŸç†ä¸Šè¯´ï¼Œæ˜¯å› ä¸ºåŸå§‹çš„å­—ç¬¦ä¸²æœ‰æ— ç©·å¤šä¸ªï¼Œè¿™æœ‰ç‚¹è±¡ä¸å­˜åœ¨åå‡½æ•°çš„æ•°å­¦å‡½æ•°ã€‚MD5çš„å…¸å‹åº”ç”¨æ˜¯å¯¹ä¸€æ®µMessage(å­—èŠ‚ä¸²)äº§ç”Ÿfingerprint(æŒ‡çº¹)ï¼Œä»¥é˜²æ­¢è¢«â€ç¯¡æ”¹â€ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä½ å°†ä¸€æ®µè¯å†™åœ¨ä¸€ä¸ªå«readme.txtæ–‡ä»¶ä¸­ï¼Œå¹¶å¯¹è¿™ä¸ªreadme.txtäº§ç”Ÿä¸€ä¸ªMD5çš„å€¼å¹¶è®°å½•åœ¨æ¡ˆï¼Œç„¶åä½ å¯ä»¥ä¼ æ’­è¿™ä¸ªæ–‡ä»¶ç»™åˆ«äººï¼Œåˆ«äººå¦‚æœä¿®æ”¹äº†æ–‡ä»¶ä¸­çš„ä»»ä½•å†…å®¹ï¼Œä½ å¯¹è¿™ä¸ªæ–‡ä»¶é‡æ–°è®¡ç®—MD5æ—¶å°±ä¼šå‘ç°ã€‚å¦‚æœå†æœ‰ä¸€ä¸ªç¬¬ä¸‰æ–¹çš„è®¤è¯æœºæ„ï¼Œç”¨MD5è¿˜å¯ä»¥é˜²æ­¢æ–‡ä»¶ä½œè€…çš„â€æŠµèµ–â€ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„æ•°å­—ç­¾ååº”ç”¨ã€‚MD5è¿˜å¹¿æ³›ç”¨äºåŠ å¯†å’Œè§£å¯†æŠ€æœ¯ä¸Šï¼Œåœ¨å¾ˆå¤šæ“ä½œç³»ç»Ÿä¸­ï¼Œç”¨æˆ·çš„å¯†ç æ˜¯ä»¥MD5å€¼ï¼ˆæˆ–ç±»ä¼¼çš„å…¶å®ƒç®—æ³•ï¼‰çš„æ–¹å¼ä¿å­˜çš„ï¼Œç”¨æˆ·Loginçš„æ—¶å€™ï¼Œç³»ç»Ÿæ˜¯æŠŠç”¨æˆ·è¾“å…¥çš„å¯†ç è®¡ç®—æˆMD5å€¼ï¼Œç„¶åå†å»å’Œç³»ç»Ÿä¸­ä¿å­˜çš„MD5å€¼è¿›è¡Œæ¯”è¾ƒï¼Œè€Œç³»ç»Ÿå¹¶â€ä¸çŸ¥é“â€ç”¨æˆ·çš„å¯†ç æ˜¯ä»€ä¹ˆã€‚MD5åŠ å¯†å¤§ä½“éƒ½åº”ç”¨åœ¨ï¼šéªŒè¯æ•°æ®æˆ–æ–‡ä»¶ä¸€è‡´æ€§ã€æ•°å­—ç­¾åã€å®‰å…¨è®¿é—®è®¤è¯ç­‰ç­‰ã€‚å¤§æ¦‚å¯æ¯”å–»ä¸ºï¼šäººçš„æŒ‡çº¹æ¥ç†è§£ã€‚æ³¨ï¼šMD5åŠ å¯†æ˜¯ä¸å¯é€†çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒMD5åŠ å¯†åæ˜¯ä¸èƒ½è§£å¯†çš„ï¼Œæ‰€è°“çš„è§£å¯†åªæ˜¯ç”¨å¤§æ•°æ®çš„â€è¯•ç”¨â€ï¼Œæ¥æµ‹å‡ºç»“æœçš„ã€‚MD5ç‰¹ç‚¹: å‹ç¼©æ€§ : ä»»æ„é•¿åº¦çš„æ•°æ®,ç®—å‡ºçš„MD5å€¼é•¿åº¦éƒ½æ˜¯å›ºå®šçš„ã€‚ å®¹æ˜“è®¡ç®— : ä»åŸæ•°æ®è®¡ç®—å‡ºMD5å€¼å¾ˆå®¹æ˜“ã€‚ æŠ—ä¿®æ”¹æ€§ : å¯¹åŸæ•°æ®è¿›è¡Œä»»ä½•æ”¹åŠ¨ï¼Œå“ªæ€•åªä¿®æ”¹ä¸€ä¸ªå­—èŠ‚ï¼Œæ‰€å¾—åˆ°çš„MD5å€¼éƒ½æœ‰å¾ˆå¤§åŒºåˆ«ã€‚ å¼±æŠ—ç¢°æ’ : å·²çŸ¥åŸæ•°æ®å’Œå…¶MD5å€¼ï¼Œæƒ³æ‰¾åˆ°ä¸€ä¸ªå…·æœ‰ç›¸åŒMD5å€¼çš„æ•°æ®ï¼ˆå³ä¼ªé€ æ•°æ®ï¼‰æ˜¯éå¸¸å›°éš¾çš„ã€‚ å¼ºæŠ—ç¢°æ’ : æƒ³æ‰¾åˆ°ä¸¤ä¸ªä¸åŒæ•°æ®ï¼Œä½¿ä»–ä»¬å…·æœ‰ç›¸åŒçš„MD5å€¼ï¼Œæ˜¯éå¸¸å›°éš¾çš„ã€‚ åœ¨iOSä¸­MD5åŠ å¯†å’ŒéªŒç­¾ä½¿ç”¨æ–¹æ³•ä»‹ç» 123456789101112131415161718192021222324252627282930313233343536373839/****************************MD5.mç±»å®ç°æ–‡ä»¶å†…å®¹****************************///å¯¹å­—ç¬¦ä¸²æ•°æ®è¿›è¡ŒMD5çš„ç­¾å+ (NSString *)md5SignWithString:(NSString *)string&#123; const char *object = [string UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(object,(CC_LONG)strlen(object),result); NSMutableString *hash = [NSMutableString string]; for (int i = 0; i &lt; 16; i ++) &#123; [hash appendFormat:@\"%02X\", result[i]]; &#125; return [hash lowercaseString];&#125;//å¯¹äºŒè¿›åˆ¶æ•°æ®è¿›è¡ŒMD5çš„ç­¾å+ (NSData *)md5SignWithData:(NSData *)data&#123; Byte byte[CC_MD5_DIGEST_LENGTH]; //å®šä¹‰ä¸€ä¸ªå­—èŠ‚æ•°ç»„æ¥æ¥æ”¶ç»“æœ CC_MD5((const void*)([data bytes]), (CC_LONG)[data length], byte); return [NSData dataWithBytes:byte length:CC_MD5_DIGEST_LENGTH];&#125;/******************************************************************************///ä½¿ç”¨MD5æ–‡ä»¶è¿›è¡ŒMD5åŠ å¯†å’ŒéªŒç­¾/*********************************ä½¿ç”¨MD5ç±»*********************************///ä½¿ç”¨MD5æ‰§è¡ŒåŠ å¯†æ“ä½œNSString *string2 = @\"abcdefghijklmnopqrstuvwxyz\";NSString *encodeString2 = [MD5 md5SignWithString:string2];NSLog(@\"encodeString2 : %@\", encodeString2);//MD5ä¸ºä¸å¯é€†çš„æ“ä½œï¼Œä½¿ç”¨MD5æ‰§è¡ŒéªŒç­¾æ“ä½œNSString *verifyString2 = [MD5 md5SignWithString:string2];NSLog(@\"verifyString2 : %@\", verifyString2);if ([verifyString2 isEqualToString:encodeString2]) &#123; NSLog(@\"md5 verify sign success\");&#125; else &#123; NSLog(@\"md5 verify sign failed\");&#125;/******************************************************************************/ AESåŠ å¯†ï¼ˆå¯¹ç§°åŠ å¯†çš„ä¸€ç§ï¼‰é«˜çº§åŠ å¯†æ ‡å‡†Advanced Encryption Standardç®€ç§°ï¼šAESï¼Œåœ¨å¯†ç å­¦ä¸­åˆç§°RijndaelåŠ å¯†æ³•ï¼Œæ˜¯ç¾å›½è”é‚¦æ”¿åºœé‡‡ç”¨çš„ä¸€ç§åŒºå—åŠ å¯†æ ‡å‡†ã€‚å®ƒæ˜¯ä¸€ç§å¯¹ç§°åŠ å¯†ç®—æ³•ï¼Œè¿™ä¸ªæ ‡å‡†ä¹Ÿæ›¿ä»£åŸå…ˆçš„DESæ ‡å‡†ï¼Œå·²ç»è¢«å¤šæ–¹åˆ†æä¸”å¹¿ä¸ºå…¨ä¸–ç•Œæ‰€ä½¿ç”¨ã€‚AESè®¾è®¡æœ‰ä¸‰ä¸ªå¯†é’¥é•¿åº¦:128ã€192ã€256ä½ï¼Œç›¸å¯¹è€Œè¨€ï¼ŒAESçš„128å¯†é’¥æ¯”DESçš„56å¯†é’¥å¼º1021å€ã€‚AESç®—æ³•ä¸»è¦åŒ…æ‹¬ä¸‰ä¸ªæ–¹é¢ï¼šè½®å˜åŒ–ã€åœˆæ•°å’Œå¯†é’¥æ‰©å±•ã€‚æ€»ä½“æ¥è¯´ï¼ŒAESä½œä¸ºæ–°ä¸€ä»£çš„æ•°æ®åŠ å¯†æ ‡å‡†æ±‡èšäº†å¼ºå®‰å…¨æ€§ã€é«˜æ€§èƒ½ã€é«˜æ•ˆç‡ã€æ˜“ç”¨å’Œçµæ´»ï¼Œåœ¨è½¯ä»¶åŠç¡¬ä»¶ä¸Šéƒ½èƒ½å¿«é€Ÿåœ°åŠ è§£å¯†ä¸”åªéœ€è¦å¾ˆå°‘çš„å­˜å‚¨èµ„æºç­‰ä¼˜ç‚¹ã€‚ AESåŠ è§£å¯†ç‰¹ç‚¹ï¼š AESå¼ºå®‰å…¨æ€§ã€é«˜æ€§èƒ½ã€é«˜æ•ˆç‡ã€æ˜“ç”¨å’Œçµæ´»ã€‚ åœ¨è½¯ä»¶åŠç¡¬ä»¶ä¸Šéƒ½èƒ½å¿«é€Ÿåœ°åŠ è§£å¯†ä¸”åªéœ€è¦å¾ˆå°‘çš„å­˜å‚¨èµ„æºã€‚ AESåŠ å¯†éœ€è¦çš„å‚æ•°ï¼š å¯†é’¥é•¿åº¦ï¼ˆKey Sizeï¼‰AESç®—æ³•ä¸‹ï¼Œkeyçš„é•¿åº¦æœ‰ä¸‰ç§ï¼š128ã€192å’Œ256 bitsã€‚ç”±äºå†å²åŸå› ï¼ŒJDKé»˜è®¤åªæ”¯æŒä¸å¤§äº128 bitsçš„å¯†é’¥ï¼Œè€Œ128 bitsçš„keyå·²èƒ½å¤Ÿæ»¡è¶³å•†ç”¨å®‰å…¨éœ€æ±‚ã€‚å› æ­¤æœ¬ä¾‹å…ˆä½¿ç”¨AES-128ã€‚ï¼ˆJavaä½¿ç”¨å¤§äº128 bitsçš„keyæ–¹æ³•åœ¨æ–‡æœ«æåŠï¼‰ åŠ å¯†æ¨¡å¼ï¼ˆCipher Modeï¼‰AESå±äºå—åŠ å¯†ï¼ˆBlock Cipherï¼‰ï¼Œå—åŠ å¯†ä¸­æœ‰CBCã€ECBã€CTRã€OFBã€CFBç­‰å‡ ç§å·¥ä½œæ¨¡å¼ã€‚æœ¬ä¾‹ç»Ÿä¸€ä½¿ç”¨CBCæ¨¡å¼ã€‚ å¡«å……æ–¹å¼ï¼ˆPaddingï¼‰ç”±äºå—åŠ å¯†åªèƒ½å¯¹ç‰¹å®šé•¿åº¦çš„æ•°æ®å—è¿›è¡ŒåŠ å¯†ï¼Œå› æ­¤CBCã€ECBæ¨¡å¼éœ€è¦åœ¨æœ€åä¸€æ•°æ®å—åŠ å¯†å‰è¿›è¡Œæ•°æ®å¡«å……ã€‚ï¼ˆCFBï¼ŒOFBå’ŒCTRæ¨¡å¼ç”±äºä¸keyè¿›è¡ŒåŠ å¯†æ“ä½œçš„æ˜¯ä¸Šä¸€å—åŠ å¯†åçš„å¯†æ–‡ï¼Œå› æ­¤ä¸éœ€è¦å¯¹æœ€åä¸€æ®µæ˜æ–‡è¿›è¡Œå¡«å……ï¼‰åœ¨iOS SDKä¸­æä¾›äº†PKCS7Paddingï¼Œè€ŒJDKåˆ™æä¾›äº†PKCS5Paddingã€‚åŸåˆ™ä¸ŠPKCS5Paddingé™åˆ¶äº†å¡«å……çš„Block Sizeä¸º8 bytesï¼Œè€ŒJavaå®é™…ä¸Šå½“å—å¤§äºè¯¥å€¼æ—¶ï¼Œå…¶PKCS5Paddingä¸PKCS7Paddingæ˜¯ç›¸ç­‰çš„ï¼šæ¯éœ€è¦å¡«å……Ï‡ä¸ªå­—èŠ‚ï¼Œå¡«å……çš„å€¼å°±æ˜¯Ï‡ã€‚ åˆå§‹å‘é‡ï¼ˆInitialization Vectorï¼‰ä½¿ç”¨é™¤ECBä»¥å¤–çš„å…¶ä»–åŠ å¯†æ¨¡å¼å‡éœ€è¦ä¼ å…¥ä¸€ä¸ªåˆå§‹å‘é‡ï¼Œå…¶å¤§å°ä¸Block Sizeç›¸ç­‰ï¼ˆAESçš„Block Sizeä¸º128 bitsï¼‰ï¼Œè€Œä¸¤ä¸ªå¹³å°çš„APIæ–‡æ¡£å‡æŒ‡æ˜å½“ä¸ä¼ å…¥åˆå§‹å‘é‡æ—¶ï¼Œç³»ç»Ÿå°†é»˜è®¤ä½¿ç”¨ä¸€ä¸ªå…¨0çš„åˆå§‹å‘é‡ã€‚æœ‰äº†ä¸Šè¿°çš„åŸºç¡€ä¹‹åï¼Œå¯ä»¥å¼€å§‹åˆ†åˆ«åœ¨ä¸¤ä¸ªå¹³å°è¿›è¡Œå®ç°äº†ã€‚ åœ¨iOSä¸­AESåŠ è§£å¯†çš„å®ç°ä»‹ç» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//éœ€è¦å¯¼å…¥ï¼š#import &lt;CommonCrypto/CommonCrypto.h&gt;åº“æ‰èƒ½ä½¿ç”¨/** * AES128 + ECB + PKCS7 * @param data è¦åŠ å¯†çš„åŸå§‹æ•°æ® * @param key åŠ å¯† key * @return åŠ å¯†åæ•°æ® */+ (NSData *)encryptData:(NSData *)data key:(NSData *)key&#123; //åˆ¤æ–­è§£å¯†çš„æµæ•°æ®æ˜¯å¦å­˜åœ¨ if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([data length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­è§£å¯†çš„Keyæ˜¯å¦å­˜åœ¨ if ((key == nil) || (key == NULL)) &#123; return nil; &#125; else if (![key isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([key length] &lt;= 0) &#123; return nil; &#125; //setup key NSData *result = nil; unsigned char cKey[kCCKeySizeAES128]; bzero(cKey, sizeof(cKey)); [key getBytes:cKey length:kCCKeySizeAES128]; //setup output buffer size_t bufferSize = [data length] + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //do encrypt size_t encryptedSize = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionECBMode|kCCOptionPKCS7Padding, cKey, kCCKeySizeAES128, nil, [data bytes], [data length], buffer, bufferSize, &amp;encryptedSize); if (cryptStatus == kCCSuccess) &#123; result = [NSData dataWithBytesNoCopy:buffer length:encryptedSize]; &#125; else &#123; free(buffer); &#125; return result;&#125;/** * AES128 + ECB + PKCS7 * @param data è¦è§£å¯†çš„åŸå§‹æ•°æ® * @param key è§£å¯† key * @return è§£å¯†åæ•°æ® */+ (NSData *)decryptData:(NSData *)data key:(NSData *)key&#123; //åˆ¤æ–­è§£å¯†çš„æµæ•°æ®æ˜¯å¦å­˜åœ¨ if ((data == nil) || (data == NULL)) &#123; return nil; &#125; else if (![data isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([data length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­è§£å¯†çš„Keyæ˜¯å¦å­˜åœ¨ if ((key == nil) || (key == NULL)) &#123; return nil; &#125; else if (![key isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([key length] &lt;= 0) &#123; return nil; &#125; //setup key NSData *result = nil; unsigned char cKey[kCCKeySizeAES128]; bzero(cKey, sizeof(cKey)); [key getBytes:cKey length:kCCKeySizeAES128]; //setup output buffer size_t bufferSize = [data length] + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //do decrypt size_t decryptedSize = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionECBMode|kCCOptionPKCS7Padding, cKey, kCCKeySizeAES128, nil, [data bytes], [data length], buffer, bufferSize, &amp;decryptedSize); if (cryptStatus == kCCSuccess) &#123; result = [NSData dataWithBytesNoCopy:buffer length:decryptedSize]; &#125; else &#123; free(buffer); &#125; return result;&#125; åœ¨iOSä¸­AESåŠ è§£å¯†ä½¿ç”¨æ–¹æ³•ä»‹ç» 123456789101112131415//ä½¿ç”¨AESæ‰§è¡ŒåŠ å¯†æ“ä½œNSString *aesKey = @\"a1b2c3d4e5f6g7h8\";NSString *string3 = @\"abcdefghijklmnopqrstuvwxyz\";NSData *keyData3 = [aesKey dataUsingEncoding:NSUTF8StringEncoding];NSData *sourceData3 = [string3 dataUsingEncoding:NSUTF8StringEncoding];NSData *encodeData3 = [AESEncrypt encryptData:sourceData3 key:keyData3];NSLog(@\"encodeData3 : %@\", encodeData3);//ä½¿ç”¨AESæ‰§è¡Œè§£å¯†æ“ä½œNSString *decodeString3 = nil;NSData *decodeData3 = [AESEncrypt decryptData:encodeData3 key:keyData3];decodeString3 = [[NSString alloc] initWithData:decodeData3 encoding:NSUTF8StringEncoding];NSLog(@\"decodeString3 : %@\", decodeString3); RSAåŠ å¯†ï¼ˆéå¯¹ç§°åŠ å¯†çš„ä¸€ç§ï¼‰RSAæ˜¯ç›®å‰æœ€æœ‰å½±å“åŠ›çš„å…¬é’¥åŠ å¯†ç®—æ³•ï¼Œå®ƒèƒ½å¤ŸæŠµæŠ—åˆ°ç›®å‰ä¸ºæ­¢å·²çŸ¥çš„ç»å¤§å¤šæ•°å¯†ç æ”»å‡»ï¼Œå·²è¢«ISOæ¨èä¸ºå…¬é’¥æ•°æ®åŠ å¯†æ ‡å‡†ã€‚RSAçš„å…¬å¼€å¯†é’¥å¯†ç ä½“åˆ¶å°±æ˜¯ä½¿ç”¨ä¸åŒçš„åŠ å¯†å¯†é’¥ä¸è§£å¯†å¯†é’¥ï¼Œæ˜¯ä¸€ç§â€œç”±å·²çŸ¥åŠ å¯†å¯†é’¥æ¨å¯¼å‡ºè§£å¯†å¯†é’¥åœ¨è®¡ç®—ä¸Šæ˜¯ä¸å¯è¡Œçš„â€å¯†ç ä½“åˆ¶ã€‚é€šå¸¸æ˜¯å…ˆç”Ÿæˆä¸€å¯¹RSAå¯†é’¥ï¼Œå…¶ä¸­ä¹‹ä¸€æ˜¯ä¿å¯†å¯†é’¥ï¼Œç”±ç”¨æˆ·ä¿å­˜ï¼›å¦ä¸€ä¸ªä¸ºå…¬å¼€å¯†é’¥ï¼Œå¯å¯¹å¤–å…¬å¼€ï¼Œç”šè‡³å¯åœ¨ç½‘ç»œæœåŠ¡å™¨ä¸­æ³¨å†Œã€‚ä¸ºæé«˜ä¿å¯†å¼ºåº¦ï¼ŒRSAå¯†é’¥è‡³å°‘ä¸º500ä½é•¿ï¼Œä¸€èˆ¬æ¨èä½¿ç”¨1024ä½ï¼Œè¿™å°±ä½¿åŠ å¯†çš„è®¡ç®—é‡å¾ˆå¤§ã€‚ä¸ºå‡å°‘è®¡ç®—é‡ï¼Œåœ¨ä¼ é€ä¿¡æ¯æ—¶ï¼Œå¸¸é‡‡ç”¨ä¼ ç»ŸåŠ å¯†æ–¹æ³•ä¸å…¬å¼€å¯†é’¥åŠ å¯†æ–¹æ³•ç›¸ç»“åˆçš„æ–¹å¼ï¼Œå³ä¿¡æ¯é‡‡ç”¨æ”¹è¿›çš„DESæˆ–IDEAå¯¹è¯å¯†é’¥åŠ å¯†ï¼Œç„¶åä½¿ç”¨RSAå¯†é’¥åŠ å¯†å¯¹è¯å¯†é’¥å’Œä¿¡æ¯æ‘˜è¦ï¼Œå¯¹æ–¹æ”¶åˆ°ä¿¡æ¯åï¼Œç”¨ä¸åŒçš„å¯†é’¥è§£å¯†å¹¶å¯æ ¸å¯¹ä¿¡æ¯æ‘˜è¦ã€‚RSAç®—æ³•æ˜¯ç¬¬ä¸€ä¸ªèƒ½åŒæ—¶ç”¨äºåŠ å¯†å’Œæ•°å­—ç­¾åçš„ç®—æ³•ï¼Œä¹Ÿæ˜“äºç†è§£å’Œæ“ä½œï¼ŒRSAæ˜¯è¢«ç ”ç©¶å¾—æœ€å¹¿æ³›çš„å…¬é’¥ç®—æ³•ã€‚RSAç®—æ³•æ˜¯ä¸€ç§éå¯¹ç§°å¯†ç ç®—æ³•ï¼Œæ‰€è°“éå¯¹ç§°ï¼Œå°±æ˜¯æŒ‡è¯¥ç®—æ³•éœ€è¦ä¸€å¯¹å¯†é’¥ï¼Œä½¿ç”¨å…¶ä¸­ä¸€ä¸ªåŠ å¯†ï¼Œåˆ™éœ€è¦ç”¨å¦ä¸€ä¸ªæ‰èƒ½è§£å¯†ã€‚RSAåŠ å¯†å¤§ä½“éƒ½åº”ç”¨åœ¨ï¼šæœ¬åœ°æ•°æ®åŠ å¯†ã€ç½‘ç»œä¼ è¾“æ•°æ®åŠ å¯†ã€æ–¹æ³•ä½“å’Œæ–¹æ³•åé«˜çº§æ··æ·†ä»¥åŠç¨‹åºç»“æ„æ··æ’åŠ å¯†ã€‚ä¾‹å¦‚ï¼šå¯¹å®¢æˆ·ç«¯ä¼ è¾“æ•°æ®æä¾›åŠ å¯†æ–¹æ¡ˆï¼Œæœ‰æ•ˆé˜²æ­¢é€šè¿‡ç½‘ç»œæ¥å£çš„æ‹¦æˆªè·å–ã€‚ RSAçš„ç®—æ³•æ¶‰åŠä¸‰ä¸ªå‚æ•°ï¼Œnã€e1ã€e2ã€‚å…¶ä¸­ï¼Œnæ˜¯ä¸¤ä¸ªå¤§è´¨æ•°pã€qçš„ç§¯ï¼Œnçš„äºŒè¿›åˆ¶è¡¨ç¤ºæ—¶æ‰€å ç”¨çš„ä½æ•°ï¼Œå°±æ˜¯æ‰€è°“çš„å¯†é’¥é•¿åº¦ã€‚e1å’Œe2æ˜¯ä¸€å¯¹ç›¸å…³çš„å€¼ï¼Œe1å¯ä»¥ä»»æ„å–ï¼Œä½†è¦æ±‚e1ä¸(p-1)(q-1)äº’è´¨ï¼›å†é€‰æ‹©e2ï¼Œè¦æ±‚(e2e1)mod((p-1)*(q-1))=1ã€‚(nï¼Œe1)ï¼Œ(nï¼Œe2)å°±æ˜¯å¯†é’¥å¯¹ã€‚å…¶ä¸­(nï¼Œe1)ä¸ºå…¬é’¥ï¼Œ(nï¼Œe2)ä¸ºç§é’¥ï¼›RSAåŠ è§£å¯†çš„ç®—æ³•å®Œå…¨ç›¸åŒï¼Œå…¬é’¥åŠ å¯†ä½“åˆ¶ä¸­ï¼Œä¸€èˆ¬ç”¨å…¬é’¥åŠ å¯†ï¼Œç§é’¥è§£å¯†ã€‚å‡è®¾Aä¸ºæ˜æ–‡ï¼ŒBä¸ºå¯†æ–‡ï¼Œåˆ™ï¼šA=B^e2 mod nï¼›B=A^e1 mod nï¼›e1å’Œe2å¯ä»¥äº’æ¢ä½¿ç”¨ï¼Œå³ç§é’¥åŠ å¯†ï¼Œå…¬é’¥è§£å¯†ï¼Œå…¬å¼ï¼šA=B^e1 mod nï¼›B=A^e2 mod n; RSAåŠ è§£å¯†ç‰¹ç‚¹ï¼š RSAå¯†é’¥ç®¡ç†çš„æ–¹ä¾¿ï¼Œè®¡ç®—é‡å¾ˆå¤§é€Ÿåº¦ç›¸å¯¹æ¯”è¾ƒæ…¢ã€‚ RSAå®‰å…¨æ€§å¾ˆé«˜ï¼Œèƒ½å¤ŸæŠµæŠ—åˆ°ç›®å‰ä¸ºæ­¢å·²çŸ¥çš„ç»å¤§å¤šæ•°å¯†ç æ”»å‡»ã€‚åœ¨çº¿ç”ŸæˆRSAå¯†é’¥å¯¹çš„ç½‘å€ï¼šåœ¨çº¿ç”Ÿæˆéå¯¹ç§°åŠ å¯†å…¬é’¥ç§é’¥å¯¹ç­‰ï¼ŒRSAå¯†é’¥æ ¼å¼è¯·ä½¿ç”¨PKCS#8æ ¼å¼ã€‚PKCS#1ä¸PKCS#8çš„åŒºåˆ«è¿˜å¾…åç»­æŸ¥é˜…èµ„æ–™ï¼Œå†è¿›è¡Œè¡¥å……è®°å½•ã€‚ åœ¨iOSä¸­RSAåŠ è§£å¯†çš„å®ç°ä»‹ç»ï¼ˆæ”¯æŒå¯†é’¥æ–‡ä»¶&lt;.pem&gt;å’Œå­—ç¬¦ä¸²å¯†é’¥ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655/****************************RSAEncrypt.mç±»å®ç°æ–‡ä»¶å†…å®¹****************************/#pragma mark - Class Utils Method+ (BOOL)isEmptyKeyRef:(id)object&#123; if (object == nil) &#123; return YES; &#125; else if (object == NULL) &#123; return YES; &#125; else if (object == [NSNull null]) &#123; return YES; &#125; return NO;&#125;#pragma mark - Private Method+ (SecKeyRef)getPrivateKeyRefWithFilePath:(NSString *)filePath keyPassword:(NSString *)keyPassword&#123; //è¯»å–ç§é’¥è¯ä¹¦æ–‡ä»¶çš„å†…å®¹ NSData *certificateData = [NSData dataWithContentsOfFile:filePath]; if ((certificateData == nil) || (certificateData == NULL)) &#123; return nil; &#125; else if (![certificateData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([certificateData length] &lt;= 0) &#123; return nil; &#125; //æ‹¼æ¥å¯†ç å‚æ•°åˆ°å­—å…¸ä¸­ NSString *passwordKey = (__bridge id)kSecImportExportPassphrase; NSString *passwordValue = [NSString stringWithFormat:@\"%@\",keyPassword]; if ((keyPassword == nil) || (keyPassword == NULL)) &#123; passwordValue = @\"\"; &#125; else if (![keyPassword isKindOfClass:[NSString class]]) &#123; passwordValue = @\"\"; &#125; else if ([keyPassword length] &lt;= 0) &#123; passwordValue = @\"\"; &#125; NSMutableDictionary *optionInfo = [[NSMutableDictionary alloc] init]; [optionInfo setObject:passwordValue forKey:passwordKey]; //è·å–ç§é’¥å¯¹è±¡ SecKeyRef privateKeyRef = NULL; CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL); CFDataRef pkcs12Data = (__bridge CFDataRef)certificateData; CFDictionaryRef options = (__bridge CFDictionaryRef)optionInfo; OSStatus securityStatus = SecPKCS12Import(pkcs12Data, options, &amp;items); if (securityStatus == noErr &amp;&amp; CFArrayGetCount(items) &gt; 0) &#123; SecIdentityRef identity; const void *secpkey = kSecImportItemIdentity; CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0); identity = (SecIdentityRef)CFDictionaryGetValue(identityDict,secpkey); securityStatus = SecIdentityCopyPrivateKey(identity, &amp;privateKeyRef); if (securityStatus != noErr) &#123; privateKeyRef = NULL; &#125; &#125; CFRelease(items); return privateKeyRef;&#125;+ (SecKeyRef)privateKeyRefWithPrivateKey:(NSString *)privateKey&#123; //åˆ¤æ–­å‚æ•°æ˜¯å¦æ­£ç¡® if ((privateKey == nil) || (privateKey == NULL)) &#123; return nil; &#125; else if (![privateKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKey length] &lt;= 0) &#123; return nil; &#125; //è§£æç§é’¥å¯¹è±¡å†…å®¹ NSString *pKey = [NSString stringWithFormat:@\"%@\",privateKey]; NSRange sposition = [pKey rangeOfString:@\"-----BEGIN RSA PRIVATE KEY-----\"]; NSRange eposition = [pKey rangeOfString:@\"-----END RSA PRIVATE KEY-----\"]; if (sposition.location != NSNotFound &amp;&amp; eposition.location != NSNotFound) &#123; NSUInteger endposition = eposition.location; NSUInteger startposition = sposition.location + sposition.length; NSRange range = NSMakeRange(startposition, endposition-startposition); pKey = [pKey substringWithRange:range]; &#125; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; //This will be base64 encoded, decode it. NSData *keyData = [Base64 base64DecodeDataWithString:pKey]; keyData = [self stripPrivateKeyHeader:keyData]; if ((keyData == nil) || (keyData == NULL)) &#123; return nil; &#125; else if (![keyData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([keyData length] &lt;= 0) &#123; return nil; &#125; //a tag to read/write keychain storage NSString *tag = @\"RSAUtil_PrivKey\"; const void *bytes = [tag UTF8String]; NSData *tagData = [NSData dataWithBytes:bytes length:[tag length]]; //Delete any old lingering key with the same tag NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init]; [attributes setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; [attributes setObject:tagData forKey:(__bridge id)kSecAttrApplicationTag]; SecItemDelete((__bridge CFDictionaryRef)attributes); //Add persistent version of the key to system keychain [attributes setObject:keyData forKey:(__bridge id)kSecValueData]; [attributes setObject:(__bridge id)kSecAttrKeyClassPrivate forKey:(__bridge id)kSecAttrKeyClass]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnPersistentRef]; OSStatus status = noErr; CFTypeRef persistKey = nil; status = SecItemAdd((__bridge CFDictionaryRef)attributes, &amp;persistKey); if (persistKey != nil) &#123;CFRelease(persistKey);&#125; if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) &#123; return nil; &#125; [attributes removeObjectForKey:(__bridge id)kSecValueData]; [attributes removeObjectForKey:(__bridge id)kSecReturnPersistentRef]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; //Now fetch the SecKeyRef version of the key SecKeyRef keyRef = nil; CFDictionaryRef query = (__bridge CFDictionaryRef)attributes; status = SecItemCopyMatching(query, (CFTypeRef *)&amp;keyRef); if (status != noErr) &#123; return nil; &#125; return keyRef;&#125;+ (NSData *)stripPrivateKeyHeader:(NSData *)d_key&#123; //Skip ASN.1 private key header if (d_key == nil) return nil; unsigned long len = [d_key length]; if (!len) return nil; unsigned char *c_key = (unsigned char *)[d_key bytes]; unsigned int idx = 22; //magic byte at offset 22 if (0x04 != c_key[idx++]) return nil; //calculate length of the key unsigned int c_len = c_key[idx++]; if (!(c_len &amp; 0x80)) &#123; c_len = c_len &amp; 0x7f; &#125; else &#123; int byteCount = c_len &amp; 0x7f; if (byteCount + idx &gt; len) &#123; //rsa length field longer than buffer return nil; &#125; unsigned int accum = 0; unsigned char *ptr = &amp;c_key[idx]; idx += byteCount; while (byteCount) &#123; accum = (accum &lt;&lt; 8) + *ptr; ptr++; byteCount--; &#125; c_len = accum; &#125; //Now make a new NSData from this buffer return [d_key subdataWithRange:NSMakeRange(idx, c_len)];&#125;+ (SecKeyRef)getPublicKeyRefWithFilePath:(NSString *)filePath&#123; //è¯»å–å…¬é’¥è¯ä¹¦æ–‡ä»¶çš„å†…å®¹ NSData *certificateData = [NSData dataWithContentsOfFile:filePath]; if ((certificateData == nil) || (certificateData == NULL)) &#123; return nil; &#125; else if (![certificateData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([certificateData length] &lt;= 0) &#123; return nil; &#125; //å°†å…¬é’¥è¯ä¹¦åˆ¶ä½œæˆè¯ä¹¦å¯¹è±¡ CFDataRef data = (__bridge CFDataRef)certificateData; SecCertificateRef certificateRef = SecCertificateCreateWithData(NULL, data); //è·å–å…¬é’¥å¯¹è±¡ SecTrustRef trust = NULL; SecKeyRef publicKey = NULL; SecPolicyRef policies = SecPolicyCreateBasicX509(); if (![[self class] isEmptyKeyRef:(__bridge id)(certificateRef)] &amp;&amp; ![[self class] isEmptyKeyRef:(__bridge id)(policies)]) &#123; OSStatus status; status = SecTrustCreateWithCertificates((CFTypeRef)certificateRef, policies, &amp;trust); if (status == noErr) &#123; SecTrustResultType result; if (SecTrustEvaluate(trust, &amp;result) == noErr) &#123; publicKey = SecTrustCopyPublicKey(trust); &#125; &#125; &#125; if (certificateRef != NULL) CFRelease(certificateRef); if (policies != NULL) CFRelease(policies); if (trust != NULL) CFRelease(trust); return publicKey;&#125;+ (SecKeyRef)publicKeyRefWithPublicKey:(NSString *)publicKey&#123; //åˆ¤æ–­å‚æ•°æ˜¯å¦æ­£ç¡® if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //è§£æå…¬é’¥å¯¹è±¡å†…å®¹ NSString *pKey = [NSString stringWithFormat:@\"%@\",publicKey]; NSRange sposition = [pKey rangeOfString:@\"-----BEGIN PUBLIC KEY-----\"]; NSRange eposition = [pKey rangeOfString:@\"-----END PUBLIC KEY-----\"]; if (sposition.location != NSNotFound &amp;&amp; eposition.location != NSNotFound) &#123; NSUInteger startposition = eposition.location; NSUInteger endposition = sposition.location + sposition.length; NSRange range = NSMakeRange(endposition, startposition-endposition); pKey = [pKey substringWithRange:range]; &#125; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"]; pKey = [pKey stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]; //This will be base64 encoded, decode it. NSData *keyData = [[self class] base64DecodeDataWithString:pKey]; keyData = [self stripPublicKeyHeader:keyData]; if ((keyData == nil) || (keyData == NULL)) &#123; return nil; &#125; else if (![keyData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([keyData length] &lt;= 0) &#123; return nil; &#125; //a tag to read/write keychain storage NSString *tag = @\"RSAUtil_PubKey\"; const void *bytes = [tag UTF8String]; NSData *tagData = [NSData dataWithBytes:bytes length:[tag length]]; //Delete any old lingering key with the same tag NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init]; [attributes setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; [attributes setObject:tagData forKey:(__bridge id)kSecAttrApplicationTag]; SecItemDelete((__bridge CFDictionaryRef)attributes); //Add persistent version of the key to system keychain [attributes setObject:keyData forKey:(__bridge id)kSecValueData]; [attributes setObject:(__bridge id)kSecAttrKeyClassPublic forKey:(__bridge id)kSecAttrKeyClass]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnPersistentRef]; OSStatus status = noErr; CFTypeRef persistKey = nil; status = SecItemAdd((__bridge CFDictionaryRef)attributes, &amp;persistKey); if (persistKey != nil) CFRelease(persistKey); if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) &#123; return nil; &#125; [attributes removeObjectForKey:(__bridge id)kSecValueData]; [attributes removeObjectForKey:(__bridge id)kSecReturnPersistentRef]; [attributes setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef]; [attributes setObject:(__bridge id)kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType]; //Now fetch the SecKeyRef version of the key SecKeyRef publicKeyRef = nil; CFDictionaryRef query = (__bridge CFDictionaryRef)attributes; status = SecItemCopyMatching(query, (CFTypeRef *)&amp;publicKeyRef); if (status != noErr) &#123; return nil; &#125; return publicKeyRef;&#125;+ (NSData *)stripPublicKeyHeader:(NSData *)d_key&#123; //Skip ASN.1 public key header if (d_key == nil) &#123;return nil;&#125; unsigned long len = [d_key length]; if (!len) return(nil); unsigned char *c_key = (unsigned char *)[d_key bytes]; unsigned int idx = 0; if (c_key[idx++] != 0x30) &#123;return nil;&#125; if (c_key[idx] &gt; 0x80) &#123; idx += c_key[idx] - 0x80 + 1; &#125; else &#123; idx++; &#125; //PKCS #1 rsaEncryption szOID_RSA_RSA static unsigned char seqiod[] = &#123;0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00&#125;; if (memcmp(&amp;c_key[idx], seqiod, 15)) &#123;return nil;&#125; idx += 15; if (c_key[idx++] != 0x03) &#123;return nil;&#125; if (c_key[idx] &gt; 0x80) &#123; idx += c_key[idx] - 0x80 + 1; &#125; else &#123; idx ++; &#125; if (c_key[idx++] != '\\0') &#123;return nil;&#125; //Now make a new NSData from this buffer return ([NSData dataWithBytes:&amp;c_key[idx] length:len - idx]);&#125;+ (NSData *)encryptData:(NSData *)data withKeyRef:(SecKeyRef)keyRef&#123; const uint8_t *srcbuf = (const uint8_t *)[data bytes]; size_t srclen = (size_t)data.length; size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t); void *outbuf = malloc(block_size); size_t src_block_size = block_size - 11; NSMutableData *ret = [[NSMutableData alloc] init]; for (int idx = 0; idx &lt; srclen; idx += src_block_size) &#123; size_t data_len = srclen - idx; if(data_len &gt; src_block_size)&#123; data_len = src_block_size; &#125; size_t outlen = block_size; OSStatus status = noErr; status = SecKeyEncrypt(keyRef, kSecPaddingPKCS1, srcbuf + idx, data_len, outbuf, &amp;outlen); if (status != 0) &#123; NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", (int)status); ret = nil; break; &#125; else &#123; [ret appendBytes:outbuf length:outlen]; &#125; &#125; free(outbuf); CFRelease(keyRef); return ret;&#125;+ (NSData *)decryptData:(NSData *)data withKeyRef:(SecKeyRef)keyRef&#123; const uint8_t *srcbuf = (const uint8_t *)[data bytes]; size_t srclen = (size_t)data.length; size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t); UInt8 *outbuf = malloc(block_size); size_t src_block_size = block_size; NSMutableData *ret = [[NSMutableData alloc] init]; for (int idx = 0; idx &lt; srclen; idx += src_block_size) &#123; size_t data_len = srclen - idx; if(data_len &gt; src_block_size) &#123; data_len = src_block_size; &#125; size_t outlen = block_size; OSStatus status = noErr; status = SecKeyDecrypt(keyRef, kSecPaddingNone, srcbuf + idx, data_len, outbuf, &amp;outlen); if (status != 0) &#123; NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", (int)status); ret = nil; break; &#125; else &#123; int idxFirstZero = -1; int idxNextZero = (int)outlen; for (int i = 0; i &lt; outlen; i ++) &#123; if (outbuf[i] == 0) &#123; if (idxFirstZero &lt; 0) &#123; idxFirstZero = i; &#125; else &#123; idxNextZero = i; break; &#125; &#125; &#125; NSUInteger length = idxNextZero-idxFirstZero-1; [ret appendBytes:&amp;outbuf[idxFirstZero+1] length:length]; &#125; &#125; free(outbuf); CFRelease(keyRef); return ret;&#125;#pragma mark - RSA Key File Encrypt/Decrypt Public Method+ (NSString *)encryptString:(NSString *)originString publicKeyPath:(NSString *)publicKeyPath&#123; //åˆ¤æ–­originStringå‚æ•°æ˜¯å¦æ­£ç¡® if ((originString == nil) || (originString == NULL)) &#123; return nil; &#125; else if (![originString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([originString length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­publicKeyPathå‚æ•°æ˜¯å¦æ­£ç¡® if ((publicKeyPath == nil) || (publicKeyPath == NULL)) &#123; return nil; &#125; else if (![publicKeyPath isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKeyPath length] &lt;= 0) &#123; return nil; &#125; //è·å–å…¬é’¥å¯¹è±¡å’Œéœ€è¦åŠ å¯†çš„å­—ç¬¦ä¸²å†…å®¹ç¼–ç æ•°æ®æµ SecKeyRef publicKeyRef = [self getPublicKeyRefWithFilePath:publicKeyPath]; NSData *originData = [originString dataUsingEncoding:NSUTF8StringEncoding]; if ([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)]) &#123; return nil; &#125; if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; //åŠ å¯†æºå­—ç¬¦ä¸²å†…å®¹ç¼–ç æ•°æ®æµçš„æ•°æ® NSData *resultData = nil; resultData = [self encryptData:originData withKeyRef:publicKeyRef]; return [[self class] base64EncodedStringWithData:resultData];&#125;+ (NSString *)decryptString:(NSString *)encryptString privateKeyPath:(NSString *)privateKeyPath privateKeyPwd:(NSString *)privateKeyPwd&#123; //åˆ¤æ–­encryptStringå‚æ•°æ˜¯å¦æ­£ç¡® if ((encryptString == nil) || (encryptString == NULL)) &#123; return nil; &#125; else if (![encryptString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([encryptString length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­publicKeyPathå‚æ•°æ˜¯å¦æ­£ç¡® if ((privateKeyPath == nil) || (privateKeyPath == NULL)) &#123; return nil; &#125; else if (![privateKeyPath isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKeyPath length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­å¯†ç æ˜¯å¦å­˜åœ¨ NSString *keyPassword = [NSString stringWithFormat:@\"%@\",privateKeyPwd]; if ((privateKeyPwd == nil) || (privateKeyPwd == NULL)) &#123; keyPassword = @\"\"; &#125; else if (![privateKeyPwd isKindOfClass:[NSString class]]) &#123; keyPassword = @\"\"; &#125; else if ([privateKeyPwd length] &lt;= 0) &#123; keyPassword = @\"\"; &#125; //è·å–ç§é’¥å¯¹è±¡å’Œéœ€è¦åŠ å¯†çš„å­—ç¬¦ä¸²å†…å®¹ç¼–ç æ•°æ®æµ NSData *encryptData = nil, *decryptData = nil; SecKeyRef privateKeyRef = [self getPrivateKeyRefWithFilePath:privateKeyPath keyPassword:privateKeyPwd]; encryptData = [[self class] base64DecodeDataWithString:encryptString]; if ([[self class] isEmptyKeyRef:(__bridge id)(privateKeyRef)]) &#123; return nil; &#125; if ((encryptData == nil) || (encryptData == NULL)) &#123; return nil; &#125; else if (![encryptData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([encryptData length] &lt;= 0) &#123; return nil; &#125; NSStringEncoding encoding = NSUTF8StringEncoding; decryptData = [self decryptData:encryptData withKeyRef:privateKeyRef]; return [[NSString alloc] initWithData:decryptData encoding:encoding];&#125;#pragma mark - RSA Key String Encrypt/Decrypt Public Method+ (NSData *)encryptData:(NSData *)originData publicKey:(NSString *)publicKey&#123; //åˆ¤æ–­originDataå‚æ•°æ˜¯å¦æ­£ç¡® if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­publicKeyPathå‚æ•°æ˜¯å¦æ­£ç¡® if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //è·å–éœ€è¦åŠ å¯†çš„å­—ç¬¦ä¸²å†…å®¹ç¼–ç æ•°æ®æµ SecKeyRef publicKeyRef = [self publicKeyRefWithPublicKey:publicKey]; if([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)])&#123; return nil; &#125; return [self encryptData:originData withKeyRef:publicKeyRef];&#125;+ (NSString *)encryptString:(NSString *)originString publicKey:(NSString *)publicKey&#123; //åˆ¤æ–­publicKeyå‚æ•°æ˜¯å¦æ­£ç¡® if ((publicKey == nil) || (publicKey == NULL)) &#123; return nil; &#125; else if (![publicKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([publicKey length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­originStringå‚æ•°æ˜¯å¦æ­£ç¡® if ((originString == nil) || (originString == NULL)) &#123; return nil; &#125; else if (![originString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([originString length] &lt;= 0) &#123; return nil; &#125; //è·å–éœ€è¦åŠ å¯†çš„å­—ç¬¦ä¸²å†…å®¹ç¼–ç æ•°æ®æµ NSData *originData = nil, *encryptData = nil; SecKeyRef publicKeyRef = [self publicKeyRefWithPublicKey:publicKey]; originData = [originString dataUsingEncoding:NSUTF8StringEncoding]; if([[self class] isEmptyKeyRef:(__bridge id)(publicKeyRef)])&#123; return nil; &#125; if ((originData == nil) || (originData == NULL)) &#123; return nil; &#125; else if (![originData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([originData length] &lt;= 0) &#123; return nil; &#125; encryptData = [self encryptData:originData withKeyRef:publicKeyRef]; return [[self class] base64EncodedStringWithData:encryptData];&#125;+ (NSString *)decryptString:(NSString *)encryptString privateKey:(NSString *)privateKey&#123; //åˆ¤æ–­publicKeyå‚æ•°æ˜¯å¦æ­£ç¡® if ((privateKey == nil) || (privateKey == NULL)) &#123; return nil; &#125; else if (![privateKey isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([privateKey length] &lt;= 0) &#123; return nil; &#125; //åˆ¤æ–­originStringå‚æ•°æ˜¯å¦æ­£ç¡® if ((encryptString == nil) || (encryptString == NULL)) &#123; return nil; &#125; else if (![encryptString isKindOfClass:[NSString class]]) &#123; return nil; &#125; else if ([encryptString length] &lt;= 0) &#123; return nil; &#125; //è·å–ç§é’¥å¯¹è±¡å’Œéœ€è¦åŠ å¯†çš„å­—ç¬¦ä¸²å†…å®¹ç¼–ç æ•°æ®æµ SecKeyRef privateKeyRef; NSData *encryptData = nil, *decryptData = nil; privateKeyRef = [[self class] privateKeyRefWithPrivateKey:privateKey]; encryptData = [[self class] base64DecodeDataWithString:encryptString]; if ([[self class] isEmptyKeyRef:(__bridge id)(privateKeyRef)]) &#123; return nil; &#125; if ((encryptData == nil) || (encryptData == NULL)) &#123; return nil; &#125; else if (![encryptData isKindOfClass:[NSData class]]) &#123; return nil; &#125; else if ([encryptData length] &lt;= 0) &#123; return nil; &#125; NSStringEncoding encoding = NSUTF8StringEncoding; decryptData = [self decryptData:encryptData withKeyRef:privateKeyRef]; return [[NSString alloc] initWithData:decryptData encoding:encoding];&#125;/******************************************************************************/ åœ¨iOSä¸­RSAåŠ è§£å¯†ä½¿ç”¨æ–¹æ³•ä»‹ç»ï¼ˆRSAå¯†é’¥æ ¼å¼è¯·ä½¿ç”¨PKCS#8æ ¼å¼ï¼‰ 12345678910//ä½¿ç”¨RSAæ‰§è¡ŒåŠ å¯†æ“ä½œNSString *string4 = @\"abcdefghijklmnopqrstuvwxyz\";NSString *encodeString4 = [RSAEncrypt encryptString:string4 publicKey:mPublicKey];NSLog(@\"encodeString4 : %@\", encodeString4);//ä½¿ç”¨RSAæ‰§è¡Œè§£å¯†æ“ä½œNSString *decodeString4 = [RSAEncrypt decryptString:encodeString4 privateKey:mPrivateKey];NSLog(@\"decodeString4 : %@\", decodeString4);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"Encryption","slug":"Encryption","permalink":"https://nixzhang5.github.io/tags/Encryption/"}]},{"title":"AFNetWorkingåŸç†(äºŒ) AFSecurityPolicy","slug":"AFNetWorkingåŸç†äºŒ","date":"2019-06-25T03:31:07.000Z","updated":"2019-06-25T10:49:12.251Z","comments":true,"path":"AFNetWorkingåŸç†äºŒ.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorkingåŸç†äºŒ.html","excerpt":"AFNetWorking æ˜¯é ç€ AFSecurityPolicy è¿™ä¸ªç±»ä¿è¯æ•°æ®å®‰å…¨çš„ï¼ŒAFSecurityPolicy å…¶å®å°±æ˜¯éªŒè¯è¯ä¹¦æ˜¯å¦æ­£ç¡®çš„ã€‚","text":"AFNetWorking æ˜¯é ç€ AFSecurityPolicy è¿™ä¸ªç±»ä¿è¯æ•°æ®å®‰å…¨çš„ï¼ŒAFSecurityPolicy å…¶å®å°±æ˜¯éªŒè¯è¯ä¹¦æ˜¯å¦æ­£ç¡®çš„ã€‚ AFSecurityPolicy çš„æ ¡éªŒé€‰é¡¹ AFSSLPinningMode æœ‰ä¸‰ç§ï¼š AFSSLPinningModeNone åœ¨ä¸æœåŠ¡å™¨å»ºç«‹å®‰å…¨è¿æ¥æ—¶ï¼Œå¹¶ä¸ä¼šä½¿ç”¨åº”ç”¨ä¸­å·²æœ‰çš„è¯ä¹¦ï¼ˆä¹Ÿå¯èƒ½æœ¬å°±æ²¡æœ‰ï¼‰å¯¹æœåŠ¡å™¨ä¼ é€’çš„ä¿¡æ¯è¿›è¡Œæ ¡éªŒï¼Œæ­¤ä¸ºé»˜è®¤é€‰é¡¹ AFSSLPinningModePublicKey ä½¿ç”¨åº”ç”¨ä¸­å·²æœ‰çš„å…¬é’¥å¯¹æœåŠ¡å™¨ä¼ é€’çš„ä¿¡æ¯è¿›è¡Œæ ¡éªŒ AFSSLPinningModeCertificate ä½¿ç”¨åº”ç”¨ä¸­å·²æœ‰çš„æ•°å­—è¯ä¹¦å¯¹æœåŠ¡å™¨ä¼ é€’çš„ä¿¡æ¯è¿›è¡Œæ ¡éªŒ HTPPSHTTPSï¼ˆå…¨ç§°ï¼šHyper Text Transfer Protocol over Secure Socket Layerï¼‰ï¼Œæ˜¯ä»¥å®‰å…¨ä¸ºç›®æ ‡çš„HTTPé€šé“ï¼Œç®€å•è®²æ˜¯HTTPçš„å®‰å…¨ç‰ˆã€‚å³HTTPä¸‹åŠ å…¥SSLå±‚ï¼ŒHTTPSçš„å®‰å…¨åŸºç¡€æ˜¯SSLï¼Œå› æ­¤åŠ å¯†çš„è¯¦ç»†å†…å®¹å°±éœ€è¦SSLã€‚ å®ƒæ˜¯ä¸€ä¸ªURI schemeï¼ˆæŠ½è±¡æ ‡è¯†ç¬¦ä½“ç³»ï¼‰ï¼Œå¥æ³•ç±»åŒhttp:ä½“ç³»ã€‚ç”¨äºå®‰å…¨çš„HTTPæ•°æ®ä¼ è¾“ã€‚https:URLè¡¨æ˜å®ƒä½¿ç”¨äº†HTTPï¼Œä½†HTTPSå­˜åœ¨ä¸åŒäºHTTPçš„é»˜è®¤ç«¯å£åŠä¸€ä¸ªåŠ å¯†/èº«ä»½éªŒè¯å±‚ï¼ˆåœ¨HTTPä¸TCPä¹‹é—´ï¼‰ã€‚è¿™ä¸ªç³»ç»Ÿçš„æœ€åˆç ”å‘ç”±ç½‘æ™¯å…¬å¸(Netscape)è¿›è¡Œï¼Œå¹¶å†…ç½®äºå…¶æµè§ˆå™¨Netscape Navigatorä¸­ï¼Œæä¾›äº†èº«ä»½éªŒè¯ä¸åŠ å¯†é€šè®¯æ–¹æ³•ã€‚ HTTPSè¿æ¥å»ºç«‹ éå¯¹ç§°åŠ å¯†ã€å¯¹ç§°åŠ å¯†ï¼šå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯å»ºç«‹ä¸€ä¸ªè¿æ¥ï¼ŒæœåŠ¡ç«¯è¿”å›ä¸€ä¸ªè¯ä¹¦ï¼Œå®¢æˆ·ç«¯é‡Œå­˜æœ‰ï¼ˆå„ä¸ªå—ä¿¡ä»»çš„è¯ä¹¦æœºæ„ï¼‰æ ¹è¯ä¹¦ï¼Œç”¨è¿™äº›æ ¹è¯ä¹¦å¯¹æœåŠ¡ç«¯è¿”å›çš„è¯ä¹¦è¿›è¡ŒéªŒè¯ï¼Œç»éªŒè¯å¦‚æœè¯ä¹¦ï¼ˆæœåŠ¡ç«¯è¿”å›çš„è¯ä¹¦ï¼‰æ˜¯å¯ä¿¡ä»»çš„ï¼Œå°±ç”Ÿæˆä¸€ä¸ªpre-master secretï¼Œç”¨è¿™ä¸ªè¯ä¹¦ï¼ˆæœåŠ¡ç«¯è¿”å›çš„è¯ä¹¦ï¼‰çš„å…¬é’¥åŠ å¯†åå‘é€ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯ç”¨ç§é’¥è§£å¯†åå¾—åˆ°pre-master secretï¼Œå†æ ¹æ®æŸç§ç®—æ³•ç”Ÿæˆmaster secretï¼Œå®¢æˆ·ç«¯ä¹ŸåŒæ ·æ ¹æ®è¿™ç§ç®—æ³•ä»pre-master secretç”Ÿæˆmaster secretï¼ˆéå¯¹ç§°åŠ å¯†ï¼‰ï¼ŒéšååŒæ–¹çš„é€šä¿¡éƒ½ç”¨è¿™ä¸ªmaster secretå¯¹ä¼ è¾“æ•°æ®è¿›è¡ŒåŠ å¯†è§£å¯†ï¼ˆå¯¹ç§°åŠ å¯†ï¼‰ã€‚ éå¯¹ç§°åŠ å¯†ï¼š d(c(x))=x HTTPå’ŒHTTPSåŒºåˆ«è¶…æ–‡æœ¬ä¼ è¾“åè®®HTTPåè®®è¢«ç”¨äºåœ¨Webæµè§ˆå™¨å’Œç½‘ç«™æœåŠ¡å™¨ä¹‹é—´ä¼ é€’ä¿¡æ¯ã€‚HTTPåè®®ä»¥æ˜æ–‡æ–¹å¼å‘é€å†…å®¹ï¼Œä¸æä¾›ä»»ä½•æ–¹å¼çš„æ•°æ®åŠ å¯†ï¼Œå¦‚æœæ”»å‡»è€…æˆªå–äº†Webæµè§ˆå™¨å’Œç½‘ç«™æœåŠ¡å™¨ä¹‹é—´çš„ä¼ è¾“æŠ¥æ–‡ï¼Œå°±å¯ä»¥ç›´æ¥è¯»æ‡‚å…¶ä¸­çš„ä¿¡æ¯ï¼Œå› æ­¤HTTPåè®®ä¸é€‚åˆä¼ è¾“ä¸€äº›æ•æ„Ÿä¿¡æ¯ï¼Œæ¯”å¦‚ä¿¡ç”¨å¡å·ã€å¯†ç ç­‰ã€‚ä¸ºäº†è§£å†³HTTPåè®®çš„è¿™ä¸€ç¼ºé™·ï¼Œéœ€è¦ä½¿ç”¨å¦ä¸€ç§åè®®ï¼šå®‰å…¨å¥—æ¥å­—å±‚è¶…æ–‡æœ¬ä¼ è¾“åè®®HTTPSã€‚ä¸ºäº†æ•°æ®ä¼ è¾“çš„å®‰å…¨ï¼ŒHTTPSåœ¨HTTPçš„åŸºç¡€ä¸ŠåŠ å…¥äº†SSLåè®®ï¼ŒSSLä¾é è¯ä¹¦æ¥éªŒè¯æœåŠ¡å™¨çš„èº«ä»½ï¼Œå¹¶ä¸ºæµè§ˆå™¨å’ŒæœåŠ¡å™¨ä¹‹é—´çš„é€šä¿¡åŠ å¯†ã€‚ HTTPSå’ŒHTTPçš„åŒºåˆ«ä¸»è¦ä¸ºä»¥ä¸‹å››ç‚¹ï¼š httpsåè®®éœ€è¦åˆ°caç”³è¯·è¯ä¹¦ï¼Œä¸€èˆ¬å…è´¹è¯ä¹¦å¾ˆå°‘ï¼Œéœ€è¦äº¤è´¹ã€‚ httpæ˜¯è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼Œä¿¡æ¯æ˜¯æ˜æ–‡ä¼ è¾“ï¼Œhttps åˆ™æ˜¯å…·æœ‰å®‰å…¨æ€§çš„sslåŠ å¯†ä¼ è¾“åè®®ã€‚ httpå’Œhttpsä½¿ç”¨çš„æ˜¯å®Œå…¨ä¸åŒçš„è¿æ¥æ–¹å¼ï¼Œç”¨çš„ç«¯å£ä¹Ÿä¸ä¸€æ ·ï¼Œå‰è€…æ˜¯80ï¼Œåè€…æ˜¯443ã€‚ httpçš„è¿æ¥å¾ˆç®€å•ï¼Œæ˜¯æ— çŠ¶æ€çš„ï¼›HTTPSåè®®æ˜¯ç”±SSL+HTTPåè®®æ„å»ºçš„å¯è¿›è¡ŒåŠ å¯†ä¼ è¾“ã€èº«ä»½è®¤è¯çš„ç½‘ç»œåè®®ï¼Œæ¯”httpåè®®å®‰å…¨ã€‚ SSLSSL(Secure Sockets Layerå®‰å…¨å¥—æ¥å±‚),åŠå…¶ç»§ä»»è€…ä¼ è¾“å±‚å®‰å…¨(Transport Layer Securityï¼ŒTLS)æ˜¯ä¸ºç½‘ç»œé€šä¿¡æä¾›å®‰å…¨åŠæ•°æ®å®Œæ•´æ€§çš„ä¸€ç§å®‰å…¨åè®®ã€‚TLSä¸SSLåœ¨ä¼ è¾“å±‚å¯¹ç½‘ç»œè¿æ¥è¿›è¡ŒåŠ å¯†ã€‚ SSL (Secure Socket Layer)ä¸ºNetscapeæ‰€ç ”å‘ï¼Œç”¨ä»¥ä¿éšœåœ¨Internetä¸Šæ•°æ®ä¼ è¾“ä¹‹å®‰å…¨ï¼Œåˆ©ç”¨æ•°æ®åŠ å¯†(Encryption)æŠ€æœ¯ï¼Œå¯ç¡®ä¿æ•°æ®åœ¨ç½‘ç»œä¸Šä¹‹ä¼ è¾“è¿‡ç¨‹ä¸­ä¸ä¼šè¢«æˆªå–åŠçªƒå¬ã€‚ SSLåè®®ä½äºTCP/IPåè®®ä¸å„ç§åº”ç”¨å±‚åè®®ä¹‹é—´ï¼Œä¸ºæ•°æ®é€šè®¯æä¾›å®‰å…¨æ”¯æŒã€‚ SSLåè®®å¯åˆ†ä¸ºä¸¤å±‚ï¼š SSLè®°å½•åè®®ï¼ˆSSL Record Protocolï¼‰ï¼šå®ƒå»ºç«‹åœ¨å¯é çš„ä¼ è¾“åè®®ï¼ˆå¦‚TCPï¼‰ä¹‹ä¸Šï¼Œä¸ºé«˜å±‚åè®®æä¾›æ•°æ®å°è£…ã€å‹ç¼©ã€åŠ å¯†ç­‰åŸºæœ¬åŠŸèƒ½çš„æ”¯æŒã€‚ SSLæ¡æ‰‹åè®®ï¼ˆSSL Handshake Protocolï¼‰ï¼šå®ƒå»ºç«‹åœ¨SSLè®°å½•åè®®ä¹‹ä¸Šï¼Œç”¨äºåœ¨å®é™…çš„æ•°æ®ä¼ è¾“å¼€å§‹å‰ï¼Œé€šè®¯åŒæ–¹è¿›è¡Œèº«ä»½è®¤è¯ã€åå•†åŠ å¯†ç®—æ³•ã€äº¤æ¢åŠ å¯†å¯†é’¥ç­‰ã€‚ SSLåè®®æä¾›çš„æœåŠ¡ä¸»è¦æœ‰å“ªäº› è®¤è¯ç”¨æˆ·å’ŒæœåŠ¡å™¨ï¼Œç¡®ä¿æ•°æ®å‘é€åˆ°æ­£ç¡®çš„å®¢æˆ·æœºå’ŒæœåŠ¡å™¨ åŠ å¯†æ•°æ®ä»¥é˜²æ­¢æ•°æ®ä¸­é€”è¢«çªƒå– ç»´æŠ¤æ•°æ®çš„å®Œæ•´æ€§ï¼Œç¡®ä¿æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¸è¢«æ”¹å˜ã€‚ SSLåè®®çš„å·¥ä½œæµç¨‹ æœåŠ¡å™¨è®¤è¯é˜¶æ®µï¼šå®¢æˆ·ç«¯å‘æœåŠ¡å™¨å‘é€ä¸€ä¸ªå¼€å§‹ä¿¡æ¯â€œHelloâ€ä»¥ä¾¿å¼€å§‹ä¸€ä¸ªæ–°çš„ä¼šè¯è¿æ¥ï¼›æœåŠ¡å™¨æ ¹æ®å®¢æˆ·çš„ä¿¡æ¯ç¡®å®šæ˜¯å¦éœ€è¦ç”Ÿæˆæ–°çš„ä¸»å¯†é’¥ï¼Œå¦‚éœ€è¦åˆ™æœåŠ¡å™¨åœ¨å“åº”å®¢æˆ·çš„â€œHelloâ€ä¿¡æ¯æ—¶å°†åŒ…å«ç”Ÿæˆä¸»å¯†é’¥æ‰€éœ€çš„ä¿¡æ¯ï¼›å®¢æˆ·æ ¹æ®æ”¶åˆ°çš„æœåŠ¡å™¨å“åº”ä¿¡æ¯ï¼Œäº§ç”Ÿä¸€ä¸ªä¸»å¯†é’¥ï¼Œå¹¶ç”¨æœåŠ¡å™¨çš„å…¬å¼€å¯†é’¥åŠ å¯†åä¼ ç»™æœåŠ¡å™¨ï¼›æœåŠ¡å™¨æ¢å¤è¯¥ä¸»å¯†é’¥ï¼Œå¹¶è¿”å›ç»™å®¢æˆ·ä¸€ä¸ªç”¨ä¸»å¯†é’¥è®¤è¯çš„ä¿¡æ¯ï¼Œä»¥æ­¤è®©å®¢æˆ·è®¤è¯æœåŠ¡å™¨ã€‚ ç”¨æˆ·è®¤è¯é˜¶æ®µï¼šåœ¨æ­¤ä¹‹å‰ï¼ŒæœåŠ¡å™¨å·²ç»é€šè¿‡äº†å®¢æˆ·è®¤è¯ï¼Œè¿™ä¸€é˜¶æ®µä¸»è¦å®Œæˆå¯¹å®¢æˆ·çš„è®¤è¯ã€‚ç»è®¤è¯çš„æœåŠ¡å™¨å‘é€ä¸€ä¸ªæé—®ç»™å®¢æˆ·ï¼Œå®¢æˆ·åˆ™è¿”å›ï¼ˆæ•°å­—ï¼‰ç­¾ååçš„æé—®å’Œå…¶å…¬å¼€å¯†é’¥ï¼Œä»è€Œå‘æœåŠ¡å™¨æä¾›è®¤è¯ã€‚ ä»SSL åè®®æ‰€æä¾›çš„æœåŠ¡åŠå…¶å·¥ä½œæµç¨‹å¯ä»¥çœ‹å‡ºï¼ŒSSLåè®®è¿è¡Œçš„åŸºç¡€æ˜¯å•†å®¶å¯¹æ¶ˆè´¹è€…ä¿¡æ¯ä¿å¯†çš„æ‰¿è¯ºï¼Œè¿™å°±æœ‰åˆ©äºå•†å®¶è€Œä¸åˆ©äºæ¶ˆè´¹è€…ã€‚åœ¨ç”µå­å•†åŠ¡åˆçº§é˜¶æ®µï¼Œç”±äºè¿ä½œç”µå­å•†åŠ¡çš„ä¼ä¸šå¤§å¤šæ˜¯ä¿¡èª‰è¾ƒé«˜çš„å¤§å…¬å¸ï¼Œå› æ­¤è¿™é—®é¢˜è¿˜æ²¡æœ‰å……åˆ†æš´éœ²å‡ºæ¥ã€‚ä½†éšç€ç”µå­å•†åŠ¡çš„å‘å±•ï¼Œå„ä¸­å°å‹å…¬å¸ä¹Ÿå‚ä¸è¿›æ¥ï¼Œè¿™æ ·åœ¨ç”µå­æ”¯ä»˜è¿‡ç¨‹ä¸­çš„å•ä¸€è®¤è¯é—®é¢˜å°±è¶Šæ¥è¶Šçªå‡ºã€‚è™½ç„¶åœ¨SSL3.0ä¸­é€šè¿‡æ•°å­—ç­¾åå’Œæ•°å­—è¯ä¹¦å¯å®ç°æµè§ˆå™¨å’ŒWebæœåŠ¡å™¨åŒæ–¹çš„èº«ä»½éªŒè¯ï¼Œä½†æ˜¯SSLåè®®ä»å­˜åœ¨ä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚ï¼Œåªèƒ½æä¾›äº¤æ˜“ä¸­å®¢æˆ·ä¸æœåŠ¡å™¨é—´çš„åŒæ–¹è®¤è¯ï¼Œåœ¨æ¶‰åŠå¤šæ–¹çš„ç”µå­äº¤æ˜“ä¸­ï¼ŒSSLåè®®å¹¶ä¸èƒ½åè°ƒå„æ–¹é—´çš„å®‰å…¨ä¼ è¾“å’Œä¿¡ä»»å…³ç³»ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒVisaå’ŒMasterCardä¸¤å¤§ä¿¡ç”¨å¡å…¬ç»„ç»‡åˆ¶å®šäº†SETåè®®ï¼Œä¸ºç½‘ä¸Šä¿¡ç”¨å¡æ”¯ä»˜æä¾›äº†å…¨çƒæ€§çš„æ ‡å‡†ã€‚ SSLåè®®åŠ å¯†æ–¹å¼SSLåè®®å³ç”¨åˆ°äº†å¯¹ç§°åŠ å¯†ä¹Ÿç”¨åˆ°äº†éå¯¹ç§°åŠ å¯†(å…¬é’¥åŠ å¯†)ï¼Œåœ¨å»ºç«‹ä¼ è¾“é“¾è·¯æ—¶ï¼ŒSSLé¦–å…ˆå¯¹å¯¹ç§°åŠ å¯†çš„å¯†é’¥ä½¿ç”¨å…¬é’¥è¿›è¡Œéå¯¹ç§°åŠ å¯†ï¼Œé“¾è·¯å»ºç«‹å¥½ä¹‹åï¼ŒSSLå¯¹ä¼ è¾“å†…å®¹ä½¿ç”¨å¯¹ç§°åŠ å¯†ã€‚ å¯¹ç§°åŠ å¯†é€Ÿåº¦é«˜ï¼Œå¯åŠ å¯†å†…å®¹è¾ƒå¤§ï¼Œç”¨æ¥åŠ å¯†ä¼šè¯è¿‡ç¨‹ä¸­çš„æ¶ˆæ¯ å…¬é’¥åŠ å¯†åŠ å¯†é€Ÿåº¦è¾ƒæ…¢ï¼Œä½†èƒ½æä¾›æ›´å¥½çš„èº«ä»½è®¤è¯æŠ€æœ¯ï¼Œç”¨æ¥åŠ å¯†å¯¹ç§°åŠ å¯†çš„å¯†é’¥ SSLè¯ä¹¦åŒ…å«çš„ä¿¡æ¯ è¯ä¹¦ç‰ˆæœ¬å·ï¼Œä¸åŒç‰ˆæœ¬çš„è¯ä¹¦æ ¼å¼ä¸åŒ Serial Number åºåˆ—å·ï¼ŒåŒä¸€èº«ä»½éªŒè¯æœºæ„ç­¾å‘çš„è¯ä¹¦åºåˆ—å·å”¯ä¸€ Algorithm Identifier ç­¾åç®—æ³•ï¼ŒåŒ…æ‹¬å¿…è¦çš„å‚æ•°Issuer èº«ä»½éªŒè¯æœºæ„çš„æ ‡è¯†ä¿¡æ¯ Period of Validity æœ‰æ•ˆæœŸ Subject è¯ä¹¦æŒæœ‰äººçš„æ ‡è¯†ä¿¡æ¯ Subjectâ€™s Public Key è¯ä¹¦æŒæœ‰äººçš„å…¬é’¥ Signature èº«ä»½éªŒè¯æœºæ„å¯¹è¯ä¹¦çš„ç­¾å è¯ä¹¦çš„æ ¼å¼ è®¤è¯ä¸­å¿ƒæ‰€å‘æ”¾çš„è¯ä¹¦å‡éµå¾ªX.509 V3 æ ‡å‡†ï¼Œå…¶åŸºæœ¬æ ¼å¼å¦‚ä¸‹ï¼š è¯ä¹¦ç‰ˆæœ¬å·ï¼ˆCertificate Format Versionï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šè¯ä¹¦æ ¼å¼é‡‡ç”¨çš„X.509 ç‰ˆæœ¬å·ã€‚ è¯ä¹¦åºåˆ—å·ï¼ˆCertificate Serial Numberï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šè¯ä¹¦çš„å”¯ä¸€åºåˆ—å·ï¼Œä»¥æ ‡è¯†CA å‘å‡ºçš„æ‰€æœ‰å…¬é’¥è¯ä¹¦ã€‚ ç­¾åï¼ˆSignatureï¼‰ç®—æ³•æ ‡è¯†ï¼ˆAlgorithm Identifierï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®š CA ç­¾å‘è¯ä¹¦æ‰€ç”¨çš„ç­¾åç®—æ³•ã€‚ ç­¾å‘æ­¤è¯ä¹¦çš„ CA åç§°ï¼ˆIssuer ï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šç­¾å‘è¯ä¹¦çš„ CA çš„X.500 å”¯ä¸€åç§°ï¼ˆDNï¼ŒDistinguished Nameï¼‰ã€‚ è¯ä¹¦æœ‰æ•ˆæœŸï¼ˆValidity Periodï¼‰èµ·å§‹æ—¥æœŸï¼ˆnotBeforeï¼‰ ç»ˆæ­¢æ—¥æœŸï¼ˆnotAfterï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šè¯ä¹¦èµ·å§‹æ—¥æœŸå’Œç»ˆæ­¢æ—¥æœŸã€‚ ç”¨æˆ·åç§°ï¼ˆSubjectï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šè¯ä¹¦ç”¨æˆ·çš„X.500 å”¯ä¸€åç§°ï¼ˆDNï¼ŒDistinguished Nameï¼‰ã€‚ ç”¨æˆ·å…¬é’¥ä¿¡æ¯ï¼ˆSubject Public Key Informationï¼‰ç®—æ³•ï¼ˆalgorithmï¼‰ ç®—æ³•æ ‡è¯†ï¼ˆAlgorithm Identifierï¼‰ç”¨æˆ·å…¬é’¥ï¼ˆsubject Public Keyï¼‰å«ä¹‰ï¼šç”¨æ¥æ ‡è¯†å…¬é’¥ä½¿ç”¨çš„ç®—æ³•ï¼Œå¹¶åŒ…å«å…¬é’¥æœ¬èº«ã€‚ è¯ä¹¦æ‰©å……éƒ¨åˆ†ï¼ˆæ‰©å±•åŸŸï¼‰ï¼ˆExtensionsï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šé¢å¤–ä¿¡æ¯ã€‚ X.509 V3 è¯ä¹¦çš„æ‰©å……éƒ¨åˆ†ï¼ˆæ‰©å±•åŸŸï¼‰åŠå®ç°æ–¹æ³•å¦‚ä¸‹ï¼š CA çš„å…¬é’¥æ ‡è¯†ï¼ˆAuthority Key Identifierï¼‰ å…¬é’¥æ ‡è¯†ï¼ˆSET æœªä½¿ç”¨ï¼‰ï¼ˆKey Identifierï¼‰ ç­¾å‘è¯ä¹¦è€…è¯ä¹¦çš„ç­¾å‘è€…çš„ç”„åˆ«åï¼ˆCertificate Issuerï¼‰ ç­¾å‘è¯ä¹¦è€…è¯ä¹¦çš„åºåˆ—å·ï¼ˆCertificate Serial Numberï¼‰ X.509 V3 è¯ä¹¦çš„æ‰©å……éƒ¨åˆ†ï¼ˆæ‰©å±•åŸŸï¼‰åŠå®ç°CA çš„å…¬é’¥æ ‡è¯†ï¼ˆAuthority Key Identifierï¼‰ å…¬é’¥æ ‡è¯†ï¼ˆSET æœªä½¿ç”¨ï¼‰ï¼ˆKey Identifierï¼‰ ç­¾å‘è¯ä¹¦è€…è¯ä¹¦çš„ç­¾å‘è€…çš„ç”„åˆ«åï¼ˆCertificatç­¾å‘è¯ä¹¦è€…è¯ä¹¦çš„åºåˆ—å·ï¼ˆCertificate Serial Numberï¼‰å«ä¹‰ï¼šCA ç­¾åè¯ä¹¦æ‰€ç”¨çš„å¯†é’¥å¯¹çš„å”¯ä¸€æ ‡è¯†ç”¨æˆ·çš„å…¬é’¥æ ‡è¯†ï¼ˆSubject Key Identifierï¼‰å«ä¹‰ï¼šç”¨æ¥æ ‡è¯†ä¸è¯ä¹¦ä¸­å…¬é’¥ç›¸å…³çš„ç‰¹å®šå¯†é’¥è¿›è¡Œè§£å¯†ã€‚ è¯ä¹¦ä¸­çš„å…¬é’¥ç”¨é€”ï¼ˆKey Usageï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šå…¬é’¥ç”¨é€”ã€‚ ç”¨æˆ·çš„ç§é’¥æœ‰æ•ˆæœŸï¼ˆPrivate Key Usage Periodï¼‰èµ·å§‹æ—¥æœŸï¼ˆNote Beforeï¼‰ ç»ˆæ­¢æ—¥æœŸï¼ˆNote Afterï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šç”¨æˆ·ç­¾åç§é’¥çš„èµ·å§‹æ—¥æœŸå’Œç»ˆæ­¢æ—¥æœŸã€‚ CA æ‰¿è®¤çš„è¯ä¹¦æ”¿ç­–åˆ—è¡¨ï¼ˆCertificate Policiesï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šç”¨æˆ·è¯ä¹¦æ‰€é€‚ç”¨çš„æ”¿ç­–ï¼Œè¯ä¹¦æ”¿ç­–å¯ç”±å¯¹è±¡æ ‡è¯†ç¬¦è¡¨ç¤ºã€‚ ç”¨æˆ·çš„ä»£ç”¨åï¼ˆSubstitutional Nameï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®šç”¨æˆ·çš„ä»£ç”¨åã€‚ CA çš„ä»£ç”¨åï¼ˆIssuer Alt Nameï¼‰å«ä¹‰ï¼šç”¨æ¥æŒ‡å®š CA çš„ä»£ç”¨åã€‚ åŸºæœ¬åˆ¶çº¦ï¼ˆBasic Constraintsï¼‰å«ä¹‰ï¼šç”¨æ¥è¡¨æ˜è¯ä¹¦ç”¨æˆ·æ˜¯æœ€ç»ˆç”¨æˆ·è¿˜æ˜¯CAã€‚ åœ¨SET ç³»ç»Ÿä¸­æœ‰ä¸€äº›ç§æœ‰æ‰©å……éƒ¨åˆ†ï¼ˆæ‰©å±•åŸŸï¼‰Hashed Root Key å«ä¹‰ï¼šåªåœ¨æ ¹è¯ä¹¦ä¸­ä½¿ç”¨ï¼Œç”¨äºè¯ä¹¦æ›´æ–°æ—¶è¿›è¡Œå›æº¯ã€‚ è¯ä¹¦ç±»å‹ï¼ˆCertificate Typeï¼‰å«ä¹‰ï¼šç”¨æ¥åŒºåˆ«ä¸åŒçš„å®ä½“ã€‚è¯¥é¡¹æ˜¯å¿…é€‰çš„ã€‚ å•†æˆ·æ•°æ®ï¼ˆMerchant Dataï¼‰å«ä¹‰ï¼šåŒ…å«æ”¯ä»˜ç½‘å…³éœ€è¦çš„æ‰€æœ‰å•†æˆ·ä¿¡æ¯ã€‚ æŒå¡äººè¯ä¹¦éœ€æ±‚ï¼ˆCard Cert Requiredï¼‰å«ä¹‰ï¼šæ˜¾ç¤ºæ”¯ä»˜ç½‘å…³æ˜¯å¦æ”¯æŒä¸æ²¡æœ‰è¯ä¹¦çš„æŒå¡äººè¿›è¡Œäº¤æ˜“ã€‚ SET æ‰©å±•ï¼ˆSETExtensionsï¼‰å«ä¹‰ï¼šåˆ—å‡ºæ”¯ä»˜ç½‘å…³æ”¯æŒçš„æ”¯ä»˜å‘½ä»¤çš„ SET ä¿¡æ¯æ‰©å±•ã€‚ CRL æ•°æ®å®šä¹‰ç‰ˆæœ¬ï¼ˆVersionï¼‰å«ä¹‰ï¼šæ˜¾ç¤º CRL çš„ç‰ˆæœ¬å·ã€‚ CRL çš„ç­¾å‘è€…ï¼ˆIssuerï¼‰å«ä¹‰ï¼šæŒ‡æ˜ç­¾å‘ CRL çš„CA çš„ç”„åˆ«åã€‚ CRL å‘å¸ƒæ—¶é—´ï¼ˆthis Updateï¼‰é¢„è®¡ä¸‹ä¸€ä¸ª CRL æ›´æ–°æ—¶é—´ï¼ˆNext Updateï¼‰æ’¤é”€è¯ä¹¦ä¿¡æ¯ç›®å½•ï¼ˆRevoked Certificatesï¼‰CRL æ‰©å±•ï¼ˆCRL Extensionï¼‰CA çš„å…¬é’¥æ ‡è¯†ï¼ˆAuthority Key Identifierï¼‰CRL å·ï¼ˆCRL Numberï¼‰ SSLè¯ä¹¦ç§ç±»ï¼šCFCAï¼ŒGlobalSignï¼ŒVeriSign ï¼ŒGeotrust ï¼ŒThawteã€‚ åŸŸåå‹ https è¯ä¹¦ï¼ˆDVSSLï¼‰ï¼šä¿¡ä»»ç­‰çº§ä¸€èˆ¬ï¼Œåªéœ€éªŒè¯ç½‘ç«™çš„çœŸå®æ€§ä¾¿å¯é¢å‘è¯ä¹¦ä¿æŠ¤ç½‘ç«™ï¼› ä¼ä¸šå‹ https è¯ä¹¦ï¼ˆOVSSLï¼‰ï¼šä¿¡ä»»ç­‰çº§å¼ºï¼Œé¡»è¦éªŒè¯ä¼ä¸šçš„èº«ä»½ï¼Œå®¡æ ¸ä¸¥æ ¼ï¼Œå®‰å…¨æ€§æ›´é«˜ï¼› å¢å¼ºå‹ https è¯ä¹¦ï¼ˆEVSSLï¼‰ï¼šä¿¡ä»»ç­‰çº§æœ€é«˜ï¼Œä¸€èˆ¬ç”¨äºé“¶è¡Œè¯åˆ¸ç­‰é‡‘èæœºæ„ï¼Œå®¡æ ¸ä¸¥æ ¼ï¼Œå®‰å…¨æ€§æœ€é«˜ï¼ŒåŒæ—¶å¯ä»¥æ¿€æ´»ç»¿è‰²ç½‘å€æ ã€‚ æ¡æ‰‹è¿‡ç¨‹ä¸ºäº†ä¾¿äºæ›´å¥½çš„è®¤è¯†å’Œç†è§£SSL åè®®ï¼Œè¿™é‡Œç€é‡ä»‹ç»SSL åè®®çš„æ¡æ‰‹åè®®ã€‚SSL åè®®æ—¢ç”¨åˆ°äº†å…¬é’¥åŠ å¯†æŠ€æœ¯åˆç”¨åˆ°äº†å¯¹ç§°åŠ å¯†æŠ€æœ¯ï¼Œå¯¹ç§°åŠ å¯†æŠ€æœ¯è™½ç„¶æ¯”å…¬é’¥åŠ å¯†æŠ€æœ¯çš„é€Ÿåº¦å¿«ï¼Œå¯æ˜¯å…¬é’¥åŠ å¯†æŠ€æœ¯æä¾›äº†æ›´å¥½çš„èº«ä»½è®¤è¯æŠ€æœ¯ã€‚SSL çš„æ¡æ‰‹åè®®éå¸¸æœ‰æ•ˆçš„è®©å®¢æˆ·å’ŒæœåŠ¡å™¨ä¹‹é—´å®Œæˆç›¸äº’ä¹‹é—´çš„èº«ä»½è®¤è¯ï¼Œå…¶ä¸»è¦è¿‡ç¨‹å¦‚ä¸‹ï¼š å®¢æˆ·ç«¯çš„æµè§ˆå™¨å‘æœåŠ¡å™¨ä¼ é€å®¢æˆ·ç«¯SSL åè®®çš„ç‰ˆæœ¬å·ï¼ŒåŠ å¯†ç®—æ³•çš„ç§ç±»ï¼Œäº§ç”Ÿçš„éšæœºæ•°ï¼Œä»¥åŠå…¶ä»–æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¹‹é—´é€šè®¯æ‰€éœ€è¦çš„å„ç§ä¿¡æ¯ã€‚ æœåŠ¡å™¨å‘å®¢æˆ·ç«¯ä¼ é€SSL åè®®çš„ç‰ˆæœ¬å·ï¼ŒåŠ å¯†ç®—æ³•çš„ç§ç±»ï¼Œéšæœºæ•°ä»¥åŠå…¶ä»–ç›¸å…³ä¿¡æ¯ï¼ŒåŒæ—¶æœåŠ¡å™¨è¿˜å°†å‘å®¢æˆ·ç«¯ä¼ é€è‡ªå·±çš„è¯ä¹¦ã€‚ å®¢æˆ·åˆ©ç”¨æœåŠ¡å™¨ä¼ è¿‡æ¥çš„ä¿¡æ¯éªŒè¯æœåŠ¡å™¨çš„åˆæ³•æ€§ï¼ŒæœåŠ¡å™¨çš„åˆæ³•æ€§åŒ…æ‹¬ï¼šè¯ä¹¦æ˜¯å¦è¿‡æœŸï¼Œå‘è¡ŒæœåŠ¡å™¨è¯ä¹¦çš„CA æ˜¯å¦å¯é ï¼Œå‘è¡Œè€…è¯ä¹¦çš„å…¬é’¥èƒ½å¦æ­£ç¡®è§£å¼€æœåŠ¡å™¨è¯ä¹¦çš„â€œå‘è¡Œè€…çš„æ•°å­—ç­¾åâ€ï¼ŒæœåŠ¡å™¨è¯ä¹¦ä¸Šçš„åŸŸåæ˜¯å¦å’ŒæœåŠ¡å™¨çš„å®é™…åŸŸåç›¸åŒ¹é…ã€‚å¦‚æœåˆæ³•æ€§éªŒè¯æ²¡æœ‰é€šè¿‡ï¼Œé€šè®¯å°†æ–­å¼€ï¼›å¦‚æœåˆæ³•æ€§éªŒè¯é€šè¿‡ï¼Œå°†ç»§ç»­è¿›è¡Œç¬¬å››æ­¥ã€‚ ç”¨æˆ·ç«¯éšæœºäº§ç”Ÿä¸€ä¸ªç”¨äºåé¢é€šè®¯çš„â€œå¯¹ç§°å¯†ç â€ï¼Œç„¶åç”¨æœåŠ¡å™¨çš„å…¬é’¥ï¼ˆæœåŠ¡å™¨çš„å…¬é’¥ä»æ­¥éª¤â‘¡ä¸­çš„æœåŠ¡å™¨çš„è¯ä¹¦ä¸­è·å¾—ï¼‰å¯¹å…¶åŠ å¯†ï¼Œç„¶åå°†åŠ å¯†åçš„â€œé¢„ä¸»å¯†ç â€ä¼ ç»™æœåŠ¡å™¨ã€‚ å¦‚æœæœåŠ¡å™¨è¦æ±‚å®¢æˆ·çš„èº«ä»½è®¤è¯ï¼ˆåœ¨æ¡æ‰‹è¿‡ç¨‹ä¸­ä¸ºå¯é€‰ï¼‰ï¼Œç”¨æˆ·å¯ä»¥å»ºç«‹ä¸€ä¸ªéšæœºæ•°ç„¶åå¯¹å…¶è¿›è¡Œæ•°æ®ç­¾åï¼Œå°†è¿™ä¸ªå«æœ‰ç­¾åçš„éšæœºæ•°å’Œå®¢æˆ·è‡ªå·±çš„è¯ä¹¦ä»¥åŠåŠ å¯†è¿‡çš„â€œé¢„ä¸»å¯†ç â€ä¸€èµ·ä¼ ç»™æœåŠ¡å™¨ã€‚ å¦‚æœæœåŠ¡å™¨è¦æ±‚å®¢æˆ·çš„èº«ä»½è®¤è¯ï¼ŒæœåŠ¡å™¨å¿…é¡»æ£€éªŒå®¢æˆ·è¯ä¹¦å’Œç­¾åéšæœºæ•°çš„åˆæ³•æ€§ï¼Œå…·ä½“çš„åˆæ³•æ€§éªŒè¯è¿‡ç¨‹åŒ…æ‹¬ï¼šå®¢æˆ·çš„è¯ä¹¦ä½¿ç”¨æ—¥æœŸæ˜¯å¦æœ‰æ•ˆï¼Œä¸ºå®¢æˆ·æä¾›è¯ä¹¦çš„CA æ˜¯å¦å¯é ï¼Œå‘è¡ŒCA çš„å…¬é’¥èƒ½å¦æ­£ç¡®è§£å¼€å®¢æˆ·è¯ä¹¦çš„å‘è¡ŒCA çš„æ•°å­—ç­¾åï¼Œæ£€æŸ¥å®¢æˆ·çš„è¯ä¹¦æ˜¯å¦åœ¨è¯ä¹¦åºŸæ­¢åˆ—è¡¨ï¼ˆCRLï¼‰ä¸­ã€‚æ£€éªŒå¦‚æœæ²¡æœ‰é€šè¿‡ï¼Œé€šè®¯ç«‹åˆ»ä¸­æ–­ï¼›å¦‚æœéªŒè¯é€šè¿‡ï¼ŒæœåŠ¡å™¨å°†ç”¨è‡ªå·±çš„ç§é’¥è§£å¼€åŠ å¯†çš„â€œé¢„ä¸»å¯†ç â€ï¼Œç„¶åæ‰§è¡Œä¸€ç³»åˆ—æ­¥éª¤æ¥äº§ç”Ÿä¸»é€šè®¯å¯†ç ï¼ˆå®¢æˆ·ç«¯ä¹Ÿå°†é€šè¿‡åŒæ ·çš„æ–¹æ³•äº§ç”Ÿç›¸åŒçš„ä¸»é€šè®¯å¯†ç ï¼‰ã€‚ æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ç”¨ç›¸åŒçš„ä¸»å¯†ç å³â€œé€šè¯å¯†ç â€ï¼Œä¸€ä¸ªå¯¹ç§°å¯†é’¥ç”¨äºSSL åè®®çš„å®‰å…¨æ•°æ®é€šè®¯çš„åŠ è§£å¯†é€šè®¯ã€‚åŒæ—¶åœ¨SSL é€šè®¯è¿‡ç¨‹ä¸­è¿˜è¦å®Œæˆæ•°æ®é€šè®¯çš„å®Œæ•´æ€§ï¼Œé˜²æ­¢æ•°æ®é€šè®¯ä¸­çš„ä»»ä½•å˜åŒ–ã€‚ å®¢æˆ·ç«¯å‘æœåŠ¡å™¨ç«¯å‘å‡ºä¿¡æ¯ï¼ŒæŒ‡æ˜åé¢çš„æ•°æ®é€šè®¯å°†ä½¿ç”¨çš„æ­¥éª¤â‘¦ä¸­çš„ä¸»å¯†ç ä¸ºå¯¹ç§°å¯†é’¥ï¼ŒåŒæ—¶é€šçŸ¥æœåŠ¡å™¨å®¢æˆ·ç«¯çš„æ¡æ‰‹è¿‡ç¨‹ç»“æŸã€‚ æœåŠ¡å™¨å‘å®¢æˆ·ç«¯å‘å‡ºä¿¡æ¯ï¼ŒæŒ‡æ˜åé¢çš„æ•°æ®é€šè®¯å°†ä½¿ç”¨çš„æ­¥éª¤â‘¦ä¸­çš„ä¸»å¯†ç ä¸ºå¯¹ç§°å¯†é’¥ï¼ŒåŒæ—¶é€šçŸ¥å®¢æˆ·ç«¯æœåŠ¡å™¨ç«¯çš„æ¡æ‰‹è¿‡ç¨‹ç»“æŸã€‚ SSL çš„æ¡æ‰‹éƒ¨åˆ†ç»“æŸï¼ŒSSL å®‰å…¨é€šé“çš„æ•°æ®é€šè®¯å¼€å§‹ï¼Œå®¢æˆ·å’ŒæœåŠ¡å™¨å¼€å§‹ä½¿ç”¨ç›¸åŒçš„å¯¹ç§°å¯†é’¥è¿›è¡Œæ•°æ®é€šè®¯ï¼ŒåŒæ—¶è¿›è¡Œé€šè®¯å®Œæ•´æ€§çš„æ£€éªŒã€‚ HTTPSçš„è®¤è¯è¿‡ç¨‹å•å‘è®¤è¯Httpsåœ¨å»ºç«‹Socketè¿æ¥ä¹‹å‰ï¼Œéœ€è¦è¿›è¡Œæ¡æ‰‹ï¼Œå…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š å®¢æˆ·ç«¯å‘æœåŠ¡ç«¯å‘é€SSLåè®®ç‰ˆæœ¬å·ã€åŠ å¯†ç®—æ³•ç§ç±»ã€éšæœºæ•°ç­‰ä¿¡æ¯ã€‚ æœåŠ¡ç«¯ç»™å®¢æˆ·ç«¯è¿”å›SSLåè®®ç‰ˆæœ¬å·ã€åŠ å¯†ç®—æ³•ç§ç±»ã€éšæœºæ•°ç­‰ä¿¡æ¯ï¼ŒåŒæ—¶ä¹Ÿè¿”å›æœåŠ¡å™¨ç«¯çš„è¯ä¹¦ï¼Œå³å…¬é’¥è¯ä¹¦ å®¢æˆ·ç«¯ä½¿ç”¨æœåŠ¡ç«¯è¿”å›çš„ä¿¡æ¯éªŒè¯æœåŠ¡å™¨çš„åˆæ³•æ€§ï¼ŒåŒ…æ‹¬ï¼š è¯ä¹¦æ˜¯å¦è¿‡æœŸ å‘å‹æœåŠ¡å™¨è¯ä¹¦çš„CAæ˜¯å¦å¯é  è¿”å›çš„å…¬é’¥æ˜¯å¦èƒ½æ­£ç¡®è§£å¼€è¿”å›è¯ä¹¦ä¸­çš„æ•°å­—ç­¾å æœåŠ¡å™¨è¯ä¹¦ä¸Šçš„åŸŸåæ˜¯å¦å’ŒæœåŠ¡å™¨çš„å®é™…åŸŸåç›¸åŒ¹é… éªŒè¯é€šè¿‡åï¼Œå°†ç»§ç»­è¿›è¡Œé€šä¿¡ï¼Œå¦åˆ™ï¼Œç»ˆæ­¢é€šä¿¡ å®¢æˆ·ç«¯å‘æœåŠ¡ç«¯å‘é€è‡ªå·±æ‰€èƒ½æ”¯æŒçš„å¯¹ç§°åŠ å¯†æ–¹æ¡ˆï¼Œä¾›æœåŠ¡å™¨ç«¯è¿›è¡Œé€‰æ‹© æœåŠ¡å™¨ç«¯åœ¨å®¢æˆ·ç«¯æä¾›çš„åŠ å¯†æ–¹æ¡ˆä¸­é€‰æ‹©åŠ å¯†ç¨‹åº¦æœ€é«˜çš„åŠ å¯†æ–¹å¼ã€‚ æœåŠ¡å™¨å°†é€‰æ‹©å¥½çš„åŠ å¯†æ–¹æ¡ˆé€šè¿‡æ˜æ–‡æ–¹å¼è¿”å›ç»™å®¢æˆ·ç«¯ å®¢æˆ·ç«¯æ¥æ”¶åˆ°æœåŠ¡ç«¯è¿”å›çš„åŠ å¯†æ–¹å¼åï¼Œä½¿ç”¨è¯¥åŠ å¯†æ–¹å¼ç”Ÿæˆäº§ç”Ÿéšæœºç ï¼Œç”¨ä½œé€šä¿¡è¿‡ç¨‹ä¸­å¯¹ç§°åŠ å¯†çš„å¯†é’¥ï¼Œä½¿ç”¨æœåŠ¡ç«¯è¿”å›çš„å…¬é’¥è¿›è¡ŒåŠ å¯†ï¼Œå°†åŠ å¯†åçš„éšæœºç å‘é€è‡³æœåŠ¡å™¨ æœåŠ¡å™¨æ”¶åˆ°å®¢æˆ·ç«¯è¿”å›çš„åŠ å¯†ä¿¡æ¯åï¼Œä½¿ç”¨è‡ªå·±çš„ç§é’¥è¿›è¡Œè§£å¯†ï¼Œè·å–å¯¹ç§°åŠ å¯†å¯†é’¥ã€‚åœ¨æ¥ä¸‹æ¥çš„ä¼šè¯ä¸­ï¼ŒæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯å°†ä¼šä½¿ç”¨è¯¥å¯†ç è¿›è¡Œå¯¹ç§°åŠ å¯†ï¼Œä¿è¯é€šä¿¡è¿‡ç¨‹ä¸­ä¿¡æ¯çš„å®‰å…¨ã€‚ åŒå‘è®¤è¯åŒå‘è®¤è¯å’Œå•å‘è®¤è¯åŸç†åŸºæœ¬å·®ä¸å¤šï¼Œåªæ˜¯é™¤äº†å®¢æˆ·ç«¯éœ€è¦è®¤è¯æœåŠ¡ç«¯ä»¥å¤–ï¼Œå¢åŠ äº†æœåŠ¡ç«¯å¯¹å®¢æˆ·ç«¯çš„è®¤è¯ï¼Œå…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š å®¢æˆ·ç«¯å‘æœåŠ¡ç«¯å‘é€SSLåè®®ç‰ˆæœ¬å·ã€åŠ å¯†ç®—æ³•ç§ç±»ã€éšæœºæ•°ç­‰ä¿¡æ¯ã€‚ æœåŠ¡ç«¯ç»™å®¢æˆ·ç«¯è¿”å›SSLåè®®ç‰ˆæœ¬å·ã€åŠ å¯†ç®—æ³•ç§ç±»ã€éšæœºæ•°ç­‰ä¿¡æ¯ï¼ŒåŒæ—¶ä¹Ÿè¿”å›æœåŠ¡å™¨ç«¯çš„è¯ä¹¦ï¼Œå³å…¬é’¥è¯ä¹¦ å®¢æˆ·ç«¯ä½¿ç”¨æœåŠ¡ç«¯è¿”å›çš„ä¿¡æ¯éªŒè¯æœåŠ¡å™¨çš„åˆæ³•æ€§ï¼ŒåŒ…æ‹¬ï¼š è¯ä¹¦æ˜¯å¦è¿‡æœŸ å‘å‹æœåŠ¡å™¨è¯ä¹¦çš„CAæ˜¯å¦å¯é  è¿”å›çš„å…¬é’¥æ˜¯å¦èƒ½æ­£ç¡®è§£å¼€è¿”å›è¯ä¹¦ä¸­çš„æ•°å­—ç­¾å æœåŠ¡å™¨è¯ä¹¦ä¸Šçš„åŸŸåæ˜¯å¦å’ŒæœåŠ¡å™¨çš„å®é™…åŸŸåç›¸åŒ¹é… éªŒè¯é€šè¿‡åï¼Œå°†ç»§ç»­è¿›è¡Œé€šä¿¡ï¼Œå¦åˆ™ï¼Œç»ˆæ­¢é€šä¿¡ æœåŠ¡ç«¯è¦æ±‚å®¢æˆ·ç«¯å‘é€å®¢æˆ·ç«¯çš„è¯ä¹¦ï¼Œå®¢æˆ·ç«¯ä¼šå°†è‡ªå·±çš„è¯ä¹¦å‘é€è‡³æœåŠ¡ç«¯ éªŒè¯å®¢æˆ·ç«¯çš„è¯ä¹¦ï¼Œé€šè¿‡éªŒè¯åï¼Œä¼šè·å¾—å®¢æˆ·ç«¯çš„å…¬é’¥ å®¢æˆ·ç«¯å‘æœåŠ¡ç«¯å‘é€è‡ªå·±æ‰€èƒ½æ”¯æŒçš„å¯¹ç§°åŠ å¯†æ–¹æ¡ˆï¼Œä¾›æœåŠ¡å™¨ç«¯è¿›è¡Œé€‰æ‹© æœåŠ¡å™¨ç«¯åœ¨å®¢æˆ·ç«¯æä¾›çš„åŠ å¯†æ–¹æ¡ˆä¸­é€‰æ‹©åŠ å¯†ç¨‹åº¦æœ€é«˜çš„åŠ å¯†æ–¹å¼ å°†åŠ å¯†æ–¹æ¡ˆé€šè¿‡ä½¿ç”¨ä¹‹å‰è·å–åˆ°çš„å…¬é’¥è¿›è¡ŒåŠ å¯†ï¼Œè¿”å›ç»™å®¢æˆ·ç«¯ å®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡ç«¯è¿”å›çš„åŠ å¯†æ–¹æ¡ˆå¯†æ–‡åï¼Œä½¿ç”¨è‡ªå·±çš„ç§é’¥è¿›è¡Œè§£å¯†ï¼Œè·å–å…·ä½“åŠ å¯†æ–¹å¼ï¼Œè€Œåï¼Œäº§ç”Ÿè¯¥åŠ å¯†æ–¹å¼çš„éšæœºç ï¼Œç”¨ä½œåŠ å¯†è¿‡ç¨‹ä¸­çš„å¯†é’¥ï¼Œä½¿ç”¨ä¹‹å‰ä»æœåŠ¡ç«¯è¯ä¹¦ä¸­è·å–åˆ°çš„å…¬é’¥è¿›è¡ŒåŠ å¯†åï¼Œå‘é€ç»™æœåŠ¡ç«¯ æœåŠ¡ç«¯æ”¶åˆ°å®¢æˆ·ç«¯å‘é€çš„æ¶ˆæ¯åï¼Œä½¿ç”¨è‡ªå·±çš„ç§é’¥è¿›è¡Œè§£å¯†ï¼Œè·å–å¯¹ç§°åŠ å¯†çš„å¯†é’¥ï¼Œåœ¨æ¥ä¸‹æ¥çš„ä¼šè¯ä¸­ï¼ŒæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯å°†ä¼šä½¿ç”¨è¯¥å¯†ç è¿›è¡Œå¯¹ç§°åŠ å¯†ï¼Œä¿è¯é€šä¿¡è¿‡ç¨‹ä¸­ä¿¡æ¯çš„å®‰å…¨ã€‚ AFSecurityPolicyå’Œè®¤è¯è®¤è¯è¿‡ç¨‹å’ŒåŸç†AFNæ˜¯é ç€AFSecurityPolicyè¿™ä¸ªç±»ä¿è¯æ•°æ®å®‰å…¨çš„ï¼Œè°ƒç”¨ä¸‹é¢æ–¹æ³•ç”¨æ¥éªŒè¯æ˜¯å¦ä¿¡ä»»æœåŠ¡å™¨ã€‚ 1[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host] çœ‹ä¸€ä¸‹AFNä¸­çš„æ¥å£ 123456789101112131415161718192021/*! @typedef SecTrustRef @abstract CFType used for performing X.509 certificate trust evaluations. // æ‰§è¡ŒX.509è¯ä¹¦ä¿¡ä»»è¯„ä¼°ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œè£…äº†æœåŠ¡å™¨ç«¯éœ€è¦éªŒè¯çš„è¯ä¹¦çš„åŸºæœ¬ä¿¡æ¯ã€ å…¬é’¥ç­‰ç­‰ï¼Œä¸ä»…å¦‚æ­¤ï¼Œå®ƒè¿˜å¯ä»¥è£…ä¸€äº›è¯„ä¼°ç­–ç•¥ï¼Œè¿˜æœ‰å®¢æˆ·ç«¯çš„é”šç‚¹è¯ä¹¦ï¼Œ è¿™ä¸ªå®¢æˆ·ç«¯çš„è¯ä¹¦ï¼Œå¯ä»¥ç”¨æ¥å’ŒæœåŠ¡ç«¯çš„è¯ä¹¦å»åŒ¹é…éªŒè¯çš„ */typedef struct CF_BRIDGED_TYPE(id) __SecTrust *SecTrustRef;/** Whether or not the specified server trust should be accepted, based on the security policy. This method should be used when responding to an authentication challenge from a server. @param serverTrust The X.509 certificate trust of the server. @param domain The domain of serverTrust. If `nil`, the domain will not be validated. // æœåŠ¡å™¨åŸŸå @return Whether or not to trust the server. */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain; æ ¹æ®å®‰å…¨ç­–ç•¥æ˜¯å¦æ¥å—æŒ‡å®šçš„æœåŠ¡å™¨ä¿¡ä»»ã€‚ å“åº”æ¥è‡ªæœåŠ¡å™¨çš„èº«ä»½éªŒè¯è´¨è¯¢æ—¶åº”ä½¿ç”¨æ­¤æ–¹æ³•ã€‚ å¤§å®¶è¿˜è®°å¾—è¿™ä¸ªä»£ç†æ–¹æ³•å—ï¼Ÿ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; //æŒ‘æˆ˜å¤„ç†ç±»å‹ä¸º é»˜è®¤ /* NSURLSessionAuthChallengePerformDefaultHandlingï¼šé»˜è®¤æ–¹å¼å¤„ç† NSURLSessionAuthChallengeUseCredentialï¼šä½¿ç”¨æŒ‡å®šçš„è¯ä¹¦ NSURLSessionAuthChallengeCancelAuthenticationChallengeï¼šå–æ¶ˆæŒ‘æˆ˜ */ NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; // sessionDidReceiveAuthenticationChallengeæ˜¯è‡ªå®šä¹‰æ–¹æ³•ï¼Œç”¨æ¥å¦‚ä½•åº”å¯¹æœåŠ¡å™¨ç«¯çš„è®¤è¯æŒ‘æˆ˜ if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; // æ­¤å¤„æœåŠ¡å™¨è¦æ±‚å®¢æˆ·ç«¯çš„æ¥æ”¶è®¤è¯æŒ‘æˆ˜æ–¹æ³•æ˜¯NSURLAuthenticationMethodServerTrust // ä¹Ÿå°±æ˜¯è¯´æœåŠ¡å™¨ç«¯éœ€è¦å®¢æˆ·ç«¯è¿”å›ä¸€ä¸ªæ ¹æ®è®¤è¯æŒ‘æˆ˜çš„ä¿æŠ¤ç©ºé—´æä¾›çš„ä¿¡ä»»ï¼ˆå³challenge.protectionSpace.serverTrustï¼‰äº§ç”Ÿçš„æŒ‘æˆ˜è¯ä¹¦ã€‚ // è€Œè¿™ä¸ªè¯ä¹¦å°±éœ€è¦ä½¿ç”¨credentialForTrust:æ¥åˆ›å»ºä¸€ä¸ªNSURLCredentialå¯¹è±¡ if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; // åŸºäºå®¢æˆ·ç«¯çš„å®‰å…¨ç­–ç•¥æ¥å†³å®šæ˜¯å¦ä¿¡ä»»è¯¥æœåŠ¡å™¨ï¼Œä¸ä¿¡ä»»çš„è¯ï¼Œä¹Ÿå°±æ²¡å¿…è¦å“åº”æŒ‘æˆ˜ if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; // åˆ›å»ºæŒ‘æˆ˜è¯ä¹¦ï¼ˆæ³¨ï¼šæŒ‘æˆ˜æ–¹å¼ä¸ºUseCredentialå’ŒPerformDefaultHandlingéƒ½éœ€è¦æ–°å»ºæŒ‘æˆ˜è¯ä¹¦ï¼‰ credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; // ç¡®å®šæŒ‘æˆ˜çš„æ–¹å¼ if (credential) &#123; //è¯ä¹¦æŒ‘æˆ˜ è®¾è®¡policy,noneï¼Œåˆ™è·‘åˆ°è¿™é‡Œ disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; //å–æ¶ˆæŒ‘æˆ˜ disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; //é»˜è®¤æŒ‘æˆ˜æ–¹å¼ disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; //å®ŒæˆæŒ‘æˆ˜ if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; è¿™ä¸ªæ–¹æ³•æ˜¯å¦‚ä½•è¿›è¡Œæ¥å—æŒ‘æˆ˜çš„ é¦–å…ˆæŒ‡å®šäº†HTTPSä¸ºé»˜è®¤çš„è®¤è¯æ–¹å¼ã€‚ åˆ¤æ–­æœ‰æ²¡æœ‰è‡ªå®šä¹‰Block:sessionDidReceiveAuthenticationChallengeï¼Œæœ‰çš„è¯ï¼Œä½¿ç”¨æˆ‘ä»¬è‡ªå®šä¹‰Block,ç”Ÿæˆä¸€ä¸ªè®¤è¯æ–¹å¼ï¼Œå¹¶ä¸”å¯ä»¥ç»™credentialèµ‹å€¼ï¼Œå³æˆ‘ä»¬éœ€è¦æ¥å—è®¤è¯çš„è¯ä¹¦ã€‚ç„¶åç›´æ¥è°ƒç”¨completionHandlerï¼Œå»æ ¹æ®è¿™ä¸¤ä¸ªå‚æ•°ï¼Œæ‰§è¡Œç³»ç»Ÿçš„è®¤è¯ã€‚ å¦‚æœæ²¡æœ‰è‡ªå®šä¹‰Blockï¼Œæˆ‘ä»¬åˆ¤æ–­å¦‚æœæœåŠ¡ç«¯çš„è®¤è¯æ–¹æ³•è¦æ±‚æ˜¯NSURLAuthenticationMethodServerTrustï¼Œåˆ™åªéœ€è¦éªŒè¯æœåŠ¡ç«¯è¯ä¹¦æ˜¯å¦å®‰å…¨ï¼ˆå³httpsçš„å•å‘è®¤è¯ï¼Œè¿™æ˜¯AFé»˜è®¤å¤„ç†çš„è®¤è¯æ–¹å¼ï¼Œå…¶ä»–çš„è®¤è¯æ–¹å¼ï¼Œåªèƒ½ç”±æˆ‘ä»¬è‡ªå®šä¹‰Blockçš„å®ç°ï¼‰ æ¥ç€æˆ‘ä»¬å°±æ‰§è¡Œäº†AFSecurityPolicyç›¸å…³çš„ä¸Šé¢çš„æ–¹æ³•- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domainï¼Œå…³äºè¿™ä¸ªæ–¹æ³•ï¼ŒAFé»˜è®¤çš„å¤„ç†æ˜¯ï¼Œå¦‚æœè¿™è¡Œè¿”å›NOã€è¯´æ˜AFå†…éƒ¨è®¤è¯å¤±è´¥ï¼Œåˆ™å–æ¶ˆHTTPSè®¤è¯ï¼Œå³å–æ¶ˆè¯·æ±‚ã€‚è¿”å›YESåˆ™è¿›å…¥ifå—ï¼Œç”¨æœåŠ¡å™¨è¿”å›çš„ä¸€ä¸ªserverTrustå»ç”Ÿæˆäº†ä¸€ä¸ªè®¤è¯è¯ä¹¦ã€‚ï¼ˆæ³¨ï¼šè¿™ä¸ªserverTrustæ˜¯æœåŠ¡å™¨ä¼ è¿‡æ¥çš„ï¼Œé‡Œé¢åŒ…å«äº†æœåŠ¡å™¨çš„è¯ä¹¦ä¿¡æ¯ï¼Œæ˜¯ç”¨æ¥æˆ‘ä»¬æœ¬åœ°å®¢æˆ·ç«¯å»éªŒè¯è¯¥è¯ä¹¦æ˜¯å¦åˆæ³•ç”¨çš„ï¼Œåé¢ä¼šæ›´è¯¦ç»†çš„å»è®²è¿™ä¸ªå‚æ•°ï¼‰ç„¶åå¦‚æœæœ‰è¯ä¹¦ï¼Œåˆ™ç”¨è¯ä¹¦è®¤è¯æ–¹å¼ï¼Œå¦åˆ™è¿˜æ˜¯ç”¨é»˜è®¤çš„éªŒè¯æ–¹å¼ã€‚æœ€åè°ƒç”¨completionHandlerä¼ é€’è®¤è¯æ–¹å¼å’Œè¦è®¤è¯çš„è¯ä¹¦ï¼Œå»åšç³»ç»Ÿæ ¹è¯ä¹¦éªŒè¯ã€‚ä¹Ÿå¯ä»¥è¿™ä¹ˆç†è§£ï¼šè¿™é‡ŒsecurityPolicyå­˜åœ¨çš„ä½œç”¨å°±æ˜¯ï¼Œä½¿å¾—åœ¨ç³»ç»Ÿåº•å±‚è‡ªå·±å»éªŒè¯ä¹‹å‰ï¼ŒAFå¯ä»¥å…ˆå»éªŒè¯æœåŠ¡ç«¯çš„è¯ä¹¦ã€‚å¦‚æœé€šä¸è¿‡ï¼Œåˆ™ç›´æ¥è¶Šè¿‡ç³»ç»Ÿçš„éªŒè¯ï¼Œå–æ¶ˆHTTPSçš„ç½‘ç»œè¯·æ±‚ã€‚å¦åˆ™ï¼Œç»§ç»­å»èµ°ç³»ç»Ÿæ ¹è¯ä¹¦çš„éªŒè¯ã€‚ AFSecurityPolicyå®ä¾‹åŒ–å…ˆçœ‹ä¸€ä¸‹è¯¥ç±»çš„å®ä¾‹åŒ– 12345678AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125; è¿™é‡Œæœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„å±æ€§å°±æ˜¯SSLPinningModeï¼Œå…ˆçœ‹ä¸€ä¸‹è¿™ä¸ªæšä¸¾ 12345typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, //ä¸éªŒè¯ AFSSLPinningModePublicKey, //åªéªŒè¯å…¬é’¥ AFSSLPinningModeCertificate, // éªŒè¯è¯ä¹¦&#125;; ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹ç±»AFSecurityPolicyçš„å‡ ä¸ªå±æ€§ 123456789101112131415161718192021222324252627/** The criteria by which server trust should be evaluated against the pinned SSL certificates. Defaults to `AFSSLPinningModeNone`. */// éªŒè¯æ¨¡å¼ è¿™ä¸ªæšä¸¾å€¼ä¸Šé¢è®²è¿°è¿‡@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;/** The certificates used to evaluate server trust according to the SSL pinning mode. By default, this property is set to any (`.cer`) certificates included in the target compiling AFNetworking. Note that if you are using AFNetworking as embedded framework, no certificates will be pinned by default. Use `certificatesInBundle` to load certificates from your target, and then create a new policy by calling `policyWithPinningMode:withPinnedCertificates`. Note that if pinning is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches. */// å¯ä»¥å»åŒ¹é…æœåŠ¡ç«¯è¯ä¹¦éªŒè¯çš„è¯ä¹¦@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;/** Whether or not to trust servers with an invalid or expired SSL certificates. Defaults to `NO`. */// æ˜¯å¦æ”¯æŒéæ³•çš„è¯ä¹¦ï¼ˆä¾‹å¦‚è‡ªç­¾åè¯ä¹¦ï¼‰@property (nonatomic, assign) BOOL allowInvalidCertificates;/** Whether or not to validate the domain name in the certificate's CN field. Defaults to `YES`. */// æ˜¯å¦å»éªŒè¯è¯ä¹¦åŸŸåæ˜¯å¦åŒ¹é…@property (nonatomic, assign) BOOL validatesDomainName; AFNetWorking HTTPSè¯·æ±‚ç¤ºä¾‹è‡ªç­¾åè¯ä¹¦æˆ‘ä»¬æ‰‹åŠ¨æŒ‡å®šsecurityPolicyè®¤è¯å±æ€§ã€‚é€šè¿‡12306è¯ä¹¦æ¥å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//è‡ªå»ºè¯ä¹¦è®¤è¯- (IBAction)buttion1:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://kyfw.12306.cn/otn/leftTicket/init\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // [request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //æŒ‡å®šå®‰å…¨ç­–ç•¥ manager.securityPolicy = [self ticketSecurityPolicy]; //æŒ‡å®šè¿”å›æ•°æ®ç±»å‹,é»˜è®¤æ˜¯AFJSONResponseSerializerç±»å‹ï¼ŒçŠ¹è±«è¿™é‡Œä¸æ˜¯JSONç±»å‹çš„è¿”å›æ•°æ®ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨æŒ‡å®šè¿”å›ç±»å‹ AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/** 12306çš„è®¤è¯è¯ä¹¦ï¼Œä»–çš„è®¤è¯è¯ä¹¦æ˜¯è‡ªç­¾åçš„ @return è¿”å›æŒ‡å®šçš„è®¤è¯ç­–ç•¥ */-(AFSecurityPolicy*)ticketSecurityPolicy &#123; // /å…ˆå¯¼å…¥è¯ä¹¦ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"12306\" ofType:@\"cer\"];//è¯ä¹¦çš„è·¯å¾„ NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate ä½¿ç”¨è¯ä¹¦éªŒè¯æ¨¡å¼ã€‚ä¸‹é¢è¿™ä¸ªæ–¹æ³•ä¼šé»˜è®¤ä½¿ç”¨é¡¹ç›®é‡Œé¢çš„æ‰€æœ‰è¯ä¹¦ securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; &#125; // allowInvalidCertificates æ˜¯å¦å…è®¸æ— æ•ˆè¯ä¹¦ï¼ˆä¹Ÿå°±æ˜¯è‡ªå»ºçš„è¯ä¹¦ï¼‰ï¼Œé»˜è®¤ä¸ºNO // å¦‚æœæ˜¯éœ€è¦éªŒè¯è‡ªå»ºè¯ä¹¦ï¼Œéœ€è¦è®¾ç½®ä¸ºYES securityPolicy.allowInvalidCertificates = YES; //validatesDomainName æ˜¯å¦éœ€è¦éªŒè¯åŸŸåï¼Œé»˜è®¤ä¸ºYESï¼› //å‡å¦‚è¯ä¹¦çš„åŸŸåä¸ä½ è¯·æ±‚çš„åŸŸåä¸ä¸€è‡´ï¼Œéœ€æŠŠè¯¥é¡¹è®¾ç½®ä¸ºNOï¼›å¦‚è®¾æˆNOçš„è¯ï¼Œå³æœåŠ¡å™¨ä½¿ç”¨å…¶ä»–å¯ä¿¡ä»»æœºæ„é¢å‘çš„è¯ä¹¦ï¼Œä¹Ÿå¯ä»¥å»ºç«‹è¿æ¥ï¼Œè¿™ä¸ªéå¸¸å±é™©ï¼Œå»ºè®®æ‰“å¼€ã€‚ //ç½®ä¸ºNOï¼Œä¸»è¦ç”¨äºè¿™ç§æƒ…å†µï¼šå®¢æˆ·ç«¯è¯·æ±‚çš„æ˜¯å­åŸŸåï¼Œè€Œè¯ä¹¦ä¸Šçš„æ˜¯å¦å¤–ä¸€ä¸ªåŸŸåã€‚å› ä¸ºSSLè¯ä¹¦ä¸Šçš„åŸŸåæ˜¯ç‹¬ç«‹çš„ï¼Œå‡å¦‚è¯ä¹¦ä¸Šæ³¨å†Œçš„åŸŸåæ˜¯www.google.comï¼Œé‚£ä¹ˆmail.google.comæ˜¯æ— æ³•éªŒè¯é€šè¿‡çš„ï¼›å½“ç„¶ï¼Œæœ‰é’±å¯ä»¥æ³¨å†Œé€šé…ç¬¦çš„åŸŸå*.google.comï¼Œä½†è¿™ä¸ªè¿˜æ˜¯æ¯”è¾ƒè´µçš„ã€‚ //å¦‚ç½®ä¸ºNOï¼Œå»ºè®®è‡ªå·±æ·»åŠ å¯¹åº”åŸŸåçš„æ ¡éªŒé€»è¾‘ã€‚ securityPolicy.validatesDomainName = NO; return securityPolicy;&#125; SSLä¿¡ä»»è¯ä¹¦æˆ‘ä»¬æ‰‹åŠ¨æŒ‡å®šsecurityPolicyè®¤è¯å±æ€§ã€‚é€šè¿‡ç™¾åº¦è¯ä¹¦æ¥å®ç°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//è®¤è¯è¯ä¹¦è®¤è¯- (IBAction)button2:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.baidu.com\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //[request setValue:@\"text/html\" forHTTPHeaderField:@\"Accept\"]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //æŒ‡å®šå®‰å…¨ç­–ç•¥ manager.securityPolicy = [self baiduSecurityPolicy]; //æŒ‡å®šè¿”å›æ•°æ®ç±»å‹,é»˜è®¤æ˜¯AFJSONResponseSerializerç±»å‹ï¼ŒçŠ¹è±«è¿™é‡Œä¸æ˜¯JSONç±»å‹çš„è¿”å›æ•°æ®ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨æŒ‡å®šè¿”å›ç±»å‹ AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125;/**ç™¾åº¦çš„çš„è®¤è¯è¯ä¹¦ï¼Œä»–çš„è®¤è¯è¯ä¹¦æ˜¯èŠ±é’±ä¹°çš„ï¼Œä¹Ÿå°±æ˜¯ä¸æ˜¯è‡ªç­¾åçš„è¯ä¹¦ã€‚è¿™ç§è¯ä¹¦ï¼Œå¦‚æœæˆ‘ä»¬è¦æ‰‹åŠ¨æŒ‡å®šï¼Œpinmodeåªèƒ½æ˜¯`AFSSLPinningModeNone` @return è¿”å›æŒ‡å®šçš„è®¤è¯ç­–ç•¥ */-(AFSecurityPolicy*)baiduSecurityPolicy &#123; // /å…ˆå¯¼å…¥è¯ä¹¦ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"baidu\" ofType:@\"cer\"];//è¯ä¹¦çš„è·¯å¾„ NSData *certData = [NSData dataWithContentsOfFile:cerPath]; NSSet *set = [NSSet setWithObject:certData]; AFSecurityPolicy *securityPolicy; if (true) &#123; //è¿™é‡Œåªèƒ½ç”¨AFSSLPinningModeNoneæ‰èƒ½æˆåŠŸï¼Œè€Œä¸”æˆ‘ç³»ç»Ÿçš„è¯ä¹¦åˆ—è¡¨é‡Œé¢å·²ç»æœ‰ç™¾åº¦çš„è¯ä¹¦äº† securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone withPinnedCertificates:set]; &#125;else&#123; // AFSSLPinningModeCertificate ä½¿ç”¨è¯ä¹¦éªŒè¯æ¨¡å¼ã€‚ä¸‹é¢è¿™ä¸ªæ–¹æ³•ä¼šé»˜è®¤ä½¿ç”¨é¡¹ç›®é‡Œé¢çš„æ‰€æœ‰è¯ä¹¦ securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone]; &#125; // allowInvalidCertificates æ˜¯å¦å…è®¸æ— æ•ˆè¯ä¹¦ï¼ˆä¹Ÿå°±æ˜¯è‡ªå»ºçš„è¯ä¹¦ï¼‰ï¼Œé»˜è®¤ä¸ºNO // å¦‚æœæ˜¯éœ€è¦éªŒè¯è‡ªå»ºè¯ä¹¦ï¼Œéœ€è¦è®¾ç½®ä¸ºYES securityPolicy.allowInvalidCertificates = NO; //validatesDomainName æ˜¯å¦éœ€è¦éªŒè¯åŸŸåï¼Œé»˜è®¤ä¸ºYESï¼› //å‡å¦‚è¯ä¹¦çš„åŸŸåä¸ä½ è¯·æ±‚çš„åŸŸåä¸ä¸€è‡´ï¼Œéœ€æŠŠè¯¥é¡¹è®¾ç½®ä¸ºNOï¼›å¦‚è®¾æˆNOçš„è¯ï¼Œå³æœåŠ¡å™¨ä½¿ç”¨å…¶ä»–å¯ä¿¡ä»»æœºæ„é¢å‘çš„è¯ä¹¦ï¼Œä¹Ÿå¯ä»¥å»ºç«‹è¿æ¥ï¼Œè¿™ä¸ªéå¸¸å±é™©ï¼Œå»ºè®®æ‰“å¼€ã€‚ //ç½®ä¸ºNOï¼Œä¸»è¦ç”¨äºè¿™ç§æƒ…å†µï¼šå®¢æˆ·ç«¯è¯·æ±‚çš„æ˜¯å­åŸŸåï¼Œè€Œè¯ä¹¦ä¸Šçš„æ˜¯å¦å¤–ä¸€ä¸ªåŸŸåã€‚å› ä¸ºSSLè¯ä¹¦ä¸Šçš„åŸŸåæ˜¯ç‹¬ç«‹çš„ï¼Œå‡å¦‚è¯ä¹¦ä¸Šæ³¨å†Œçš„åŸŸåæ˜¯www.google.comï¼Œé‚£ä¹ˆmail.google.comæ˜¯æ— æ³•éªŒè¯é€šè¿‡çš„ï¼›å½“ç„¶ï¼Œæœ‰é’±å¯ä»¥æ³¨å†Œé€šé…ç¬¦çš„åŸŸå*.google.comï¼Œä½†è¿™ä¸ªè¿˜æ˜¯æ¯”è¾ƒè´µçš„ã€‚ //å¦‚ç½®ä¸ºNOï¼Œå»ºè®®è‡ªå·±æ·»åŠ å¯¹åº”åŸŸåçš„æ ¡éªŒé€»è¾‘ã€‚ securityPolicy.validatesDomainName = YES; return securityPolicy;&#125; SSLè¯ä¹¦AFNé»˜è®¤å¤„ç†è¿™é‡Œæˆ‘ä»¬ä¸åšä»»ä½•é¢å¤–çš„å¤„ç†ï¼Œç›´æ¥ä½¿ç”¨AFNçš„é»˜è®¤è¯ä¹¦å¤„ç†æœºåˆ¶ã€‚é€šè¿‡AFURLSessionManagerçš„securityPolicyé»˜è®¤å®ç°ã€‚å®ƒä¼šå’Œå­˜åœ¨ç³»ç»Ÿä¸­çš„åšå¯¹æ¯”æ¥éªŒè¯è¯ä¹¦ã€‚ 1234567891011121314//ç³»ç»Ÿè¯ä¹¦è®¤è¯- (IBAction)button3:(id)sender &#123; NSURL *url = [NSURL URLWithString:@\"https://www.apple.com/\"]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; //æŒ‡å®šè¿”å›æ•°æ®ç±»å‹,é»˜è®¤æ˜¯AFJSONResponseSerializerç±»å‹ï¼ŒçŠ¹è±«è¿™é‡Œä¸æ˜¯JSONç±»å‹çš„è¿”å›æ•°æ®ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨æŒ‡å®šè¿”å›ç±»å‹ AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer]; responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"]; manager.responseSerializer = responseSerializer; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@-----%@\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]; [dataTask resume];&#125; AFSecurityPolicyæºç è§£æAFSecurityPolicyåˆ†ä¸‰ç§éªŒè¯æ¨¡å¼ AFSSLPinningModeNone:è¿™ä¸ªæ¨¡å¼è¡¨ç¤ºä¸åšSSL pinningï¼Œåªè·Ÿæµè§ˆå™¨ä¸€æ ·åœ¨ç³»ç»Ÿçš„ä¿¡ä»»æœºæ„åˆ—è¡¨é‡ŒéªŒè¯æœåŠ¡ç«¯è¿”å›çš„è¯ä¹¦ã€‚è‹¥è¯ä¹¦æ˜¯ä¿¡ä»»æœºæ„ç­¾å‘çš„å°±ä¼šé€šè¿‡ï¼Œè‹¥æ˜¯è‡ªå·±æœåŠ¡å™¨ç”Ÿæˆçš„è¯ä¹¦ï¼Œè¿™é‡Œæ˜¯ä¸ä¼šé€šè¿‡çš„ã€‚ AFSSLPinningModeCertificate:è¿™ä¸ªæ¨¡å¼è¡¨ç¤ºç”¨è¯ä¹¦ç»‘å®šæ–¹å¼éªŒè¯è¯ä¹¦ï¼Œéœ€è¦å®¢æˆ·ç«¯ä¿å­˜æœ‰æœåŠ¡ç«¯çš„è¯ä¹¦æ‹·è´ï¼Œè¿™é‡ŒéªŒè¯åˆ†ä¸¤æ­¥ï¼Œç¬¬ä¸€æ­¥éªŒè¯è¯ä¹¦çš„åŸŸå/æœ‰æ•ˆæœŸç­‰ä¿¡æ¯ï¼Œç¬¬äºŒæ­¥æ˜¯å¯¹æ¯”æœåŠ¡ç«¯è¿”å›çš„è¯ä¹¦è·Ÿå®¢æˆ·ç«¯è¿”å›çš„æ˜¯å¦ä¸€è‡´ã€‚è¿™é‡Œè¿˜æ²¡å¼„æ˜ç™½ç¬¬ä¸€æ­¥çš„éªŒè¯æ˜¯æ€ä¹ˆè¿›è¡Œçš„ï¼Œä»£ç ä¸Šè·Ÿå»ç³»ç»Ÿä¿¡ä»»æœºæ„åˆ—è¡¨é‡ŒéªŒè¯ä¸€æ ·è°ƒç”¨äº†SecTrustEvaluateï¼Œåªæ˜¯è¿™é‡Œçš„åˆ—è¡¨æ¢æˆäº†å®¢æˆ·ç«¯ä¿å­˜çš„é‚£äº›è¯ä¹¦åˆ—è¡¨ã€‚è‹¥è¦éªŒè¯è¿™ä¸ªï¼Œæ˜¯å¦åº”è¯¥æŠŠæœåŠ¡ç«¯è¯ä¹¦çš„é¢å‘æœºæ„æ ¹è¯ä¹¦ä¹Ÿæ”¾åˆ°å®¢æˆ·ç«¯é‡Œï¼Ÿ AFSSLPinningModePublicKey:è¿™ä¸ªæ¨¡å¼åŒæ ·æ˜¯ç”¨è¯ä¹¦ç»‘å®šæ–¹å¼éªŒè¯ï¼Œå®¢æˆ·ç«¯è¦æœ‰æœåŠ¡ç«¯çš„è¯ä¹¦æ‹·è´ï¼Œåªæ˜¯éªŒè¯æ—¶åªéªŒè¯è¯ä¹¦é‡Œçš„å…¬é’¥ï¼Œä¸éªŒè¯è¯ä¹¦çš„æœ‰æ•ˆæœŸç­‰ä¿¡æ¯ã€‚åªè¦å…¬é’¥æ˜¯æ­£ç¡®çš„ï¼Œå°±èƒ½ä¿è¯é€šä¿¡ä¸ä¼šè¢«çªƒå¬ï¼Œå› ä¸ºä¸­é—´äººæ²¡æœ‰ç§é’¥ï¼Œæ— æ³•è§£å¼€é€šè¿‡å…¬é’¥åŠ å¯†çš„æ•°æ®ã€‚ SecTrustRefè¿™æ˜¯ä¸€ä¸ªéœ€è¦éªŒè¯çš„ä¿¡ä»»å¯¹è±¡,åŒ…å«å¾…éªŒè¯çš„è¯ä¹¦å’Œæ”¯æŒçš„éªŒè¯æ–¹æ³•ç­‰ã€‚ SecTrustResultTypeè¡¨ç¤ºéªŒè¯ç»“æœã€‚å…¶ä¸­ kSecTrustResultProceedè¡¨ç¤ºserverTrustéªŒè¯æˆåŠŸï¼Œä¸”è¯¥éªŒè¯å¾—åˆ°äº†ç”¨æˆ·è®¤å¯(ä¾‹å¦‚åœ¨å¼¹å‡ºçš„æ˜¯å¦ä¿¡ä»»çš„alertæ¡†ä¸­é€‰æ‹©always trust)ã€‚ kSecTrustResultUnspecifiedè¡¨ç¤º serverTrustéªŒè¯æˆåŠŸï¼Œæ­¤è¯ä¹¦ä¹Ÿè¢«æš—ä¸­ä¿¡ä»»äº†ï¼Œä½†æ˜¯ç”¨æˆ·å¹¶æ²¡æœ‰æ˜¾ç¤ºåœ°å†³å®šä¿¡ä»»è¯¥è¯ä¹¦ã€‚ ä¸¤è€…å–å…¶ä¸€å°±å¯ä»¥è®¤ä¸ºå¯¹serverTrustéªŒè¯æˆåŠŸã€‚ SecTrustEvaluateè¯ä¹¦æ ¡éªŒå‡½æ•°,åœ¨å‡½æ•°çš„å†…éƒ¨é€’å½’åœ°ä»å¶èŠ‚ç‚¹è¯ä¹¦åˆ°æ ¹è¯ä¹¦éªŒè¯ã€‚éœ€è¦éªŒè¯è¯ä¹¦æœ¬èº«çš„åˆæ³•æ€§ï¼ˆéªŒè¯ç­¾åå®Œæ•´æ€§ï¼ŒéªŒè¯è¯ä¹¦æœ‰æ•ˆæœŸç­‰);éªŒè¯è¯ä¹¦é¢å‘è€…çš„åˆæ³•æ€§ï¼ˆæŸ¥æ‰¾é¢å‘è€…çš„è¯ä¹¦å¹¶æ£€æŸ¥å…¶åˆæ³•æ€§ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯é€’å½’çš„).è€Œé€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯è¯ä¹¦éªŒè¯è¿‡ç¨‹ä¸­é‡åˆ°äº†é”šç‚¹è¯ä¹¦(é”šç‚¹è¯ä¹¦:åµŒå…¥åˆ°æ“ä½œç³»ç»Ÿä¸­çš„æ ¹è¯ä¹¦,è¿™ä¸ªæ ¹è¯ä¹¦æ˜¯æƒå¨è¯ä¹¦é¢å‘æœºæ„é¢å‘çš„è‡ªç­¾åè¯ä¹¦)ã€‚ AFSecurityPolicyçš„æºç ç»†èŠ‚å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383/** è¯ä¹¦çš„éªŒè¯ç±»å‹ - AFSSLPinningModeNone: ä¸ä½¿ç”¨`pinned certificates`æ¥éªŒè¯è¯ä¹¦ - AFSSLPinningModePublicKey: ä½¿ç”¨`pinned certificates`æ¥éªŒè¯è¯ä¹¦çš„å…¬é’¥ - AFSSLPinningModeCertificate: ä½¿ç”¨`pinned certificates`æ¥éªŒè¯æ•´ä¸ªè¯ä¹¦ */typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate,&#125;;/** è·å–æŒ‡å®šè¯ä¹¦çš„å…¬é’¥ @param certificate è¯ä¹¦æ•°æ® @return å…¬é’¥ */static id AFPublicKeyForCertificate(NSData *certificate) &#123; id allowedPublicKey = nil; SecCertificateRef allowedCertificate; SecPolicyRef policy = nil; SecTrustRef allowedTrust = nil; SecTrustResultType result; //è·å–è¯ä¹¦å¯¹è±¡ allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate); __Require_Quiet(allowedCertificate != NULL, _out); //è·å–X.509çš„è®¤è¯ç­–ç•¥ policy = SecPolicyCreateBasicX509(); //è·å–allowedTrustå¯¹è±¡çš„å€¼ __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _out); __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out); //æ ¹æ®allowedTrustè·å–å¯¹åº”çš„å…¬é’¥ allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);//C++çš„gumptoè·³è½¬ï¼Œå½“å‰é¢çš„æ“ä½œå‡ºé”™ä»¥åï¼Œç›´æ¥è·³å…¥_outæ‰§è¡Œ_out: if (allowedTrust) &#123; CFRelease(allowedTrust); &#125; if (policy) &#123; CFRelease(policy); &#125; if (allowedCertificate) &#123; CFRelease(allowedCertificate); &#125; //è¿”å›å…¬é’¥ return allowedPublicKey;&#125;/** åœ¨æŒ‡å®šçš„è¯ä¹¦å’Œè®¤è¯ç­–ç•¥ä¸‹ï¼ŒéªŒè¯SecTrustRefå¯¹è±¡æ˜¯å¦æ˜¯å—ä¿¡ä»»çš„ã€åˆæ³•çš„ã€‚ @param serverTrust SecTrustRefå¯¹è±¡ @return ç»“æœ */static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; //è·å–serverTrustçš„è®¤è¯ç»“æœï¼Œè°ƒç”¨`SecTrustEvaluate`è¡¨ç¤ºé€šè¿‡ç³»ç»Ÿçš„è¯ä¹¦æ¥æ¯”è¾ƒè®¤è¯ __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125;/** æ ¹æ®`serverTrust`è·å–è®¤è¯çš„è¯ä¹¦é“¾ @param serverTrust serverTrustå¯¹è±¡ @return è®¤è¯è¯ä¹¦é“¾ */static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //è·å–è®¤è¯é“¾çš„æ€»å±‚æ¬¡ CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; //è·å–æ¯ä¸€çº§è®¤è¯é“¾ï¼ŒæŠŠè·å–çš„è¯ä¹¦æ•°æ®å­˜å…¥æ•°ç»„ä¸­ for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)]; &#125; //è¿”å›è¯ä¹¦é“¾æ•°ç»„ return [NSArray arrayWithArray:trustChain];&#125;/** è·å–serverTrustå¯¹è±¡çš„è®¤è¯é“¾çš„å…¬é’¥æ•°ç»„ @param serverTrust serverTrustå¯¹è±¡ @return å…¬é’¥æ•°ç»„ */static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123; //X.509æ ‡å‡†çš„å®‰å…¨ç­–ç•¥ SecPolicyRef policy = SecPolicyCreateBasicX509(); //è·å–è¯ä¹¦é“¾çš„è¯ä¹¦æ•°é‡ CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); SecCertificateRef someCertificates[] = &#123;certificate&#125;; CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL); SecTrustRef trust; //é€šè¿‡ä¸€ä¸ªè¯ä¹¦ã€è®¤è¯ç­–ç•¥æ–°å»ºä¸€ä¸ªSecTrustRefå¯¹è±¡ __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _out); SecTrustResultType result; //éªŒè¯SecTrustRefå¯¹è±¡æ˜¯å¦æˆåŠŸ __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _out); //æŠŠSecTrustRefå¯¹åº”çš„å…¬é’¥åŠ å…¥æ•°ç»„ä¸­ [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)]; _out: if (trust) &#123; CFRelease(trust); &#125; if (certificates) &#123; CFRelease(certificates); &#125; continue; &#125; CFRelease(policy); return [NSArray arrayWithArray:trustChain];&#125;#pragma mark -@interface AFSecurityPolicy()//è®¤è¯ç­–ç•¥@property (readwrite, nonatomic, assign) AFSSLPinningMode SSLPinningMode;//å…¬é’¥é›†åˆ@property (readwrite, nonatomic, strong) NSSet *pinnedPublicKeys;@end@implementation AFSecurityPolicy/** ä»MainBundleä¸­è·å–æ‰€æœ‰è¯ä¹¦ @param bundle è¿”å›åŒ…å«åœ¨bundleä¸­çš„è¯ä¹¦é›†åˆã€‚å¦‚æœAFNetworkingä½¿ç”¨çš„æ˜¯é™æ€åº“ï¼Œæˆ‘ä»¬å¿…é¡»é€šè¿‡è¿™ä¸ªæ–¹æ³•æ¥åŠ è½½è¯ä¹¦ã€‚å¹¶ä¸”é€šè¿‡`policyWithPinningMode:withPinnedCertificates`æ–¹æ³•æ¥æŒ‡å®šè®¤è¯ç±»å‹ã€‚ @return è¿”å›bundleé‡Œé¢çš„è¯ä¹¦ */+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123; //è·å–é¡¹ç›®é‡Œçš„æ‰€æœ‰.cerè¯ä¹¦ NSArray *paths = [bundle pathsForResourcesOfType:@\"cer\" inDirectory:@\".\"]; NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]]; for (NSString *path in paths) &#123; //è·å–è¯ä¹¦å¯¹åº”çš„NSDataï¼Œå¹¶ä¸”åŠ å…¥é›†åˆä¸­ NSData *certificateData = [NSData dataWithContentsOfFile:path]; [certificates addObject:certificateData]; &#125; //è¿”å›è¯ä¹¦é›†åˆ return [NSSet setWithSet:certificates];&#125;/** è¿”å›å½“å‰ç±»æ‰€åœ¨bundleæ‰€åœ¨çš„è¯ä¹¦é›†åˆ @return è¯ä¹¦é›†åˆ */+ (NSSet *)defaultPinnedCertificates &#123; static NSSet *_defaultPinnedCertificates = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //è·å–å½“å‰ç±»æ‰€åœ¨bundle NSBundle *bundle = [NSBundle bundleForClass:[self class]]; _defaultPinnedCertificates = [self certificatesInBundle:bundle]; &#125;); return _defaultPinnedCertificates;&#125;/** è¿”å›é»˜è®¤çš„å®‰å…¨è®¤è¯ç­–ç•¥,åœ¨è¿™é‡Œæ˜¯éªŒè¯ç³»ç»Ÿçš„è¯ä¹¦ã€‚è¿™ä¸ªç­–ç•¥ä¸å…è®¸éæ³•è¯ä¹¦ã€éªŒè¯ä¸»æœºåã€ä¸éªŒè¯è¯ä¹¦å†…å®¹å’Œå…¬é’¥ @return è¿”å›è®¤è¯ç­–ç•¥ */+ (instancetype)defaultPolicy &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = AFSSLPinningModeNone; return securityPolicy;&#125;/** æ ¹æ®æŒ‡å®šçš„è®¤è¯ç­–ç•¥å’Œé»˜è®¤çš„è¯ä¹¦åˆ—è¡¨åˆå§‹åŒ–ä¸€ä¸ª`AFSecurityPolicy`å¯¹è±¡ @param pinningMode è®¤è¯ç­–ç•¥ @return `AFSecurityPolicy`å¯¹è±¡ */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123; return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];&#125;/** é€šè¿‡åˆ¶å®šçš„è®¤è¯ç­–ç•¥`pinningMode`å’Œè¯ä¹¦é›†åˆ`pinnedCertificates`æ¥åˆå§‹åŒ–ä¸€ä¸ª`AFSecurityPolicy`å¯¹è±¡ @param pinningMode è®¤è¯æ¨¡å‹ @param pinnedCertificates è¯ä¹¦é›†åˆ @return AFSecurityPolicyå¯¹è±¡ */+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = pinningMode; //è®¾ç½®`_pinnedCertificates`å’Œ`pinnedPublicKeys`å±æ€§ï¼Œåˆ†åˆ«å¯¹åº”è¯ä¹¦é›†åˆå’Œå…¬é’¥é›†åˆ [securityPolicy setPinnedCertificates:pinnedCertificates]; //è¿”å›åˆå§‹åŒ–æˆåŠŸçš„`AFSecurityPolicy` return securityPolicy;&#125;- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; //é»˜è®¤æ˜¯è¦è®¤è¯ä¸»æœºåç§° self.validatesDomainName = YES; return self;&#125;/**é€šè¿‡æŒ‡å®šçš„è¯ä¹¦ç»“åˆè·å–åˆ°å¯¹åº”çš„å…¬é’¥é›†åˆã€‚ç„¶åèµ‹å€¼ç»™`pinnedPublicKeys`å±æ€§ @param pinnedCertificates è¯ä¹¦é›†åˆ */- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123; _pinnedCertificates = pinnedCertificates; if (self.pinnedCertificates) &#123; NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]]; //è¿­ä»£æ¯ä¸€ä¸ªè¯ä¹¦ for (NSData *certificate in self.pinnedCertificates) &#123; //è·å–è¯ä¹¦å¯¹åº”çš„å…¬é’¥ id publicKey = AFPublicKeyForCertificate(certificate); if (!publicKey) &#123; continue; &#125; [mutablePinnedPublicKeys addObject:publicKey]; &#125; //èµ‹å€¼ç»™å¯¹åº”çš„å±æ€§ self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys]; &#125; else &#123; self.pinnedPublicKeys = nil; &#125;&#125;#pragma mark -/** ä¸ºserverTrustå¯¹è±¡æŒ‡å®šè®¤è¯ç­–ç•¥ï¼Œå¦‚æœdomainä¸ä¸ºnil,åˆ™åŒ…æ‹¬å¯¹ä¸»æœºåçš„è®¤è¯ã€‚è¿™ä¸ªæ–¹æ³•å¿…é¡»åœ¨æ¥å—åˆ°`authentication challenge`è¿”å›çš„æ—¶å€™è°ƒç”¨ã€‚ SecTrustRefå¯ä»¥ç†è§£ä¸ºæ¡¥æ¥è¯ä¹¦ä¸è®¤è¯ç­–ç•¥çš„å¯¹è±¡ï¼Œä»–å…³è”æŒ‡å®šçš„è¯ä¹¦ä¸è®¤è¯ç­–ç•¥ @param serverTrust æœåŠ¡å™¨çš„X.509æ ‡å‡†çš„è¯ä¹¦æ•°æ® @param domain è®¤è¯æœåŠ¡å™¨çš„ä¸»æœºåã€‚å¦‚æœæ˜¯nil,åˆ™ä¸ä¼šå¯¹ä¸»æœºåè¿›è¡Œè®¤è¯ã€‚ @return serverTrustæ˜¯å¦é€šè¿‡è®¤è¯ */- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // \"Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors.\" NSLog(@\"In order to validate a domain name for self signed certificates, you MUST use pinning.\"); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; //ä½¿ç”¨éœ€è¦è®¤è¯ä¸»æœºåçš„è®¤è¯ç­–ç•¥ [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; //ä½¿ç”¨é»˜è®¤çš„è®¤è¯ç­–ç•¥ [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; //ç»™serverTrustå¯¹è±¡æŒ‡å®šè®¤è¯ç­–ç•¥ SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; return NO; &#125; //æ ¹æ®è¯ä¹¦éªŒè¯ç­–ç•¥ã€æ•°å­—ç­¾åè®¤è¯ç­–ç•¥ã€å…¶ä»–è®¤è¯ç­–ç•¥æ¥å¤„ç†ä¸åŒæƒ…å†µ switch (self.SSLPinningMode) &#123; case AFSSLPinningModeNone://ä¸éªŒè¯å…¬é’¥å’Œè¯ä¹¦ default: return NO; case AFSSLPinningModeCertificate: &#123;//éªŒè¯æ•´ä¸ªè¯ä¹¦ NSMutableArray *pinnedCertificates = [NSMutableArray array]; //æ ¹æ®æŒ‡å®šè¯ä¹¦è·å–ï¼Œè·å–å¯¹åº”çš„è¯ä¹¦å¯¹è±¡ for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; //æŠŠè¯ä¹¦ä¸serverTrustå…³è”èµ·æ¥ SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA) //è·å–serverTrustè¯ä¹¦é“¾ã€‚ç›´åˆ°æ ¹è¯ä¹¦ã€‚ NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); //å¦‚æœ`pinnedCertificates`åŒ…å«`serverTrust`å¯¹è±¡å¯¹åº”çš„è¯ä¹¦é“¾çš„æ ¹è¯ä¹¦ã€‚åˆ™è¿”å›true for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; return YES; &#125; &#125; return NO; &#125; case AFSSLPinningModePublicKey: &#123;//åªéªŒè¯è¯ä¹¦é‡Œé¢çš„æ•°å­—ç­¾å NSUInteger trustedPublicKeyCount = 0; //æ ¹æ®serverTrustå¯¹è±¡å’ŒSecPolicyCreateBasicX509è®¤è¯ç­–ç•¥ï¼Œè·å–å¯¹åº”çš„å…¬é’¥é›†åˆ NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); for (id trustChainPublicKey in publicKeys) &#123; //æŠŠè·å–çš„å…¬é’¥å’Œç³»ç»Ÿè·å–çš„é»˜è®¤å…¬é’¥æ¯”è¾ƒï¼Œå¦‚æœç›¸ç­‰ï¼Œåˆ™é€šè¿‡è®¤è¯ for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125;#pragma mark - NSKeyValueObserving+ (NSSet *)keyPathsForValuesAffectingPinnedPublicKeys &#123; return [NSSet setWithObject:@\"pinnedCertificates\"];&#125;#pragma mark - NSSecureCoding+ (BOOL)supportsSecureCoding &#123; return YES;&#125;- (instancetype)initWithCoder:(NSCoder *)decoder &#123; self = [self init]; if (!self) &#123; return nil; &#125; self.SSLPinningMode = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(SSLPinningMode))] unsignedIntegerValue]; self.allowInvalidCertificates = [decoder decodeBoolForKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; self.validatesDomainName = [decoder decodeBoolForKey:NSStringFromSelector(@selector(validatesDomainName))]; self.pinnedCertificates = [decoder decodeObjectOfClass:[NSArray class] forKey:NSStringFromSelector(@selector(pinnedCertificates))]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder &#123; [coder encodeObject:[NSNumber numberWithUnsignedInteger:self.SSLPinningMode] forKey:NSStringFromSelector(@selector(SSLPinningMode))]; [coder encodeBool:self.allowInvalidCertificates forKey:NSStringFromSelector(@selector(allowInvalidCertificates))]; [coder encodeBool:self.validatesDomainName forKey:NSStringFromSelector(@selector(validatesDomainName))]; [coder encodeObject:self.pinnedCertificates forKey:NSStringFromSelector(@selector(pinnedCertificates))];&#125;#pragma mark - NSCopying- (instancetype)copyWithZone:(NSZone *)zone &#123; AFSecurityPolicy *securityPolicy = [[[self class] allocWithZone:zone] init]; securityPolicy.SSLPinningMode = self.SSLPinningMode; securityPolicy.allowInvalidCertificates = self.allowInvalidCertificates; securityPolicy.validatesDomainName = self.validatesDomainName; securityPolicy.pinnedCertificates = [self.pinnedCertificates copyWithZone:zone]; return securityPolicy;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorkingåŸç†","slug":"AFNetWorkingåŸç†","permalink":"https://nixzhang5.github.io/tags/AFNetWorkingåŸç†/"},{"name":"Encryption","slug":"Encryption","permalink":"https://nixzhang5.github.io/tags/Encryption/"}]},{"title":"AFNetWorkingåŸç†(ä¸€) AFURLSessionManagerè§£è¯»","slug":"AFNetWorkingåŸç†","date":"2019-06-21T07:48:30.000Z","updated":"2019-06-25T03:19:09.896Z","comments":true,"path":"AFNetWorkingåŸç†.html","link":"","permalink":"https://nixzhang5.github.io/AFNetWorkingåŸç†.html","excerpt":"NSURLSession æ˜¯ iOS7 æ—¶æ¨å‡ºçš„ï¼Œä¸ºäº†å–ä»£ NSURLConnectionï¼ˆåœ¨iOS9åºŸå¼ƒï¼‰ï¼ŒAFNetWorkingä½¿ç”¨ NSURLSession ä½œä¸ºåŸºç¡€çš„ç½‘ç»œè¯·æ±‚ç±»ã€‚NSURLSession å·¥ä½œåœ¨åœ¨ OSI ä¸ƒå±‚æ¨¡å‹ çš„ä¼šè¯å±‚ï¼Œä¼šè¯å±‚ä¹‹ä¸‹çš„æ‰€æœ‰å·¥ä½œï¼Œç³»ç»Ÿéƒ½å·²ç»å¸®æˆ‘ä»¬åšå¥½äº†ï¼Œæ‰€ä»¥ NSURLSession å¯ä»¥ç†è§£ä¸ºä¼šè¯ã€‚","text":"NSURLSession æ˜¯ iOS7 æ—¶æ¨å‡ºçš„ï¼Œä¸ºäº†å–ä»£ NSURLConnectionï¼ˆåœ¨iOS9åºŸå¼ƒï¼‰ï¼ŒAFNetWorkingä½¿ç”¨ NSURLSession ä½œä¸ºåŸºç¡€çš„ç½‘ç»œè¯·æ±‚ç±»ã€‚NSURLSession å·¥ä½œåœ¨åœ¨ OSI ä¸ƒå±‚æ¨¡å‹ çš„ä¼šè¯å±‚ï¼Œä¼šè¯å±‚ä¹‹ä¸‹çš„æ‰€æœ‰å·¥ä½œï¼Œç³»ç»Ÿéƒ½å·²ç»å¸®æˆ‘ä»¬åšå¥½äº†ï¼Œæ‰€ä»¥ NSURLSession å¯ä»¥ç†è§£ä¸ºä¼šè¯ã€‚ AFNetworkingç”±5ä¸ªæ¨¡å—ç»„æˆ NSURLSessionï¼šç½‘ç»œé€šä¿¡æ¨¡å—ï¼ˆæ ¸å¿ƒæ¨¡å—ï¼‰ AFURLSessionManager å¯¹NSURLSessionçš„å°è£… AFHTTPSessionManager æ˜¯ç»§æ‰¿äº AFURLSessionmanager Securityï¼šç½‘ç»œé€šè®¯å®‰å…¨ç­–ç•¥æ¨¡å— AFSecurityPolicy Reachabilityï¼šç½‘ç»œçŠ¶æ€ç›‘å¬æ¨¡å— AFNetworkReachabilityManager Seriaalizationï¼šç½‘ç»œé€šä¿¡ä¿¡æ¯åºåˆ—åŒ–ã€ååºåˆ—åŒ–æ¨¡å— AFHTTPRequestSerializer AFURLResponseSerialization UIKitï¼šå¯¹äºiOS UIKitçš„æ‰©å±•åº“ ç½‘ç»œè¯·æ±‚ç±» AFURLSessionManagerå£°æ˜.hæ–‡ä»¶123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226// AFURLSessionManagerç±»å®ç°äº†NSURLSessionç›¸å…³çš„ä¼—å¤šåè®®ï¼Œç”¨äºå¸®åŠ©æˆ‘ä»¬è¿›è¡Œæ•°æ®çš„å¤„ç†@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;// NSURLSession ä½œä¸ºä¸€ä¸ªå®ä¾‹å˜é‡ï¼ŒAFNå‘èµ·çš„ç½‘ç»œè¯·æ±‚éƒ½æ˜¯é€šè¿‡è¯¥sessionåˆ›å»ºçš„taskå®ç°çš„@property (readonly, nonatomic, strong) NSURLSession *session;// NSURLSession delegateæ–¹æ³•æ‰§è¡Œé˜Ÿåˆ—@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;// å“åº”åºåˆ—åŒ– ä¸èƒ½ä¸ºnil@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;// å®‰å…¨ç­–ç•¥ï¼Œç”¨äºhttpsç­‰éœ€è¦éªŒè¯çš„åœ°æ–¹@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;#if !TARGET_OS_WATCHï¼ˆç”Ÿæˆçš„ä»£ç å°†åœ¨Apple Watchæ“ä½œç³»ç»Ÿä¸‹è¿è¡Œï¼‰///--------------------------------------/// @name Monitoring Network Reachability///--------------------------------------// ç›‘æµ‹ç½‘ç»œè¿é€šæ€§ï¼Œä½¿ç”¨AFNetworkReachabilityManager@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;#endif///----------------------------/// @name Getting Session Tasks///----------------------------// sessionç®¡ç†çš„data upload download taskçš„é›†åˆ@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;// sessionç®¡ç†çš„data taskçš„é›†åˆ@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;// sessionç®¡ç†çš„upload taskçš„é›†åˆ@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;// sessionç®¡ç†çš„download taskçš„é›†åˆ@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;///-------------------------------/// @name Managing Callback Queues///-------------------------------// å®Œæˆç½‘ç»œè¯·æ±‚åæ‰§è¡Œå›è°ƒå—çš„é˜Ÿåˆ—ï¼Œå¦‚æœä¸ºnilåˆ™ä½¿ç”¨ä¸»é˜Ÿåˆ—@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;// å®Œæˆç½‘ç»œè¯·æ±‚åå›è°ƒå—çš„@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;///---------------------------------/// @name Working Around System Bugs///---------------------------------// backgroundç±»å‹çš„sessionæ˜¯å¦å°è¯•é‡æ–°åˆ›å»ºä¸Šä¼ ä»»åŠ¡@property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions;///---------------------/// @name Initialization///---------------------// åˆå§‹åŒ–å‡½æ•°ï¼Œæ ¹æ®æŒ‡å®šNSURLSessionConfigurationåˆ›å»ºsession- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;// è®¾ç½®sessionæ— æ•ˆï¼ŒcancelPendingTasksæ ‡è¯†æ˜¯å¦å–æ¶ˆsessionä¸­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡// å†…éƒ¨è¿˜æ˜¯è°ƒç”¨NSURLSessionçš„invalidateæ–¹æ³•- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;///-------------------------/// @name Running Data Tasks///-------------------------// æ ¹æ®æŒ‡å®šçš„requeståˆ›å»ºä¸€ä¸ªNSURLSessionDataTaskä»»åŠ¡- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler DEPRECATED_ATTRIBUTE;// æ ¹æ®æŒ‡å®šçš„requeståˆ›å»ºä¸€ä¸ªNSURLSessionDataTaskä»»åŠ¡- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///---------------------------/// @name Running Upload Tasks///---------------------------// æ ¹æ®æŒ‡å®šrequest fileURLç­‰å‚æ•°æ„é€ ä¸€ä¸ªNSURLSessionUploadTaskä»»åŠ¡- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// æ ¹æ®æŒ‡å®šrequestå’Œdataç­‰å‚æ•°æ„é€ ä¸€ä¸ªä¸Šä¼ ä»»åŠ¡- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;// åˆ›å»ºä¸€ä¸ªå…·æœ‰ç‰¹å®šæ•°æ®æµçš„NSURLSessionUploadTaskè¯·æ±‚ï¼Œä¸Šä¼ çš„bodyä½¿ç”¨çš„æ˜¯request.HTTPBodyStream- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;///-----------------------------/// @name Running Download Tasks///-----------------------------// æ„é€ ä¸‹è½½ä»»åŠ¡- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;/*æ„é€ ä¸‹è½½ä»»åŠ¡ æ–­ç‚¹ç»­ä¼ æ ¹æ®æœªä¸‹è½½å®Œæˆçš„æ•°æ®ï¼Œåˆ›å»ºä¸€ä¸ªNSURLSessionDownloadTaskå¯¹è±¡ã€‚resumeDataï¼šæœªå®Œæˆçš„ä¸‹è½½æ•°æ®destinationï¼šå†³å®šä¸‹è½½æ–‡ä»¶çš„å­˜æ”¾è·¯å¾„çš„blockã€‚blockä¸­æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œç›®æ ‡è·¯å¾„å’ŒæœåŠ¡å™¨çš„å“åº”ã€‚åŒæ—¶è¿”å›æ–‡ä»¶ä¸‹è½½çš„URLcompletionHandlerï¼šå½“ä»»åŠ¡å®ŒæˆåcompletionHandlerçš„blockä¼šè¢«è°ƒç”¨progressï¼šä¸‹è½½è¿›åº¦blockã€‚æ¯å½“ä¸‹è½½è¿›åº¦æ›´æ–°æ—¶å°±ä¼šæ‰§è¡Œè¿™ä¸ªblock*/- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;///---------------------------------/// @name Getting Progress for Tasks///---------------------------------// æ ¹æ®NSURLSessionTaskè·å–å¯¹åº”çš„ä»»åŠ¡å®Œæˆè¿›åº¦NSProgress- (nullable NSProgress *)uploadProgressForTask:(NSURLSessionTask *)task;// æ ¹æ®NSURLSessionTaskè·å–å¯¹åº”ä¸‹è½½ä»»åŠ¡çš„è¿›åº¦NSProgress- (nullable NSProgress *)downloadProgressForTask:(NSURLSessionTask *)task;///-----------------------------------------/// @name Setting Session Delegate Callbacks///-----------------------------------------// è®¾ç½®sessionæ— æ•ˆæ—¶æ‰§è¡Œçš„å›è°ƒå—- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;// è®¾ç½®sessionæ”¶åˆ°challengeæ—¶æ‰§è¡Œçš„å›è°ƒå—- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;///--------------------------------------/// @name Setting Task Delegate Callbacks///--------------------------------------// è®¾ç½®sessionéœ€è¦æ–°çš„æµæ—¶æ‰§è¡Œçš„å›è°ƒå—- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;// è®¾ç½®sessionçš„ä»»åŠ¡éœ€è¦æ‰§è¡Œé‡å®šå‘æ—¶æ‰§è¡Œçš„å›è°ƒå—- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * _Nullable (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;// è®¾ç½®Blockç”¨äºå½“ä¸€ä¸ªsessionçš„taskæ¥æ”¶åˆ°è¯ä¹¦éªŒè¯æ—¶è°ƒç”¨ã€‚å®é™…ä¸Šä¾èµ–ç”±NSURLSessionTaskDelegate çš„ URLSession:task:didReceiveChallenge:completionHandler:.æ–¹æ³•å¤„ç†- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;// è®¾ç½®Blockæ¯éš”ä¸€æ®µæ—¶é—´è°ƒç”¨ç”¨æ¥è·Ÿè¸ªä¸Šä¼ è¿›åº¦ï¼Œå®é™…ä¸Šä¾èµ–ç”±NSURLSessionTaskDelegateçš„ URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:æ–¹æ³•å®ç°- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;// è®¾ç½®ä¸€ä¸ªå½“taskå®Œæˆæ—¶è°ƒç”¨çš„Block- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;///-------------------------------------------/// @name Setting Data Task Delegate Callbacks///-------------------------------------------// è®¾ç½®ä¸€ä¸ªå½“DataTaskè¯·æ±‚æ¥æ”¶åˆ°å“åº”æ—¶è°ƒç”¨çš„blockã€‚äº¤ç”±NSURLSessionDataDelegateçš„URLSession:dataTask:didReceiveResponse:completionHandler:.æ–¹æ³•å¤„ç†- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;// è®¾ç½®å½“ä¸€ä¸ªdataTaskè½¬å˜æˆdownloadTakæ—¶è°ƒç”¨çš„blockï¼Œäº¤ç”±NSURLSessionDataDelegate çš„ URLSession:dataTask:didBecomeDownloadTask:.æ–¹æ³•å¤„ç†- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;// è®¾ç½®å½“ä¸€ä¸ªdataTaskæ¥å—åˆ°æ•°æ®æ—¶å°±è°ƒç”¨çš„blockï¼Œäº¤ç”±NSURLSessionDataDelegate çš„ URLSession:dataTask:didReceiveResponse:completionHandler:.æ–¹æ³•å¤„ç†- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;// è®¾ç½®å½“ä¸€ä¸ªdataTaskå¯¹è¯·æ±‚ç»“æœçš„ç¼“å†²æ—¶çš„blockã€‚äº¤ç”±NSURLSessionDataDelegate çš„ URLSession:dataTask:willCacheResponse:completionHandler:.æ–¹æ³•å¤„ç†- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;// è®¾ç½®å½“sessionä¸­æ‰€æœ‰æ¶ˆæ¯éƒ½è¢«å‘é€æ—¶ï¼Œè°ƒç”¨çš„blockã€‚äº¤ç”±NSURLSessionDataDelegateçš„URLSessionDidFinishEventsForBackgroundURLSessionï¼šæ–¹æ³•å®ç°- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block AF_API_UNAVAILABLE(macos);///-----------------------------------------------/// @name Setting Download Task Delegate Callbacks///-----------------------------------------------// è®¾ç½®ä¸€ä¸ªå½“ä¸‹è½½ä»»åŠ¡å®Œæˆä¸€ä¸ªä¸‹è½½æ—¶è°ƒç”¨çš„blockã€‚æœ€ç»ˆäº¤ç”±NSURLSessionDownloadDelegate çš„ URLSession:downloadTask:didFinishDownloadingToURL:.æ–¹æ³•å¤„ç†- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;// è®¾ç½®æ¯æ¬¡è¿½è¸ªä¸‹è½½è¿›åº¦æ—¶è°ƒç”¨çš„blockï¼Œæœ€ç»ˆäº¤ç”±NSURLSessionDownloadDelegateçš„URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWriteï¼šæ–¹æ³•å¤„ç†- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;// è®¾ç½®ä¸€ä¸ªblockï¼Œå½“ä»»åŠ¡é‡æ–°ä¸‹è½½æ—¶è°ƒç”¨ã€‚äº¤ç”±NSURLSessionDownloadDelegate çš„ URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:.æ–¹å¼- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;@end///--------------------/// @name Notifications///--------------------FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidSuspendNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDidInvalidateNotification;FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseDataKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteAssetPathKey;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteErrorKey;NS_ASSUME_NONNULL_END é€šè¿‡å¤´æ–‡ä»¶å¯ä»¥å‘ç°ï¼ŒAFURLSessionManageræ˜¯å°è£…äº†NSURLSessionå¹¶å®ç°äº†å…¶ç›¸å…³çš„æ‰€æœ‰åè®®ï¼Œæä¾›äº†ä¸€ç³»åˆ—æ–¹æ³•ç”¨äºæ„é€ å„ç§ç½‘ç»œè¯·æ±‚ä»»åŠ¡ï¼Œå¹¶æä¾›å›è°ƒå—è¿›è¡Œå¤„ç†ï¼Œè¿˜æä¾›äº†ä¸€ç³»åˆ—è®¾ç½®ä»£ç†æ–¹æ³•æ‰§è¡Œæ—¶çš„æ‰§è¡Œå›è°ƒå—çš„æ–¹æ³•ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç›‘å¬æ•´ä¸ªç½‘ç»œè¯·æ±‚çš„è¿‡ç¨‹ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥å¿½ç•¥è¿™äº›ä»£ç†æ–¹æ³•æ‰§è¡Œæƒ…å†µï¼Œæä¾›äº†å„ç§é€šçŸ¥ï¼Œé€šè¿‡å¤´æ–‡ä»¶å¯ä»¥çœ‹å‡ºï¼Œä¸»è¦ç›®çš„è¿˜æ˜¯ä¸ºäº†å°è£…NSURLSessionä»è€Œæä¾›æ›´åŠ ä¾¿æ·çš„æ–¹æ³•æ¥å®ç°ç½‘ç»œè¯·æ±‚ã€‚ å®ç°.mæ–‡ä»¶12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef NSFoundationVersionNumber_iOS_8_0#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11#else#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0#endif//Cé™æ€å‡½æ•°ï¼ŒGCDåªæ‰§è¡Œä¸€æ¬¡ï¼Œç”¨äºåˆ›å»ºä¸€ä¸ªä¸²è¡Œé˜Ÿåˆ—æ¥æ‰§è¡Œå„ç§ç½‘ç»œè¯·æ±‚ä»»åŠ¡çš„åˆ›å»ºå·¥ä½œstatic dispatch_queue_t url_session_manager_creation_queue() &#123; static dispatch_queue_t af_url_session_manager_creation_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_creation_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.creation\", DISPATCH_QUEUE_SERIAL); &#125;); return af_url_session_manager_creation_queue;&#125;/*Cé™æ€å‡½æ•°ï¼Œç”¨äºæ‰§è¡Œåˆ›å»ºç½‘ç»œè¯·æ±‚ä»»åŠ¡çš„blockä¸»è¦ç›®çš„æ˜¯ä¸ºäº†è§£å†³ios8ä»¥ä¸‹å­˜åœ¨çš„ä¸€ä¸ªblockå’Œtaskä¸åŒ¹é…çš„bugä¸Šé¢é‚£ä¸ªé˜Ÿåˆ—ä¹Ÿæ˜¯ä¸ºäº†è§£å†³è¿™ä¸ªbugæ‰åˆ›å»ºçš„å…·ä½“å¯æŸ¥çœ‹Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093*/static void url_session_manager_create_task_safely(dispatch_block_t block) &#123; if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123; dispatch_sync(url_session_manager_creation_queue(), block); &#125; else &#123; block(); &#125;&#125;//Cé™æ€å‡½æ•°ï¼Œåˆ›å»ºä¸€ä¸ªå¹¶å‘é˜Ÿåˆ—ï¼Œç”¨äºåœ¨ç½‘ç»œè¯·æ±‚ä»»åŠ¡å®Œæˆåå¤„ç†æ•°æ®çš„ï¼Œå¹¶å‘é˜Ÿåˆ—å®ç°å¤šçº¿ç¨‹å¤„ç†å¤šä¸ªè¯·æ±‚å®Œæˆåçš„æ•°æ®å¤„ç†static dispatch_queue_t url_session_manager_processing_queue() &#123; static dispatch_queue_t af_url_session_manager_processing_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_processing_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.processing\", DISPATCH_QUEUE_CONCURRENT); &#125;); return af_url_session_manager_processing_queue;&#125;//Cé™æ€å‡½æ•°åˆ›å»ºä¸€ä¸ªdispatchçš„ç»„//ä½†åœ¨æ¥ä¸‹æ¥çš„æºç ä¸­å¹¶æ²¡æœ‰ä½¿ç”¨è¿™ä¸ªç»„æ¥å®ç°notifyç­‰åŠŸèƒ½ï¼Œä»…ä»…æ˜¯å°†blockå’Œç»„å…³è”äº†ï¼Œä¸å¤ªæ¸…æ¥šå…·ä½“ç”¨æ„//æœ‰æ˜ç™½çš„è¯»è€…è¿˜è¯·ä¸åèµæ•™static dispatch_group_t url_session_manager_completion_group() &#123; static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_completion_group = dispatch_group_create(); &#125;); return af_url_session_manager_completion_group;&#125;//ä¸€ç³»åˆ—é€šçŸ¥åç§°çš„å®šä¹‰NSString * const AFNetworkingTaskDidResumeNotification = @\"com.alamofire.networking.task.resume\";NSString * const AFNetworkingTaskDidCompleteNotification = @\"com.alamofire.networking.task.complete\";NSString * const AFNetworkingTaskDidSuspendNotification = @\"com.alamofire.networking.task.suspend\";NSString * const AFURLSessionDidInvalidateNotification = @\"com.alamofire.networking.session.invalidate\";NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification = @\"com.alamofire.networking.session.download.file-manager-error\";NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey = @\"com.alamofire.networking.task.complete.serializedresponse\";NSString * const AFNetworkingTaskDidCompleteResponseSerializerKey = @\"com.alamofire.networking.task.complete.responseserializer\";NSString * const AFNetworkingTaskDidCompleteResponseDataKey = @\"com.alamofire.networking.complete.finish.responsedata\";NSString * const AFNetworkingTaskDidCompleteErrorKey = @\"com.alamofire.networking.task.complete.error\";NSString * const AFNetworkingTaskDidCompleteAssetPathKey = @\"com.alamofire.networking.task.complete.assetpath\";//éœ€è¦ä½¿ç”¨çš„NSLocké”çš„åç§°static NSString * const AFURLSessionManagerLockName = @\"com.alamofire.networking.session.manager.lock\";//background sessioné‡è¯•åˆ›å»ºä¸Šä¼ ä»»åŠ¡æ¬¡æ•°static NSUInteger const AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = 3; å¯¹äºurl_session_manager_create_task_safelyè¿™ä¸ªæœ‰ä»€ä¹ˆç”¨ï¼Ÿå…¶å®è¿™ä¸ªæ˜¯è¢«å½“åšæ˜¯ä¸€ä¸ªåœ¨ios8ä»¥ä¸‹ï¼ŒNSURLSessionDataTaskå‡ºç°çš„ä¸€ä¸ªBugã€‚é—®é¢˜äº§ç”Ÿçš„åŸå› å°±æ˜¯å½“é˜Ÿåˆ—æ˜¯å¹¶å‘çš„ï¼Œè¿™æ˜¯å½“ä¸¤ä¸ªä»»åŠ¡åŒæ—¶åœ¨ä¸åŒçš„çº¿ç¨‹ä¸Šåˆ›å»ºä»»åŠ¡çš„æ—¶å€™taskIdentifierå¯èƒ½æ˜¯ä¸€æ ·çš„ã€‚å¤§è‡´çš„æ„æ€å°±æ˜¯å½“æˆ‘ä»¬åŒæ—¶åˆ›å»ºä¸¤ä¸ªä»»åŠ¡ï¼Œè¿”å›äº†é‡å¤çš„taskIdentifierï¼Œè¿™æ ·çš„è¯ç¬¬ä¸€ä¸ªè¢«åˆ›å»ºçš„completionHandlerå°±ä¼šè¢«æ¸…ç©ºï¼Œè¢«ç¬¬äºŒä¸ªä»»åŠ¡çš„completionHandlerç»™æ›¿æ¢ï¼Œå¦‚æœç¬¬ä¸€ä¸ªæ•°æ®æ˜¯æ—©äºç¬¬äºŒä¸ªæ•°æ®è¿”å›çš„ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªæ•°æ®è¿”å›ä¹‹åå°±ä¼šå»è°ƒç”¨ç¬¬äºŒä¸ªä»»åŠ¡çš„completionHandlerã€‚ 12345678910111213141516171819202122typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session, NSError *error);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef NSURLRequest * (^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request);typedef NSURLSessionAuthChallengeDisposition (^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential);typedef void (^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(NSURLSession *session);typedef NSInputStream * (^AFURLSessionTaskNeedNewBodyStreamBlock)(NSURLSession *session, NSURLSessionTask *task);typedef void (^AFURLSessionTaskDidSendBodyDataBlock)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend);typedef void (^AFURLSessionTaskDidCompleteBlock)(NSURLSession *session, NSURLSessionTask *task, NSError *error);typedef NSURLSessionResponseDisposition (^AFURLSessionDataTaskDidReceiveResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response);typedef void (^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask);typedef void (^AFURLSessionDataTaskDidReceiveDataBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data);typedef NSCachedURLResponse * (^AFURLSessionDataTaskWillCacheResponseBlock)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse);typedef NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);typedef void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);typedef void (^AFURLSessionDownloadTaskDidResumeBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes);typedef void (^AFURLSessionTaskProgressBlock)(NSProgress *);typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response, id responseObject, NSError *error); å®šä¹‰ä¸€äº›å›è°ƒçš„block 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248//å®šä¹‰äº†ä¸€ä¸ªç±»AFURLSessionManagerTaskDelegateå¹¶å®ç°äº†NSURLSessionTaskçš„ç›¸å…³åè®®//è¿™ä¸ªç±»æ˜¯ç”¨äºå¤„ç†NSURLSessionTaskç›¸å…³ä»£ç†æ–¹æ³•çš„@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;//åˆå§‹åŒ–æ„é€ å‡½æ•°ï¼Œéœ€è¦ä¼ å…¥ä¸€ä¸ªå…³è”çš„task- (instancetype)initWithTask:(NSURLSessionTask *)task;//weakä¿®é¥°çš„manager@property (nonatomic, weak) AFURLSessionManager *manager;//å¯å˜dataç”¨äºå­˜å‚¨è·å–åˆ°çš„ç½‘ç»œæ•°æ®@property (nonatomic, strong) NSMutableData *mutableData;//ä¸Šä¼ è¿›åº¦NSProgress@property (nonatomic, strong) NSProgress *uploadProgress;//ä¸‹è½½è¿›åº¦NSProgress@property (nonatomic, strong) NSProgress *downloadProgress;//ä¸‹è½½æ–‡ä»¶çš„NSURL@property (nonatomic, copy) NSURL *downloadFileURL;//ä¸‹è½½å®Œæˆçš„å›è°ƒå—@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;//ä¸Šä¼ è¿›åº¦çš„å›è°ƒå—@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;//ä¸‹è½½è¿›åº¦çš„å›è°ƒå—@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;//ç½‘ç»œè¯·æ±‚å®Œæˆçš„å›è°ƒå—@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;@end@implementation AFURLSessionManagerTaskDelegate//åˆå§‹åŒ–æ„é€ å‡½æ•°- (instancetype)initWithTask:(NSURLSessionTask *)task &#123; self = [super init]; if (!self) &#123; return nil; &#125; _mutableData = [NSMutableData data]; _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; //éå†ä¸¤ä¸ªä¸Šä¼ å’Œä¸‹è½½NSProgressè®¾ç½®ä¸€äº›å±æ€§ __weak __typeof__(task) weakTask = task; for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ]) &#123; //åˆå§‹åŒ–progress progress.totalUnitCount = NSURLSessionTransferSizeUnknown; progress.cancellable = YES; //è®¾ç½®å–æ¶ˆè¿›åº¦çš„å›è°ƒå—ï¼Œæ‰§è¡Œtaskçš„cancelæ–¹æ³• progress.cancellationHandler = ^&#123; [weakTask cancel]; &#125;; progress.pausable = YES; //è®¾ç½®æš‚åœè¿›åº¦çš„å›è°ƒå—ï¼Œæ‰§è¡Œtaskçš„suspendæ–¹æ³• progress.pausingHandler = ^&#123; [weakTask suspend]; &#125;; //è®¾ç½®é‡æ–°å¼€å§‹çš„å›è°ƒå—ï¼Œæ‰§è¡Œtaskçš„resumeæ–¹æ³• if ([progress respondsToSelector:@selector(setResumingHandler:)]) &#123; progress.resumingHandler = ^&#123; [weakTask resume]; &#125;; &#125; //progressæ·»åŠ kvoï¼Œç›‘å¬progressçš„è¿›åº¦fractionCompleted [progress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; &#125; return self;&#125;//ææ„å‡½æ•°- (void)dealloc &#123; //åˆ é™¤KVO [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];&#125;#pragma mark - NSProgress Tracking//KVOå›è°ƒæ–¹æ³•- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; //ä¸Šæ¬¡æˆ–ä¸‹è½½è¿›åº¦æœ‰æ”¹å˜æ—¶ï¼Œæ‰§è¡Œä¸Šä¼ æˆ–ä¸‹è½½è¿›åº¦å›è°ƒå— if ([object isEqual:self.downloadProgress]) &#123; if (self.downloadProgressBlock) &#123; self.downloadProgressBlock(object); &#125; &#125; else if ([object isEqual:self.uploadProgress]) &#123; if (self.uploadProgressBlock) &#123; self.uploadProgressBlock(object); &#125; &#125;&#125;#pragma mark - NSURLSessionTaskDelegate//ä»£ç†æ–¹æ³•ï¼Œç½‘ç»œè¯·æ±‚å®Œæˆæˆ–å‡ºé”™- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //managerç”¨weakä¿®é¥°ï¼Œè¿™é‡Œstrongä¸€ä¸‹é˜²æ­¢managerè¢«é‡Šæ”¾ __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; //ä¸ºuserInfoå­—å…¸è®¾ç½®å“åº”åºåˆ—åŒ– userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 //èµ‹å€¼mutableDataåˆ°dataä¸­ï¼Œå¹¶é‡Šæ”¾mutableData NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; &#125; //å¦‚æœdownloadFileURLå­˜åœ¨ï¼Œå³æ˜¯ä¸‹è½½ä»»åŠ¡å°±è®¾ç½®ä¸‹è½½å®Œæˆåçš„æ–‡ä»¶å­˜å‚¨urlåˆ°å­—å…¸ä¸­ if (self.downloadFileURL) &#123; userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; &#125; else if (data) &#123; //å¦åˆ™å°±è®¾ç½®å¯¹åº”çš„NSDataæ•°æ®åˆ°å­—å…¸ä¸­ userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; &#125; //å¦‚æœç½‘ç»œè¯·æ±‚æœ‰é”™è¯¯ if (error) &#123; //è®¾ç½®errorä¿¡æ¯åˆ°å­—å…¸ä¸­ userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; /* è¿™ä¸ªä¸‰ç›®è¿ç®—ç¬¦éœ€è¦è§£é‡Šä¸€ä¸‹ï¼Œåœ¨å…¶ä»–è¯­è¨€ä¸­è¿™ä¹ˆå†™å¾ˆå¯èƒ½å°±æ˜¯è¯­æ³•é”™è¯¯ è¿™é‡Œçš„æ„æ€å°±æ˜¯å¦‚æœmanager.completionGroupå­˜åœ¨å°±ä½¿ç”¨å®ƒ ä¸å­˜åœ¨å°±ä½¿ç”¨url_session_manager_completion_groupå‡½æ•°è¿”å›çš„group åé¢çš„ä¸‰ç›®è¿ç®—ç¬¦åŒç† æ‰€ä»¥å¦‚æœè‡ªå·±ä¸è®¾ç½®managerçš„completionGroupæˆ–completionQueueå°±ä¼šä½¿ç”¨é»˜è®¤æä¾›çš„ */ //æ‰§è¡Œå¯¹åº”çš„completionHandlerå›è°ƒå— dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, error); &#125; //åœ¨ä¸»é˜Ÿåˆ—å³ä¸»çº¿ç¨‹ä¸­å‘é€é€šçŸ¥ dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125; else &#123; //å¦‚æœç½‘ç»œä»»åŠ¡æˆåŠŸå®Œæˆï¼Œå¼‚æ­¥åœ¨å¹¶å‘é˜Ÿåˆ—ä¸­æ‰§è¡Œæ•°æ®å¤„ç† dispatch_async(url_session_manager_processing_queue(), ^&#123; //åºåˆ—åŒ–å“åº”æ•°æ® NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; //å¦‚æœæ˜¯ä¸‹è½½ä»»åŠ¡è®¾ç½®å“åº”æ•°æ®ä¸ºæ–‡ä»¶çš„url if (self.downloadFileURL) &#123; responseObject = self.downloadFileURL; &#125; //å¦‚æœå“åº”å¯¹è±¡åºåˆ—åŒ–æˆåŠŸæˆ–æ˜¯æ–‡ä»¶urlå°±è®¾ç½®ç›¸å…³å­—å…¸key-value if (responseObject) &#123; userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; &#125; //å¦‚æœåºåˆ—åŒ–å‡ºé”™ï¼Œè®¾ç½®ç›¸å…³å­—å…¸å€¼ if (serializationError) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; &#125; //åŒç†ï¼Œåœ¨dispatchç»„ä¸­å’Œç‰¹å®šé˜Ÿåˆ—æ‰§è¡Œå›è°ƒå— dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; //ä¸»çº¿ç¨‹å‘é€é€šçŸ¥ dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); &#125;&#125;#pragma mark - NSURLSessionDataDelegate//å›è°ƒæ–¹æ³•ï¼Œæ”¶åˆ°æ•°æ®- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //è®¾ç½®ä¸‹è½½è¿›åº¦çš„ç›¸å…³å±æ€§ self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive; self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived; //æ·»åŠ æ•°æ®åˆ°mutableData [self.mutableData appendData:data];&#125;//ä¸Šä¼ ä»»åŠ¡çš„å›è°ƒæ–¹æ³•- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //è®¾ç½®ä¸Šä¼ è¿›åº¦çš„ç›¸å…³å±æ€§ self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.uploadProgress.completedUnitCount = task.countOfBytesSent;&#125;#pragma mark - NSURLSessionDownloadDelegate//ä¸‹è½½ä»»åŠ¡çš„å›è°ƒæ–¹æ³•//ç”±äºNSURLSessionçš„downloadTaskç›´æ¥å°†æ–‡ä»¶ä¸‹è½½åˆ°ç£ç›˜æ²™ç›’ä¸­ï¼Œæ‰€ä»¥ä¸éœ€è¦mutableDataè‡ªè¡Œæ¥æ”¶æ•°æ®- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //è®¾ç½®ä¸‹è½½è¿›åº¦çš„ç›¸å…³å±æ€§ self.downloadProgress.totalUnitCount = totalBytesExpectedToWrite; self.downloadProgress.completedUnitCount = totalBytesWritten;&#125;//æ¢å¤ä¸‹è½½ä»»åŠ¡çš„å›è°ƒæ–¹æ³•- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; //è®¾ç½®ä¸‹è½½è¿›åº¦çš„ç›¸å…³å±æ€§ self.downloadProgress.totalUnitCount = expectedTotalBytes; self.downloadProgress.completedUnitCount = fileOffset;&#125;//ä¸‹è½½ä»»åŠ¡ä¸‹è½½æ–‡ä»¶å®Œæˆåçš„å›è°ƒæ–¹æ³•//locationå°±æ˜¯æ–‡ä»¶ä¸‹è½½åˆ°ç£ç›˜æ²™ç›’ç›®å½•çš„NSURL- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //è®¾ç½®downloadFileURLä¸ºnil self.downloadFileURL = nil; //å¦‚æœæœ‰ä¸‹è½½å®Œæˆçš„å›è°ƒå— if (self.downloadTaskDidFinishDownloading) &#123; //æ‰§è¡Œè¯¥å›è°ƒå—ï¼Œè¿™ä¸ªå›è°ƒå—è¿”å›ä¸€ä¸ªä¸‹è½½çš„æ–‡ä»¶ä¿å­˜çš„è·¯å¾„URL //é»˜è®¤ä¿å­˜åœ¨æ²™ç›’tmpæ–‡ä»¶ä¸­ï¼Œå¯èƒ½ä¼šè¢«åˆ é™¤ï¼Œéœ€è¦æŒä¹…åŒ–æ—¶è¦è‡ªå·±è®¾ç½®ä¸€ä¸ªç›®å½•å­˜å‚¨ self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //å¦‚æœéœ€è¦ç§»åŠ¨æ–‡ä»¶çš„è·¯å¾„ä½¿ç”¨NSFileManaegrç§»åŠ¨ if (self.downloadFileURL) &#123; NSError *fileManagerError = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]) &#123; //æ–‡ä»¶ç§»åŠ¨å‘ç”Ÿé”™è¯¯å‘é€é€šçŸ¥ [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; &#125; &#125; &#125;&#125;@end AFURLSessionManagerTaskDelegateçš„æºç ï¼Œä¸»è¦å°±æ˜¯å…³è”ä¸€ä¸ªNSURLSessionTaskå¹¶å®ç°äº†ç›¸å…³ä»»åŠ¡çš„ä»£ç†æ–¹æ³•ç”¨äºæ•°æ®çš„è·å–ã€ä¸Šä¼ æ–‡ä»¶å’Œä¸‹è½½æ–‡ä»¶ã€‚éœ€è¦æ³¨æ„çš„æ˜¯NSURLSessionTaskçš„delegateå±æ€§æ˜¯åªè¯»çš„ï¼Œåªèƒ½åœ¨ä½¿ç”¨sessionåˆ›å»ºtaskçš„å‡½æ•°ä¸­ä¼ å…¥ä»£ç†å¯¹è±¡ï¼Œè€Œä¸”é€šè¿‡æºç ä¹Ÿæ²¡æœ‰å‘ç°ç›¸å…³ä»£ç†çš„è®¾ç½®ï¼Œæ‰€ä»¥AFURLSessionManagerTaskDelegateç±»å®ç°ç›¸å…³ä»£ç†æ˜¯ä¸ºäº†å…¶ä»–ç±»æ‰‹åŠ¨è°ƒç”¨ç›¸å…³æ–¹æ³•ï¼ŒAFURLSessionManagerä¹Ÿå®ç°äº†è¿™äº›ä»£ç†ï¼Œæ‰€ä»¥å…·ä½“çš„è°ƒç”¨æ˜¯ç”±AFURLSessionMangeræ‰‹åŠ¨è§¦å‘çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(theClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123; return class_addMethod(theClass, selector, method_getImplementation(method), method_getTypeEncoding(method));&#125;static NSString * const AFNSURLSessionTaskDidResumeNotification = @\"com.alamofire.networking.nsurlsessiontask.resume\";static NSString * const AFNSURLSessionTaskDidSuspendNotification = @\"com.alamofire.networking.nsurlsessiontask.suspend\";@interface _AFURLSessionTaskSwizzling : NSObject@end@implementation _AFURLSessionTaskSwizzling+ (void)load &#123; /** WARNING: Trouble Ahead https://github.com/AFNetworking/AFNetworking/pull/2702 */ if (NSClassFromString(@\"NSURLSessionTask\")) &#123; /** iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky. Many Unit Tests have been built to validate as much of this behavior has possible. Here is what we know: - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn't actually the type of class you will get back. - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there. - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`. - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`. - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled. - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled. - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there. Some Assumptions: - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we'd need to handle it. - No background task classes override `resume` or `suspend` The current solution: 1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task. 2) Grab a pointer to the original implementation of `af_resume` 3) Check to see if the current class has an implementation of resume. If so, continue to step 4. 4) Grab the super class of the current class. 5) Grab a pointer for the current class to the current implementation of `resume`. 6) Grab a pointer for the super class to the current implementation of `resume`. 7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods 8) Set the current class to the super class, and repeat steps 3-8 */ NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];#pragma GCC diagnostic push#pragma GCC diagnostic ignored \"-Wnonnull\" NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];#pragma clang diagnostic pop IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume))); Class currentClass = [localDataTask class]; while (class_getInstanceMethod(currentClass, @selector(resume))) &#123; Class superClass = [currentClass superclass]; IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume))); IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume))); if (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; [self swizzleResumeAndSuspendMethodForClass:currentClass]; &#125; currentClass = [currentClass superclass]; &#125; [localDataTask cancel]; [session finishTasksAndInvalidate]; &#125;&#125;+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123; Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume)); Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend)); if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123; af_swizzleSelector(theClass, @selector(resume), @selector(af_resume)); &#125; if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123; af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend)); &#125;&#125;- (NSURLSessionTaskState)state &#123; NSAssert(NO, @\"State method should never be called in the actual dummy class\"); return NSURLSessionTaskStateCanceling;&#125;- (void)af_resume &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_resume]; if (state != NSURLSessionTaskStateRunning) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self]; &#125;&#125;- (void)af_suspend &#123; NSAssert([self respondsToSelector:@selector(state)], @\"Does not respond to state\"); NSURLSessionTaskState state = [self state]; [self af_suspend]; if (state != NSURLSessionTaskStateSuspended) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self]; &#125;&#125;@end è¿™é‡Œç”¨åˆ°äº†method-swizzlingçš„æŠ€æœ¯ï¼Œäº¤æ¢äº† resume å’Œ suspendæ–¹æ³•çš„å®ç°ï¼Œå› ä¸ºiOS7å’ŒiOS8ä¸­NSURLSessionTaskçš„çˆ¶ç±»ä¸åŒï¼Œéœ€è¦åšä¸€äº›å¤„ç†ï¼ˆå‘é€taskæš‚åœã€ç»§ç»­é€šçŸ¥ï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233@interface AFURLSessionManager ()//ç®¡ç†çš„sessionè¿è¡Œæ¨¡å¼ï¼Œé»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨é»˜è®¤è¿è¡Œæ¨¡å¼ï¼ŒdefaultConfiguration@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;/*NSOperationé˜Ÿåˆ—ï¼Œä»£ç†æ–¹æ³•æ‰§è¡Œçš„é˜Ÿåˆ—.hæ–‡ä»¶é‡Œæ˜¯readonlyï¼Œæ‰€ä»¥è¿™é‡Œå®šä¹‰ä¸€ä¸ªreadwriteç”¨äºèµ‹å€¼*/@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;//ç®¡ç†çš„sessionï¼Œreadwrite@property (readwrite, nonatomic, strong) NSURLSession *session;//å¯å˜å­—å…¸ï¼Œkeyæ˜¯NSURLSessionTaskçš„å”¯ä¸€NSUIntegerç±»å‹æ ‡è¯†ï¼Œvalueæ˜¯å¯¹åº”çš„AFURLSessionManagerTaskDelgateå¯¹è±¡@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;//åªè¯»å±æ€§ï¼Œé€šè¿‡getterè¿”å›æ•°æ®@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;//NSLocké”@property (readwrite, nonatomic, strong) NSLock *lock;//ä¸‹é¢æ˜¯ä¸€ç³»åˆ—å›è°ƒå—@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;@end å»¶å±•é‡Œé¢å®šä¹‰äº†ä¸€äº›å±æ€§å’Œå“åº”çš„å›è°ƒblockã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation AFURLSessionManager//æ„é€ å‡½æ•°- (instancetype)init &#123; return [self initWithSessionConfiguration:nil];&#125;//æ„é€ å‡½æ•°- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; //å¦‚æœæ²¡æœ‰æŒ‡å®šsessionè¿è¡Œæ¨¡å¼å°±ä½¿ç”¨é»˜è®¤çš„ if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; //åˆ›å»ºä»£ç†æ–¹æ³•æ‰§è¡Œçš„é˜Ÿåˆ—ï¼Œæœ€å¤§å¹¶å‘æ•°ä¸º1ï¼Œå³ä¸²è¡Œé˜Ÿåˆ— //æ„Ÿè§‰è¿™é‡Œè®¾ç½®ä¸º1æ˜¯ä¸ºäº†è®©å›è°ƒä¸€ä¸ªä¸ªæ‰§è¡Œ self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; //åˆ›å»ºsessionï¼Œæ³¨æ„ä»£ç†å¯¹è±¡æ˜¯self self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; //åˆ›å»ºå“åº”åºåˆ—åŒ–å™¨ self.responseSerializer = [AFJSONResponseSerializer serializer]; //è®¾ç½®é»˜è®¤å®‰å…¨ç­–ç•¥ self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH //è·å–ç½‘ç»œå¯è¾¾æ€§manager self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; //åˆ›å»ºé” self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* è·å–sessionä¸­çš„ä»»åŠ¡ï¼Œå¹¶è°ƒç”¨ç›¸å…³æ–¹æ³•å…³è”AFURLSessionManagerTaskDelegate ä¸å¤ªæ˜ç™½è¿™é‡Œä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšï¼Œåˆšåˆ›å»ºçš„sessionåº”è¯¥æ²¡æœ‰ä»»ä½•ä»»åŠ¡åœ¨æ‰§è¡Œ */ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self;&#125;//ææ„æ–¹æ³•ï¼Œç§»é™¤æ‰€æœ‰é€šçŸ¥ç›‘å¬- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; åˆå§‹åŒ–æ–¹æ³•é‡Œé¢æœ‰ä¸€ä¸ªæœ‰ä¸€ä¸ªä¸æ˜ç™½çš„ç‚¹ï¼Œåˆ›å»ºå®Œsessionä¹‹åå°±å»è·å–å®ƒæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼Œåˆšåˆ›å»ºå®Œsessionä¸ºä½•ä¼šæœ‰ä»»åŠ¡å‘¢ï¼Ÿè¿™æ˜¯ä¸ºäº†é˜²æ­¢åå°å›æ¥ï¼Œé‡æ–°åˆå§‹åŒ–è¿™ä¸ªsessionï¼Œä¸€äº›ä¹‹å‰çš„åå°è¯·æ±‚ä»»åŠ¡ï¼Œå¯¼è‡´ç¨‹åºçš„crashã€‚ 1234567891011121314151617181920212223242526272829//taskDescriptionForSessionTaskså±æ€§çš„getterï¼Œè¿”å›åœ°å€çš„å­—ç¬¦ä¸²å½¢å¼æ•°æ®ï¼Œå¯ä»¥ä¿è¯è¿™ä¸ªå­—ç¬¦ä¸²æ˜¯å”¯ä¸€çš„- (NSString *)taskDescriptionForSessionTasks &#123; return [NSString stringWithFormat:@\"%p\", self];&#125;//é€šçŸ¥çš„å›è°ƒæ–¹æ³•ï¼Œæ¥ä¸‹æ¥çš„ä»£ç ä¼šæ·»åŠ ç›¸å…³é€šçŸ¥- (void)taskDidResume:(NSNotification *)notification &#123; //å‘é€é€šçŸ¥çš„æ—¶å€™ä¼šå°†taskæ·»åŠ è¿›é€šçŸ¥ä¸­ NSURLSessionTask *task = notification.object; //åˆ¤æ–­è¿™ä¸ªä»»åŠ¡æ˜¯å¦æ˜¯å½“å‰managerç®¡ç†çš„ï¼Œå¦‚æœæ˜¯å°±å‘é€ç›¸å…³é€šçŸ¥ //taskçš„taskDescriptionå±æ€§åœ¨ä¸‹æ–‡çš„æºç ä¸­ä¼šè®¾ç½® if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task]; &#125;); &#125; &#125;&#125;//åŒä¸Š- (void)taskDidSuspend:(NSNotification *)notification &#123; NSURLSessionTask *task = notification.object; if ([task respondsToSelector:@selector(taskDescription)]) &#123; if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task]; &#125;); &#125; &#125;&#125; ä¸Šé¢çš„ä»£ç å°±æ˜¯é€šçŸ¥çš„å›è°ƒæ–¹æ³•ï¼Œç”¨äºé€šçŸ¥resumeå’Œsuspendäº‹ä»¶ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//æ ¹æ®taskè·å–ç›¸å…³è”çš„AFURLSessionManagerTaskDelegateå¯¹è±¡- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123; //taskä¸èƒ½ä¸ºç©º NSParameterAssert(task); //ä¸Šé”ï¼Œé€šè¿‡taskçš„å”¯ä¸€taskIdentifierä»å­—å…¸ä¸­å–å€¼ï¼Œè¿™ä¸ªå”¯ä¸€æ ‡è¯†æ˜¯åœ¨åˆ›å»ºtaskçš„æ—¶å€™NSURLSessionTaskä¸ºå…¶è®¾ç½®çš„ï¼Œä¸éœ€è¦æ‰‹åŠ¨è®¾ç½®ï¼Œä¿è¯å”¯ä¸€æ€§ AFURLSessionManagerTaskDelegate *delegate = nil; [self.lock lock]; delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate;&#125;//ä¸ºtaskè®¾ç½®å…³è”çš„delegate- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; //taskå’Œdelegateéƒ½ä¸èƒ½ä¸ºç©º NSParameterAssert(task); NSParameterAssert(delegate); //ä¸Šé”ï¼Œå‘å­—å…¸ä¸­æ·»åŠ key-valueå¯¹ [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125;//é‡ç‚¹æ–¹æ³•ï¼Œä¸ºdataTaskåˆ›å»ºä¸€ä¸ªå…³è”çš„AFURLSessionManagerTaskDelegateå¯¹è±¡- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; //åˆ›å»ºAFURLSessionManagerTaskDelegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; //è®¾ç½®ç›¸å…³å±æ€§ delegate.manager = self; delegate.completionHandler = completionHandler; /* è®¾ç½®taskçš„taskDescriptionï¼Œæ³¨æ„å’ŒtaskIdentifieråŒºåˆ† taskDescriptionæ˜¯å¼€å‘è€…è‡ªè¡Œè®¾ç½®çš„ taskIdentifieræ˜¯NSURLSessionTaskè®¾ç½®çš„ï¼Œä¿è¯æ¯ä¸€ä¸ªtaskçš„idä¸åŒ è¿™é‡Œè®¾ç½®çš„taskDescriptionå°±æ˜¯AFURLSessionManagerçš„åœ°å€ æ‰€ä»¥åŒä¸€ä¸ªmanageråˆ›å»ºçš„taskçš„descriptionéƒ½æ˜¯ä¸€è‡´çš„ è®¾ç½®è¿™ä¸ªå€¼çš„ç›®çš„å°±æ˜¯ä¸ºäº†åŒºåˆ†taskæ˜¯å¦æ˜¯å½“å‰mangeråˆ›å»ºçš„ */ dataTask.taskDescription = self.taskDescriptionForSessionTasks; //è°ƒç”¨ä¸Šé¢çš„æ–¹æ³•å°†task-delegateé”®å€¼å¯¹æ·»åŠ è¿›å­—å…¸ä¸­ [self setDelegate:delegate forTask:dataTask]; //è®¾ç½®å›è°ƒå— delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//åŒä¸Šï¼Œåˆ›å»ºä¸Šä¼ ä»»åŠ¡çš„AFURLSessionManagerTaskDelegateå¯¹è±¡ï¼Œå¹¶åŠ å…¥åˆ°å­—å…¸ä¸­- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; uploadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:uploadTask]; delegate.uploadProgressBlock = uploadProgressBlock;&#125;//åŒä¸Šï¼Œåˆ›å»ºä¸‹è½½æ–‡ä»¶ä»»åŠ¡çš„AFURLSessionManagerTaskDelegateå¯¹è±¡ï¼Œå¹¶åŠ å…¥åˆ°å­—å…¸ä¸­- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; /* éœ€è¦æ³¨æ„ä¸‹ï¼ŒAFURLSessionManagerTaskDelegateä¸­ä¸‹è½½æ–‡ä»¶å®Œæˆåä¼šè°ƒç”¨delegate.downloadTaskDidFinishDownloadingå›è°ƒå— æ¥è·å–ä¸‹è½½æ–‡ä»¶è¦ç§»åŠ¨åˆ°çš„ç›®å½•URL æ‰€ä»¥è¿™é‡Œå°±æ˜¯åˆ›å»ºè¿™ä¸ªå›è°ƒå—ï¼Œç›´æ¥è¿”å›å‚æ•°ä¸­çš„destinationå›è°ƒå— */ if (destination) &#123; delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123; return destination(location, task.response); &#125;; &#125; downloadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:downloadTask]; delegate.downloadProgressBlock = downloadProgressBlock;&#125;//ä»å­—å…¸ä¸­åˆ é™¤taskå¯¹åº”çš„delegateçš„key-valueå¯¹- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); [self.lock lock]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; ä¸Šé¢çš„ä»£ç å°±æ˜¯å¯¹AFURLSessionManagerTaskDelegateçš„åˆ›å»ºã€æ·»åŠ è¿›å­—å…¸ã€åˆ é™¤ã€è·å–çš„æ“ä½œï¼Œè¿™æ ·å°±å®ç°äº†æ¯ä¸€ä¸ªNSURLSessionTaskå¯¹åº”ä¸€ä¸ªAFURLSessionManagerTaskDelegateå¯¹è±¡ï¼Œå¯èƒ½è¯»è€…ä¼šæœ‰ç–‘é—®ï¼ŒAFURLSessionManageræ—¢ç„¶å·²ç»å®ç°äº†ä»£ç†çš„æ–¹æ³•ï¼Œä¸ºä»€ä¹ˆä¸ç›´æ¥ä½¿ç”¨å®ƒæ¥å¤„ç†ä»£ç†æ–¹æ³•ï¼Œä¸ºä»€ä¹ˆè¦åˆ›å»ºä¸€ä¸ªç±»æ¥ä¸“é—¨å¤„ç†ï¼Œç»§ç»­çœ‹å®Œæºç å¯èƒ½ä½ å°±ä¼šæ˜ç™½äº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//æ ¹æ®keyPathè·å–ä¸åŒç±»å‹ä»»åŠ¡çš„é›†åˆ- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray *tasks = nil; //åˆ›å»ºä¸€ä¸ªä¿¡å·é‡ï¼Œå€¼æ˜¯0 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); //è¿™ä¸ªæ–¹æ³•æ˜¯å¼‚æ­¥çš„ï¼Œæ‰€ä»¥ä¸ºäº†åŒæ­¥è¿”å›ç»“æœï¼Œéœ€è¦ä½¿ç”¨é”ï¼Œä¿¡å·é‡å€¼è®¾ç½®ä¸º0æˆ–è€…1æ—¶å°±å¯ä»¥å½“é”æ¥ä½¿ç”¨äº† [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks = dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks = uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks = downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@\"@unionOfArrays.self\"]; &#125; //signalé€šçŸ¥ä¿¡å·é‡ï¼Œä¿¡å·é‡å€¼åŠ 1 dispatch_semaphore_signal(semaphore); &#125;]; //ç­‰å¾…ä¿¡å·é‡ï¼Œç›´åˆ°å€¼å¤§äº0ï¼Œç­‰å¾…æ—¶é—´æ˜¯forever dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125;//ä¸‹é¢æ˜¯tasksã€dataTasksã€uploadTasksã€downloadTaskså±æ€§çš„getterï¼Œéƒ½æ˜¯è°ƒç”¨ä¸Šè¿°æ–¹æ³•æ¥è·å–å¯¹åº”ç±»å‹çš„ä»»åŠ¡é›†åˆ- (NSArray *)tasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)dataTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)uploadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;- (NSArray *)downloadTasks &#123; return [self tasksForKeyPath:NSStringFromSelector(_cmd)];&#125;#pragma mark -//è®¾ç½®sessionæ— æ•ˆï¼Œæ ¹æ®å‚æ•°åˆ¤æ–­æ˜¯å¦éœ€è¦å–æ¶ˆæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks &#123; //è°ƒç”¨NSURLSessionå¯¹åº”çš„æ–¹æ³•æ¥è®¾ç½®sessionæ— æ•ˆï¼ŒåŒæ—¶æ‰“ç ´å¼•ç”¨å¾ªç¯ if (cancelPendingTasks) &#123; [self.session invalidateAndCancel]; &#125; else &#123; [self.session finishTasksAndInvalidate]; &#125;&#125;#pragma mark -//responseSerializerçš„setter- (void)setResponseSerializer:(id &lt;AFURLResponseSerialization&gt;)responseSerializer &#123; NSParameterAssert(responseSerializer); _responseSerializer = responseSerializer;&#125;#pragma mark -//æ·»åŠ é€šçŸ¥ï¼ŒtaskDidResumeã€taskDidSuspendæ–¹æ³•å‰é¢è®²è¿‡äº†- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];&#125;//åˆ é™¤é€šçŸ¥- (void)removeNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidSuspendNotification object:task]; [[NSNotificationCenter defaultCenter] removeObserver:self name:AFNSURLSessionTaskDidResumeNotification object:task];&#125; ä¸Šé¢çš„æ–¹æ³•æ˜¯ä¸€äº›getterå’Œsetterï¼Œå¾ˆç®€å•ï¼Œä¸å†èµ˜è¿°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//åˆ›å»ºå¹¶è¿”å›NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];&#125;//åˆ›å»ºå¹¶è¿”å›NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; //ä¸ºäº†è§£å†³iOS8ä¸€ä¸‹çš„ä¸€ä¸ªbugï¼Œè°ƒç”¨ä¸€ä¸ªä¸²è¡Œé˜Ÿåˆ—æ¥åˆ›å»ºdataTask __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^&#123; //ä½¿ç”¨sessionæ¥åˆ›å»ºä¸€ä¸ªNSURLSessionDataTaskå¯¹è±¡ dataTask = [self.session dataTaskWithRequest:request]; &#125;); //ä¸ºè¿™ä¸ªtaskåˆ›å»ºä¸€ä¸ªAFURLSessionManagerTaskDelegateå¹¶å…³è”åŠ å…¥å­—å…¸ä¸­ [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125;#pragma mark -//åˆ›å»ºä¸€ä¸ªNSURLSessionUploadTaskå¯¹è±¡- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125;); // uploadTask may be nil on iOS7 because uploadTaskWithRequest:fromFile: may return nil despite being documented as nonnull (https://devforums.apple.com/message/926113#926113) //è§£å†³iOS7çš„ä¸€ä¸ªbugæŒ‰ç…§é…ç½®çš„å°è¯•æ¬¡æ•°åˆ›å»ºä¸Šä¼ ä»»åŠ¡ï¼Œé»˜è®¤å°è¯•3æ¬¡ if (!uploadTask &amp;&amp; self.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; self.session.configuration.identifier) &#123; for (NSUInteger attempts = 0; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125; &#125; //åˆ›å»ºå…³è”çš„delegateå¹¶æ·»åŠ åˆ°å­—å…¸ä¸­ [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//åŒä¸Š- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;//åŒä¸Š- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;#pragma mark -//åˆ›å»ºä¸‹è½½ä»»åŠ¡ï¼ŒåŒä¸Š- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithRequest:request]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125;//åˆ›å»ºä¸‹è½½ä»»åŠ¡ï¼ŒåŒä¸Š- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithResumeData:resumeData]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125; ä¸Šé¢çš„æ–¹æ³•å°±æ˜¯AFURLSessionManagerä¸ºæˆ‘ä»¬æä¾›çš„è·å–NSURLSessionDataTaskã€NSURLSessionUploadTaskå’ŒNSURLSessionDownloadTaskçš„æ–¹æ³•ï¼Œä¸Šé¢è¿™äº›æ–¹æ³•ä¸»è¦ç›®çš„å°±æ˜¯ä¼ å…¥è¿›åº¦æˆ–å®Œæˆå›è°ƒå—ï¼Œç„¶åæ„é€ ä¸€ä¸ªAFURLSessionManagerTaskDeleagteå¯¹è±¡å¹¶å…³è”ï¼Œè¿™æ ·å°±ä¸éœ€è¦å¼€å‘è€…è‡ªè¡Œå®ç°å’Œç®¡ç†ä»£ç†æ–¹æ³•åšç›¸å…³æ•°æ®å¤„ç†ï¼Œåªéœ€è¦åœ¨å›è°ƒå—ä¸­åšå¤„ç†å³å¯ã€‚ æ¥ä¸‹æ¥æºç ä¸­æ˜¯ä¸€ç³»åˆ—å›è°ƒå—çš„setteræ–¹æ³•ï¼Œå°±ä¸åˆ—ä¸‹æ¥äº†ï¼Œè¯»è€…å¯ä»¥è‡ªå·±çœ‹çœ‹ã€‚æ¥ä¸‹æ¥å°±è®²è§£é‡ç‚¹çš„å„ç§ä»£ç†çš„å›è°ƒæ–¹æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445//sessionæ— æ•ˆåçš„å›è°ƒæ–¹æ³•- (void)URLSession:(NSURLSession *)sessiondidBecomeInvalidWithError:(NSError *)error&#123; //å¦‚æœå›è°ƒå—å­˜åœ¨å°±æ‰§è¡Œå›è°ƒå— if (self.sessionDidBecomeInvalid) &#123; self.sessionDidBecomeInvalid(session, error); &#125; //å‘é€å¯¹åº”é€šçŸ¥ [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];&#125;//æ”¶åˆ°æœåŠ¡ç«¯çš„challengeï¼Œä¾‹å¦‚httpséœ€è¦éªŒè¯è¯ä¹¦ç­‰- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; //å¦‚æœæœ‰å¯¹åº”å›è°ƒå—å°±æ‰§è¡Œ if (self.sessionDidReceiveAuthenticationChallenge) &#123; disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; //å¤„ç†https if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125; ä¸Šé¢ä¸¤ä¸ªæ–¹æ³•æ˜¯NSURLSessionDelegateçš„æ–¹æ³•ï¼Œå…³äºéªŒè¯HTTPSçš„éƒ¨åˆ†ä»£ç å¯ä»¥å½“åšæ¨¡æ¿ä»£ç æ¥å†™ï¼Œå…·ä½“å†…å®¹ä¸æ˜¯æœ¬æ–‡è®²è§£èŒƒç•´ï¼Œè¯»è€…å¯è‡ªè¡ŒæŸ¥é˜…ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//è¦æ‰§è¡Œé‡å®šå‘çš„ä»£ç†æ–¹æ³•- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskwillPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler&#123; //å¥—è·¯å°±æ˜¯æ‰§è¡Œç”¨æˆ·è‡ªå®šä¹‰çš„å›è°ƒå—ï¼Œæ‰§è¡Œå®Œæˆå›è°ƒå— NSURLRequest *redirectRequest = request; if (self.taskWillPerformHTTPRedirection) &#123; redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request); &#125; if (completionHandler) &#123; completionHandler(redirectRequest); &#125;&#125;//åŒå‰é¢ä¸€æ ·ï¼Œå¤„ç†httpsé“¾æ¥- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (self.taskDidReceiveAuthenticationChallenge) &#123; disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential); &#125; else &#123; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125;//å¤„ç†éœ€è¦ä¸€ä¸ªæ–°çš„æµ- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler&#123; //è°ƒç”¨ç”¨æˆ·è‡ªå®šä¹‰çš„å›è°ƒå—æ¥è·å–ï¼Œæˆ–è€…copyä¸€ä¸ª NSInputStream *inputStream = nil; if (self.taskNeedNewBodyStream) &#123; inputStream = self.taskNeedNewBodyStream(session, task); &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123; inputStream = [task.originalRequest.HTTPBodyStream copy]; &#125; if (completionHandler) &#123; completionHandler(inputStream); &#125;&#125;//ä¸Šä¼ ä»»åŠ¡çš„å›è°ƒæ–¹æ³•- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; //è·å–ä¸Šä¼ çš„æ€»å¤§å°ï¼Œå¦‚æœæ•°æ®ä¸æ­£ç¡®å°±ä»httpé¦–éƒ¨ä¸­è·å– int64_t totalUnitCount = totalBytesExpectedToSend; if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123; NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@\"Content-Length\"]; if(contentLength) &#123; totalUnitCount = (int64_t) [contentLength longLongValue]; &#125; &#125; //è·å–taskå…³è”çš„AFURLSessionManagerTaskDelegateå¯¹è±¡ AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; //å¦‚æœä»£ç†å¯¹è±¡å­˜åœ¨ï¼Œå°±è°ƒç”¨ä»£ç†å¯¹è±¡çš„è¿™ä¸ªæ–¹æ³• if (delegate) &#123; [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend]; &#125; //å¦‚æœç”¨æˆ·è‡ªå®šä¹‰å›è°ƒå—å­˜åœ¨ï¼Œæ‰§è¡Œå›è°ƒå— if (self.taskDidSendBodyData) &#123; self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount); &#125;&#125;//ä»»åŠ¡å®Œæˆçš„å›è°ƒæ–¹æ³•- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //åŒæ ·çš„å¥—è·¯ï¼Œè·å–å…³è”çš„ä»£ç†å¯¹è±¡ï¼Œæ‰‹åŠ¨è°ƒç”¨ä»£ç†å¯¹è±¡çš„è¿™ä¸ªæ–¹æ³•ï¼Œæ‰§è¡Œç”¨æˆ·è‡ªå®šä¹‰çš„å›è°ƒå— AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; &#125; if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error); &#125;&#125; ä»¥ä¸Šä»£ç æ˜¯NSURLSessionTaskDelegateçš„å›è°ƒæ–¹æ³•ï¼Œé€šè¿‡ä¸Šé¢çš„ä»£ç å¯ä»¥å‘ç°AFURLSessionManagerTaskDelegateçš„ä½œç”¨äº†ï¼ŒAFURLSessionManagerçš„ä»£ç†æ–¹æ³•ä¸­ä¼šæ ¹æ®taskè·å–åˆ°å¯¹åº”çš„delegateï¼Œå¦‚æœéœ€è¦æå‰å¤„ç†ä¸€äº›æ•°æ®å°±å…ˆå¤„ç†ï¼Œå¤„ç†å®Œæˆåæ‰‹åŠ¨è§¦å‘delegateä¸­çš„å¯¹åº”æ–¹æ³•ï¼Œç„¶åå…·ä½“çš„æ•°æ®å¤„ç†å°±äº¤ç”±AFURLSessionManagerTaskDelegateæ¥å¤„ç†ã€‚ç»§ç»­çœ‹å…¶ä»–ä»£ç†æ–¹æ³•: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//æ”¶åˆ°æœåŠ¡ç«¯å“åº”çš„ä»£ç†å›è°ƒæ–¹æ³•- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; //è°ƒç”¨ç”¨æˆ·è‡ªå®šä¹‰å›è°ƒå—ï¼Œæ‰§è¡Œå®Œæˆå›è°ƒå— NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; if (self.dataTaskDidReceiveResponse) &#123; disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; if (completionHandler) &#123; completionHandler(disposition); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; if (delegate) &#123; [self removeDelegateForTask:dataTask]; [self setDelegate:delegate forTask:downloadTask]; &#125; if (self.dataTaskDidBecomeDownloadTask) &#123; self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //è·å–ä»£ç†ï¼Œç„¶åè°ƒç”¨ä»£ç†çš„è¿™ä¸ªæ–¹æ³•ï¼Œæœ‰è‡ªå®šä¹‰å›è°ƒå—å°±æ‰§è¡Œ AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; [delegate URLSession:session dataTask:dataTask didReceiveData:data]; if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (self.dataTaskWillCacheResponse) &#123; cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse); &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125;- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123; if (self.didFinishEventsForBackgroundURLSession) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.didFinishEventsForBackgroundURLSession(session); &#125;); &#125;&#125; ä¸Šé¢çš„ä»£ç æ˜¯NSURLSessionDataDelegateçš„ä»£ç†æ–¹æ³•ï¼ŒåŒæ ·çš„ï¼Œå¦‚æœAFURLSessionManagerTaskDelegateèƒ½å“åº”çš„å…³äºæ•°æ®å¤„ç†çš„æ–¹æ³•éƒ½ä¼šé€šè¿‡taskæ‰¾åˆ°å¯¹åº”delegateåè°ƒç”¨å…¶å¯¹åº”çš„æ–¹æ³•ï¼Œç„¶åæ‰§è¡Œç”¨æˆ·è‡ªå®šä¹‰çš„å›è°ƒå—ï¼Œå¦‚æœä»£ç†ä¸èƒ½å“åº”çš„æ–¹æ³•å°±ç”±AFURLSessionManagerè‡ªè¡Œå¤„ç†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//ä¸‹è½½ä»»åŠ¡ä¸‹è½½æ–‡ä»¶å®Œæˆåçš„å›è°ƒæ–¹æ³•- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; //è·å–å¯¹åº”çš„ä»£ç†å¯¹è±¡ AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //å¦‚æœdownloadTaskDidFinishDownloadingå›è°ƒå—å­˜åœ¨å°±æ‰§è¡Œå®ƒæ¥è·å–ä¸€ä¸ªä¿å­˜æ–‡ä»¶çš„URLè·¯å¾„ if (self.downloadTaskDidFinishDownloading) &#123; NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); //å¦‚æœè¿™ä¸ªè·¯å¾„å­˜åœ¨å°±é€šè¿‡NSFileManageræ¥ç§»åŠ¨ï¼Œç§»åŠ¨å¤±è´¥å‘é€é€šçŸ¥ if (fileURL) &#123; delegate.downloadFileURL = fileURL; NSError *error = nil; if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo]; &#125; return; &#125; &#125; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location]; &#125;&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; //é€šè¿‡taskè·å–delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; //å¦‚æœdelegateå­˜åœ¨å°±è°ƒç”¨å…¶è¯¥æ–¹æ³• if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite]; &#125; //å¦‚æœå›è°ƒå—å­˜åœ¨å°±æ‰§è¡Œ if (self.downloadTaskDidWriteData) &#123; self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite); &#125;&#125;//åŒä¸Šå¥—è·¯- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes]; &#125; if (self.downloadTaskDidResume) &#123; self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes); &#125;&#125; åˆ°ç°åœ¨ä¸ºæ­¢ï¼ŒAFURLSessionManageræ‰€æœ‰æºç éƒ½çœ‹å®Œäº†ï¼Œä»£ç å°è£…äº†NSURLSessionå¹¶æä¾›äº†ç®€æ´çš„åˆ›å»ºNSURLSessionDataTaskã€NSURLSessionUploadTaskå’ŒNSURLSessionDownloadTaskå¯¹è±¡çš„æ–¹æ³•ï¼Œä½¿ç”¨äººå‘˜å¯ä»¥ä¸éœ€è¦è€ƒè™‘å…·ä½“çš„æ•°æ®å¤„ç†è¿‡ç¨‹ï¼Œæœ€ç®€å•çš„å¯ä»¥åªé€šè¿‡å›è°ƒå—æ¥è·å–ç½‘ç»œè¯·æ±‚çš„å„ç§ä¿¡æ¯ã€‚åœ¨å…·ä½“å®ç°ä¸Šï¼ŒAFURLSessionManageré€šè¿‡å®šä¹‰AFURLSessionManagerTaskDelegateæ¥åšå…·ä½“taskçš„æ•°æ®å¤„ç†ï¼Œè€ŒAFURLSessionManageråªå…³æ³¨äºé€šç”¨éƒ¨åˆ†çš„å®ç°ï¼Œå¹¶æä¾›å„ç§æ–¹æ³•å’Œå›è°ƒå—ç”¨äºå¤„ç†taskï¼Œä½¿å¾—ä»£ç ç»“æ„æ›´æ¸…æ™°ï¼ŒAFURLSessionManagerä»£ç†æ–¹æ³•ç»“æ„ä¹Ÿæ›´ç®€å•ã€‚ AFURLSessionManagerä¸ªäººæ€»ç»“ AFURLSessionManagerTaskDelegate æ˜¯ä¸ºäº†å¯¹åº”æ¯ä¸€ä¸ªtaskï¼Œå•ç‹¬å®šä¹‰ä¸€ä¸ªç±»ï¼Œè§£è€¦åˆï¼Œä»£ç é€»è¾‘æ›´æ¸…æ™° mutableData åœ¨è¯·æ±‚å®Œæˆä¹‹åç½®ä½ nilï¼ŒèŠ‚çœå†…å­˜ dispatch_semaphoreçš„ä½¿ç”¨ï¼Œä¿¡å·é‡çº¿ç¨‹åŒæ­¥ method swizzingå·§å¦™ç›‘å¬ task çš„ suspend å’Œ resume NSLock å®‰å…¨åŠ é”ï¼Œé¿å…å­—å…¸ä¸­å‡å¦‚çš„ delegate å’Œ taskä¸å¯¹åº”","categories":[{"name":"iOS","slug":"iOS","permalink":"https://nixzhang5.github.io/categories/iOS/"}],"tags":[{"name":"AFNetWorkingåŸç†","slug":"AFNetWorkingåŸç†","permalink":"https://nixzhang5.github.io/tags/AFNetWorkingåŸç†/"}]},{"title":"Github Blog With Hexo","slug":"hello-world","date":"2019-06-21T07:40:42.265Z","updated":"2019-06-24T10:16:01.754Z","comments":true,"path":"hello-world.html","link":"","permalink":"https://nixzhang5.github.io/hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://nixzhang5.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://nixzhang5.github.io/tags/hexo/"}]}]}